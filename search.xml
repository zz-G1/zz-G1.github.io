<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RPC协议</title>
      <link href="/2022/05/16/RPC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/05/16/RPC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2><span id="设计协议">设计协议</span></h2><p>相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以性能要求相对更高。但 HTTP 协议的数据包大小相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等；</p><p>还有一个更重要的原因是，HTTP 协议属于<strong>无状态协议</strong>，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接。因此，对于要求高性能的 RPC 来说，HTTP 协议基本很难满足需求，所以<br>RPC 会选择设计更紧凑的私有协议。</p><h3><span id="协议要点">协议要点：</span></h3><p>在协议头里面，我们除了会放<strong>协议长度</strong>、<strong>序列化方式</strong>，还会放一些像<strong>协议标示</strong>、<strong>消息 ID</strong>、<strong>消息类型</strong>这样的参数，而协议体一般只放<strong>请求接口方法</strong>、<strong>请求的业务参数值</strong>和一些<strong>扩展属性</strong>。这样一个完整的 RPC 协议大概就出来了，协议头是由一堆固定的长度参数组成，而协议体是根据请求接口和参数构造的，长度属于可变的，具体协议如下图所示：</p><p><img src="/2022/05/16/RPC%E5%8D%8F%E8%AE%AE/1652665800020.png" alt="1652665800020"></p><h4><span id="可扩展">可扩展：</span></h4><p>如果加新参数的话，首先不可以放在协议头，那么放在协议体中可以吗</p><p>答案是不可以的</p><p>因为协议体中的内容都是要经过序列和反序列化的，如果要获取到你参数的值，就必须把整个协议体里面的数据经过反序列化出来，在某些场景下这样做代价有点高</p><p>那就变成协议头（固定部分，扩展部分），协议体</p><p><img src="/2022/05/16/RPC%E5%8D%8F%E8%AE%AE/1652666060565.png" alt="1652666060565"></p><h2><span id="序列化和反序列化">序列化和反序列化</span></h2><p>实际上任何一种序列化框架，核心思想就是设计一种序列化协议，将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化</p><p>常见的序列化方式有：JDK,Json,Hessian,Protobuf序列化方式。</p><p>选择序列化方式要考虑的因素</p><ol><li><p>性能和效率</p></li><li><p>空间开销‘</p></li><li><p>通用性和兼容性</p></li><li><p>安全性</p></li></ol><p><img src="/2022/05/16/RPC%E5%8D%8F%E8%AE%AE/1652668771965.png" alt="1652668771965"></p><p>首选的还是 Hessian 与 Protobuf，因为他们在性能、时间开销、空间开销、通用性、兼容性和安全性上，都满足了我们的要求。其中 Hessian 在使用上更加方便，在对象的兼容性上更好；Protobuf 则更加高效，通用性上更有优势。</p><h3><span id="在使用过程中编码需注意那些问题">在使用过程中编码需注意那些问题</span></h3><p>   1.对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；<br>2. 入参对象与返回值对象体积不要太大，更不要传太大的集合；<br>3. 尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；<br>4. 对象不要有复杂的继承关系，最好不要有父子类的情况</p><h2><span id="io">IO</span></h2><h4><span id="零拷贝">零拷贝</span></h4><p>取消用户空间和内核空间的拷贝</p><p>应用进程的每一次读写可以直接将数据从内核区中取出或者写入，再通过DMA将内核中的数据拷贝到网卡或从网卡拷贝到内核。</p><p>所以解决方式就是使用户空间和内核空间的数据都在一个地方存取，那就是<strong>虚拟内存</strong>。</p><p>RPC协议在传输数据过程中，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包，所以消息都需要有边界。那么一端的机器收到消息之后，就需要对数据包进行处理，根据边界对数据包进行分割和合并，最终获得一条完整的消息。</p><p>收到消息后，对数据包的分割和合并，是在用户空间完成，还是在内核空间完成的</p><p>Netty 的零拷贝就是为了解决这个问题，在用户空间对数据操作进行优化。</p><p>Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。</p><p>那么 Netty 解决用户空间与内核空间之间的数据拷贝问题的方法：<br>Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socketd 的读写操作，最终的效果与虚拟内存所实现的效果是一样的。</p><h3><span id="spi">SPI</span></h3><p>设计RPC框架时，为了实现插件化架构，可将功能点抽象成接口，将接口与实现分离，并提供接口的默认实现</p><p>利用SPI（服务发现机制），可动态的为接口寻找服务</p><p><strong>实现</strong>：在Classpath 下的 METAINF/services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。</p><h3><span id="服务发现">服务发现</span></h3><p>还是最终一致性性能更好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重构</title>
      <link href="/2022/04/22/%E9%87%8D%E6%9E%84/"/>
      <url>/2022/04/22/%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/04/22/%E9%87%8D%E6%9E%84/1650624089842.png" alt="1650624089842"></p><h2><span id="参数过长">参数过长</span></h2><p><strong>影响</strong>：</p><p>方法不易被理解、使用，方法签名容易不稳定，不易维护</p><p>解决方法：反复使用提炼方法+内联方法，消除多余参数</p><p>​                   尽量把方法移进相关的类中</p><p>​                   如实体类中的get方法在其他类中没有被调用可以删除</p><p>​                   实际工作中，可以结合参数数量、以及自身对业务的理解，在 最小知道 和 保持对象完整性 之间进行权衡</p><h2><span id="全局变量">全局变量</span></h2><p><strong>影响</strong>：可以在任何位置进行修改，在使用过程中可能出现意想不到的值，并且没有任何机制可以探测出哪段代码进行了修改，导致定位困难</p><p><strong>改进目标</strong>：</p><p>降低代码耦合性，保持代码清晰，维护简单，降低由于对全局数据随意的改变引发bug的风险</p><p><strong>方法</strong>：封装变量，提炼函数</p><p>使用Convert To Instance Method替换项目中使用静态方法的地方，进行重构</p><p>如果想避免其他类中引用本类的字段，修饰符改为private</p><h2><span id="可变数据">可变数据</span></h2><p><strong>影响</strong>：</p><p>影响可维护性，在一处修改数据，却在另一处造成难以发现的破坏<br><strong>改进目标</strong>：</p><p>应用“数据不可变”：不可变性是强大的代码防腐剂<br><strong>方法</strong>：<br>封装变量、拆分变量、提炼函数、移除设值，函数、查询取代派生、Builder模式创建不可变对象、引用对象改为值对象、函数式编程等</p><h2><span id="发散式变化">发散式变化</span></h2><p><strong>定义</strong>：<br>某个模块经常因为不同的原因在不同的方向上发生变化<br><strong>影响</strong>：<br>通常，发散式变化是由于多个变化方向之间有较多的来回调用或者函数内部混合了多类处理逻辑。当处于多个不同上下文的外部行为发生变化时候，都会引起对同一个类或模块的修改，影响了代码的可读和可维护性<br><strong>改进目标</strong>：<br>提高代码组织结构、职责单一提升代码可读性、可维护性<br><strong>方法</strong>：<br>拆分阶段<br>搬移函数<br>提炼函数<br>提炼类</p><h2><span id="霰弹式修改">霰弹式修改</span></h2><p><strong>定义</strong>：</p><p>霰弹式修改：指的是如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改。此时，你所面临的坏味道就是霰弹式修改</p><p><strong>影响</strong>：</p><p>修改的地方四面散布，而且有可能修改之后导致其他异常结果</p><p><strong>改进目标</strong>：</p><p>更好的代码组织，更少的代码重复</p><p><strong>方法</strong>：<br>搬移函数、搬移字段、函数组合成类、函数组合成变换、拆分阶段、内联函数、内联类</p><h4><span id="clone的应用">clone的应用</span></h4><p>这里之所以使用 clone，是因为在跨边界调用场景下，直接更改原对象会有一定风险。<br>比如某些场景下，边界外更改对象可能改变边界内状态，或者调用方想维护多个状态时可能引发混乱。<br>因此一般涉及状态信息更新时，尽量不直接处理同一对象（使用clone），或不暴露完整对象（返回部分需要的属性）。<br>如果需要内部维护对象状态，又需要将完整对象暴露出去，就返回一个副本（比如当前案例，如果 clonePaySlip 需要在内部缓存，那么返回值应当进一步优化为：clonePaySlip.clone()）</p><h2><span id></span></h2><h2><span id="依恋情节">依恋情节</span></h2><p><strong>定义</strong>：<br>依恋情节/特性依恋:一个函数跟另一个模块中的函数或数据交流格外频繁，远胜于在自己所处模块内部的交流<br><strong>影响：</strong><br><strong>可读性、可维护性低</strong>：调用另一模块功能时往往需要打一套组合拳才能完成，需要知道过多的细节；往往会伴随有“内幕交易、重复代码、霰弹式修改……”<br><strong>改进目标</strong><br>将函数搬移到对应的类，解除跨模块的过多交流<br><strong>方法</strong><br>提炼函数、搬移函数<br>注：策略模式、访问者模式往往会带来依恋情节，这不是说这两个模式不可取。我们需要理解：<br><strong>从根本上来说，我们消除“依恋情节”和应用这些设计模式都是为了把一起变化的东西放到一块儿</strong></p><p> ——《重构，改善既有代码的设计》</p><h2><span id="数据泥团">数据泥团</span></h2><p><strong>定义</strong><br>总是成块出现的相同数据项，包括多个类中相同的字段、多个方法签名中相同的参数等<br><strong>影响</strong><br>成块出现的重复参数过多，影响阅读和理解，难维护<br><strong>改进目标</strong><br>减少相同的字段及入参，缩短入参列，简化函数调用<br><strong>方法</strong><br>提炼类  引入参数对象  保持对象完整性</p><p>Tip：内联</p><p>这里之所以能够直接内联，是因为字段是final的，只会读取，不会更新，大家可以尝试在非final上内联，IDEA会提示我们内联失败。因此当我们需要通过内联的方法消除字段时，需要先想办法把字段变为final的</p><p>Ctrl+Alt+N</p><p><img src="/2022/04/22/%E9%87%8D%E6%9E%84/1652272194373.png" alt="1652272194373"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动配置</title>
      <link href="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ol><li><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648952872902.png" alt="1648952872902"></li></ol><p><strong>@SpringBootApplication SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动springBoot的应用</strong></p><p>2.<img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648952954673.png" alt="1648952954673"></p><p>核心注解为@EnableAutoConfiguration，开启自动配置功能</p><p>3.@EnableAutoConfiguration中有两个核心注解：</p><hr><p><strong>@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)</strong></p><p>@AutoConfigurationPackage自动扫包的配置</p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953049026.png" alt="1648953049026"></p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953122408.png" alt="1648953122408"></p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953155312.png" alt="1648953155312"></p><p>扫描范围默认为当前文件所在包及其子包</p><p>4.@Import(AutoConfigurationImportSelector.class)</p><pre><code class="dart">//扫描具有META-INF/spring.factories文件的jar包任何一个springboot应用，都会引入spring-boot-autoconfigure，而spring.factories文件就在该包下面</code></pre><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953793994.png" alt="1648953793994"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bean</title>
      <link href="/2022/04/01/Bean/"/>
      <url>/2022/04/01/Bean/</url>
      
        <content type="html"><![CDATA[<h2><span id="循环依赖">循环依赖</span></h2><p>谈到循环依赖要先了解spring bean的生命周期</p><h3><span id="一-加载数据">一. 加载数据</span></h3><p>普通Java对象：以class作为模板创建出具体的实例</p><p>Spring Bean：除了用Class对象外，还用了BeanDefinition实例来描述对象信息</p><p>Spring在启动时需要扫描使用了 <strong>xml</strong>  <strong>注解</strong>  **javaconfig **中需要被Spring管理的Bean信息，随后把信息封装为BeanDefinition，最后把信息放在beanDefinitionMap中，key为beanName，value为BeanDefinition。</p><p>接着遍历beanDefinitionMap，执行BeanFactoryPostProcesser工厂后置处理器的处理逻辑。这里如果想获取bean的数据进行修改的话，通过自定义BeanFactoryPostProcesser来实现</p><h3><span id="二-实例化">二.  实例化</span></h3><h3><span id="三-属性填充">三. 属性填充</span></h3><h3><span id="四-初始化">四. 初始化</span></h3><p>判断该Bean是否实现了Aware相关的接口，如果存在则填充相关的资源</p><p>到了BeanPostProcessor后置处理器（是AOP实现的关键）</p><p>执行BeanPostProcessor相关子类的before方法</p><p>执行init方法，执行顺序为@PostConstruct，实现了initializingbean接口，是否自己定义了init-method方法。</p><h3><span id="五-使用">五.  使用</span></h3><h3><span id="六-销毁">六. 销毁</span></h3><p>看是否实现了diposableBean接口，执行destory方法，或者自己定义了destory-method属性</p><h3><span id="注解xmljavaconfig">注解，xml，javaconfig</span></h3><table><thead><tr><th></th><th>xml</th><th>注解</th><th>config</th></tr></thead><tbody><tr><td>便利性</td><td>不便利</td><td>便利</td><td>不便利</td></tr><tr><td>修改之后是否需要重编译</td><td>不</td><td>需要</td><td>需要</td></tr><tr><td>自由度</td><td>低</td><td>低</td><td>高</td></tr><tr><td>是否可以注入不是自己维护的类</td><td>可以</td><td>不可以</td><td>可以</td></tr></tbody></table><p>现在通常使用注解加config</p><p>只有当需要注入代码不是自己维护的第三方jar包中的类时，或者需要更为灵活地注入，比如说需要调用某个接口，查询数据，然后把这个数据赋值给要注入的对象，那么这时候就需要用到Java Config（面向接口开发）。</p><h2><span id="循环依赖">循环依赖</span></h2><p>A包含B，B包含A</p><p>使用三级缓存</p><p>singletonObjects：一级：正式对象</p><p>earlySingletonObjects：二级：半成品（考虑性能）</p><p>sinletonFactories：三级：工厂（为了代理，可以直接从里面拿代理对象，放在二级缓存）</p><p>创建A时：实例化后，把自己扔在三级缓存，key时beanName，value是ObjectFactory。</p><p>注入属性时发现B还没创建，然后实例化B，B属性注入A，A放在二级缓存中，然后B完成创建，自然A也就可以完成了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>select，poll，epoll</title>
      <link href="/2022/03/14/select%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
      <url>/2022/03/14/select%EF%BC%8Cpoll%EF%BC%8Cepoll/</url>
      
        <content type="html"><![CDATA[<p><strong>select、poll、epoll 区别总结：</strong></p><h2><span id="底层实现">底层实现</span></h2><p><strong>select/poll</strong></p><p>他俩没多大本质区别，都是用线性结构存储进程关注的socket集合，因此都需要遍历文件描述符集合来判断是否可以读写，时间复杂度为O（n），而且也需要在用户态和内核态之间拷贝文件描述符集合，消耗性能。</p><p><strong>epoll</strong></p><p>通过两个手段解决了上面的不足</p><ol><li>在内核中使用了红黑树来跟踪进程所有的待检测文件描述符，减少了内核和用户空间大量的数据拷贝和内存分配</li><li>使用了时间驱动的机制，内核里维护了一个链表来记录就绪事件。不需要轮询检测了</li></ol><h4><span id="1-支持一个进程所能打开的最大连接数">1、支持一个进程所能打开的最大连接数</span></h4><p><strong>select</strong></p><p>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><p><strong>poll</strong></p><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><p><strong>epoll</strong></p><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><h4><span id="2-fd剧增后带来的io效率问题">2、FD剧增后带来的IO效率问题</span></h4><p>select</p><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p><p><strong>poll</strong></p><p>同上</p><p><strong>epoll</strong></p><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><h4><span id="3-消息传递方式">3、 消息传递方式</span></h4><p><strong>select</strong></p><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><p><strong>poll</strong></p><p>同上</p><p><strong>epoll</strong></p><p>epoll通过内核和用户空间共享一块内存来实现的。（错的）</p>]]></content>
      
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“索引的树结构”</title>
      <link href="/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/"/>
      <url>/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h3><span id="查找结构的进化">查找结构的进化</span></h3><p>二分查找</p><p>二叉树</p><p>二叉平衡树</p><p>B-TREE ：二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小</p><p>缺点：业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及 CPU 高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。</p><p>B+TREE：非叶子节点只保存索引数据，叶子节点保存索引数据与<strong>业务数据所在的地址</strong></p><h4><span id></span></h4><ol><li><p>B+数据量相同的情况下，非叶子节点可以存放更多的数据，B+树会更加矮胖，io次数会更少</p></li><li><p>B+树有大量的冗余节点（非叶子结点），会让B+树在插入删除时的效率更高</p></li><li><p>B+树的叶子结点用双向链表连了起来，有益于范围查询，而B树只能遍历。</p></li></ol><p><strong>聚簇索引和非聚簇索引</strong></p><p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p><p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」</p><h3><span id="查询数据的过程">查询数据的过程</span></h3><p><strong>在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</strong></p><p>磁盘IO</p><p><strong>磁盘处理太慢太慢了</strong></p><ul><li>尽量减少 I/O 次数，比如可以使用缓存；</li><li>每次 I/O 尽量获取更多的数据；</li><li>每次 I/O 尽量获取有用的数据，当然相应的也间接减少总 I/O 次数</li></ul><p>总结：</p><ul><li>数据存储在磁盘（ SSD 跟 CPU 性能也不在一个量级），而磁盘处理数据很慢；</li><li>提高磁盘性能主要通过减少 I/O 次数，以及单次 I/O 有效数据量；</li><li>索引通过多阶（一个节点保存多个数据，指向多个子节点）使树的结构更矮胖，从而减少 I/O 次数；</li><li>索引通过 B+ 树，把业务数据与索引数据分离，来提高单次 I/O 有效数据量，从而减少 I/O 次数；</li><li>索引通过树数据的有序和「二分查找」（多阶树可以假设为多分查找），大大缩小查询范围；</li><li>索引针对的是单个字段或部分字段，数据量本身比一条记录的数据量要少的多，这样即使通过扫描的方式查询索引也比扫描数据库表本身快的多；</li></ul><h2><span id="事务">事务</span></h2><ul><li>持久性是通过 redo log （重做日志）来保证的；是物理日志，记录做了什么修改</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>一致性是binlog保证的 ，逻辑日志（有三种格式）statement，row包含操作的具体数据，mixed</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； </li></ul><h2><span id="死锁问题">死锁问题</span></h2><p>处理订单业务时，需要用到select…for update用来避免并发导致的幻读问题，但是这样的话就容易出现死锁</p><p>处理方法是破坏形成死锁的条件：<strong>打破循环等待条件</strong></p><ul><li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li></ul><ul><li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><h2><span id="关于count">关于count</span></h2><p><img src="/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/image-20220314151059566.png" alt="image-20220314151059566"></p><p>*<em>count(1)、 count(</em>)、 count(主键字段)**在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段)  来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p><h3><span id="优化count">优化count</span></h3><p>如果数据量很大，因为要全表扫描，所以也要花费不短的时间</p><p>1.使用explain 出现的rows 字段值就是  explain 命令对表 t_order 记录的估算值。</p><p>2.额外表保存记录值</p><h2><span id></span></h2><h2><span id="索引失效的情况"><strong>索引失效的情况</strong></span></h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>innoDB对MVCC的实现</title>
      <link href="/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见</p><p>这里用到了隐藏字段</p><p><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。</p><p><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</p><p>若聚簇索引记录DB_TRX_ID小于事务id则可见，如果不可见，则根据DB_ROLL_PTR取出快照记录的DB_TRX_ID再进行循环判断。</p><p><img src="/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20220227212834866.png" alt="image-20220227212834866"></p><p>实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <strong>Next-key Lock</strong> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h3><span id="对于读已提交和重复读">对于读已提交和重复读</span></h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li></ul><p>然后根据数据可见性算法，导致RC的问题为不可重复读，RR解决了不可重复读</p><p>详细实现：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496769&idx=1&sn=30990d141185303fd0c7ecf63c125b30&chksm=f98db0ebcefa39fda085edb2596398c046541851d9650a7a8328874476984e4caac1055c4c68&scene=178&cur_album_id=1955634887135199237#rd">消失的 100 万，炸了！ (qq.com)</a></p><p>–参考JavaGuide</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time_wait和close_wait</title>
      <link href="/2022/02/27/time-wait%E5%92%8Cclose-wait/"/>
      <url>/2022/02/27/time-wait%E5%92%8Cclose-wait/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/02/27/time-wait%E5%92%8Cclose-wait/image-20220227192546623.png" alt="image-20220227192546623"></p><p>客户端和服务器并不固定，看谁主动断开连接</p><h2><span id="time_wait">time_wait</span></h2><p>HTTP的交互跟上面画的那个图是不一样的，关闭连接的不是客户端，而是服务器，所以web服务器也是会出现大量的TIME_WAIT的情况的。</p><p>HTTP协议1.1版规定default行为是Keep-Alive，也就是会重用TCP连接传输多个 request/response，一个主要原因就是发现了这个问题</p><p>解决思路很简单，就是让服务器能够快速回收和重用那些TIME_WAIT的资源</p><p>对/etc/sysctl.conf文件进行修改</p><p>net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。</p><p>net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。</p><p>net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。</p><h2><span id="close_wait">close_wait</span></h2><p>从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p><p>将大量CLOSE_WAIT的解决办法总结为一句话那就是：查代码。因为问题出在服务器程序里头</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring知识点整理</title>
      <link href="/2022/02/27/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2022/02/27/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2><span id="spring-ioc-amp-aop">Spring IOC &amp; AOP</span></h2><p><strong>IoC（Inverse of Control:控制反转）</strong> </p><p>是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p><p>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p><strong>AOP</strong>（面相切面编程）</p><p>基于动态代理的，根据要代理的对象是否实现接口来判断是使用JDK代理还是CGlib代理</p><h2><span id="bean的线程问题">Bean的线程问题</span></h2><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。    </p><p>解决办法：</p><ol><li>​    避免在bean中定义可变的成员变量</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中</li></ol><h2><span id="bean的生命周期">Bean的生命周期</span></h2><p>Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期</p><p>由两组回调（call back）方法组成。</p><p>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：</p><p> InitializingBean 和 DisposableBean 回调接口</p><p> 针对特殊行为的其他 Aware 接口</p><p> Bean 配置文件中的 Custom init()方法和 destroy()方法</p><p> @PostConstruct 和@PreDestroy 注解方式</p><h2><span id="springbean的自动装配">SpringBean的自动装配</span></h2><p>Spring 容器可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系</p><h3><span id="如何开启基于注解的自动装配"><strong>如何开启基于注解的自动装配？</strong></span></h3><p>两种方式</p><p>1、引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a></bean></p><pre><code class="java">&lt;beans&gt;  &lt;context:annotation-config /&gt; &lt;/beans&gt; </code></pre><p>2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor</p><pre><code class="java">&lt;beans&gt;  &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt; &lt;/beans&gt;</code></pre><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件中</p><h3><span id="autowired">@Autowired</span></h3><p>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。</p><h3><span id="qualifier">@Qualifier</span></h3><pre><code>&lt;bean id=&quot;customer&quot; class=&quot;com.somnus.common.Customer&quot; /&gt;  &lt;bean id=&quot;personA&quot; class=&quot;com.somnus.common.Person&quot; &gt;  &lt;property name=&quot;name&quot; value=&quot;lokesh&quot; /&gt; &lt;/bean&gt;  &lt;bean id=&quot;personB&quot; class=&quot;com.somnus.common.Person&quot; &gt;  &lt;property name=&quot;name&quot; value=&quot;alex&quot; /&gt; &lt;/bean&gt; </code></pre><pre><code>public class Customer&#123;  @Autowired  @Qualifier(&quot;personA&quot;)  private Person person; &#125; </code></pre><p>给Spring指定自动装配哪个bean</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> spring boot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>源码解析：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb</a></p><h1><span id="1构造函数">1.构造函数</span></h1><p>有三种</p><p><img src="/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/image-20220209130002676.png" alt="image-20220209130002676"></p><p>说第一种无参构造，默认初始容量为10</p><h1><span id="2add函数">2.add函数</span></h1><pre><code class="java">    /**     * 将指定的元素追加到此列表的末尾。     */    public boolean add(E e) &#123;   //添加元素之前，先调用ensureCapacityInternal方法        ensureCapacityInternal(size + 1);  // Increments modCount!!        //这里看到ArrayList添加元素的实质就相当于为数组赋值        elementData[size++] = e;        return true;    &#125;</code></pre><p>进入add方法后调用<strong>ensureCapacityInternal</strong> 方法，进入<strong>ensureCapacityInternal</strong>方法后初始化容量，然后调用<strong>ensureExplicitCapacity</strong>判断是否需要扩容，</p><p>，<strong>grow</strong>方法是实现扩容的方法，需要扩容则扩大1.5位，使用位运算。然后调用<strong>Arrays.copyOf</strong>方法将<strong>elementData</strong>数组指向新的内存空间<strong>newCapacity</strong>的连续空间<br>从此方法中我们可以清晰的看出其实<strong>ArrayList</strong>扩容的本质就是计算出新的扩容数组的<strong>size</strong>后实例化，并将原有数组内容复制到新数组中去。</p><pre><code class="java">  //得到最小扩容量    private void ensureCapacityInternal(int minCapacity) &#123;        //第二次调用ensureCapacityInternal方法后if判断后为假，因为不是空数组了        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;              // 获取默认的容量和传入参数的较大值            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);        &#125;        ensureExplicitCapacity(minCapacity);    &#125;  //判断是否需要扩容    private void ensureExplicitCapacity(int minCapacity) &#123;        modCount++;        // overflow-conscious code        if (minCapacity - elementData.length &gt; 0)            //调用grow方法进行扩容，调用此方法代表已经开始扩容了            grow(minCapacity);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/01/28/JVM/"/>
      <url>/2022/01/28/JVM/</url>
      
        <content type="html"><![CDATA[<hr><h1><span id="jvm">JVM</span></h1><h2><span id="一-什么是jvm">一、什么是JVM</span></h2><h3><span id="定义">定义</span></h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3><span id="好处">好处</span></h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3><span id="比较">比较</span></h3><p>JVM JRE JDK的区别</p><p><img src="/2022/01/28/JVM/image-20220128120907409.png" alt="image-20220128120907409"></p><h2><span id="二-内存结构">二、内存结构</span></h2><h3><span id="整体架构"><strong>整体架构</strong></span></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p><h3><span id="1-程序计数器">1、程序计数器</span></h3><h4><span id="作用">作用</span></h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4><span id="特点">特点</span></h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3><span id="2-虚拟机栈">2、虚拟机栈</span></h3><h4><span id="定义">定义</span></h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>（栈顶部的第一个方法）</li></ul><h4><span id="演示">演示</span></h4><p>代码</p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        method1();    &#125;    private static void method1() &#123;        method2(1, 2);    &#125;    private static int method2(int a, int b) &#123;        int c = a + b;        return c;    &#125;&#125;Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4><span id="问题辨析">问题辨析</span></h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>看变量是被线程私有还是共享，共享则不安全</li><li>看变量的作用范围</li><li><img src="/2022/01/28/JVM/image-20220202214904660.png" alt="image-20220202214904660"></li></ul></li></ul><h4><span id="内存溢出">内存溢出</span></h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4><span id="线程运行诊断">线程运行诊断</span></h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3><span id="3-本地方法栈">3、本地方法栈</span></h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3><span id="4-堆">4、堆</span></h3><h4><span id="定义">定义</span></h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4><span id="特点">特点</span></h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4><span id="堆内存溢出">堆内存溢出</span></h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4><span id="堆内存诊断">堆内存诊断</span></h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3><span id="5-方法区">5、方法区</span></h3><h4><span id="结构">结构</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p><h4><span id="内存溢出">内存溢出</span></h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4><span id="常量池">常量池</span></h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre><code>F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.javaCopy</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre><code>javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="/2022/01/28/JVM/image-20220203213504873.png" alt="image-20220203213504873"></p></li><li><p>常量池</p><p><img src="/2022/01/28/JVM/image-20220203213602701.png" alt="image-20220203213602701"></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><img src="/2022/01/28/JVM/image-20220203213712499.png" alt="image-20220203213712499"></p></li></ul></li></ul><h4><span id="运行时常量池">运行时常量池</span></h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4><span id="常量池与串池的关系">常量池与串池的关系</span></h4><h5><span id="串池stringtable"><strong>串池</strong>StringTable</span></h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><pre><code class="java">public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;         String b = &quot;b&quot;;        String ab = &quot;ab&quot;;    &#125;&#125;Copy</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="java">0: ldc           #2                  // String a2: astore_13: ldc           #3                  // String b5: astore_26: ldc           #4                  // String ab8: astore_39: returnCopy</code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code>public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;        String b = &quot;b&quot;;        String ab = &quot;ab&quot;;        //拼接字符串对象来创建新的字符串        String ab2 = a+b;     &#125;&#125;Copy</code></pre><p>反编译后的结果</p><pre><code class="java">     Code:      stack=2, locals=5, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        29: returnCopy</code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="java">String ab = &quot;ab&quot;;String ab2 = a+b;//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中System.out.println(ab == ab2);Copy</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="java">public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;        String b = &quot;b&quot;;        String ab = &quot;ab&quot;;        String ab2 = a+b;        //使用拼接字符串的方法创建字符串        String ab3 = &quot;a&quot; + &quot;b&quot;;    &#125;&#125;Copy</code></pre><p>反编译后的结果</p><pre><code class="java">       Code:      stack=2, locals=6, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        //ab3初始化时直接从串池中获取字符串        29: ldc           #4                  // String ab        31: astore        5        33: returnCopy</code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5><span id="intern方法-18">intern方法 1.8</span></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);        //调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象        String st2 = str.intern();        //给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回        String str3 = &quot;ab&quot;;        //因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true        System.out.println(str == st2);        System.out.println(str == str3);    &#125;&#125;Copy</code></pre><p><strong>例2</strong></p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        //此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中        String str3 = &quot;ab&quot;;        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);        //此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;        String str2 = str.intern();        //false        System.out.println(str == str2);        //false        System.out.println(str == str3);        //true        System.out.println(str2 == str3);    &#125;&#125;Copy</code></pre><h5><span id="intern方法-16">intern方法 1.6</span></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4><span id="stringtable-垃圾回收">StringTable 垃圾回收</span></h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4><span id="stringtable调优">StringTable调优</span></h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><pre><code>-XX:StringTableSize=xxxxCopy</code></pre></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3><span id="6-直接内存">6、直接内存</span></h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4><span id="文件读写流程">文件读写流程</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4><span id="释放原理">释放原理</span></h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code>//通过ByteBuffer申请1M的直接内存ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);Copy</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><pre><code>public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;Copy</code></pre><p>DirectByteBuffer类</p><pre><code>DirectByteBuffer(int cap) &#123;   // package-private       super(-1, 0, cap, cap);    boolean pa = VM.isDirectMemoryPageAligned();    int ps = Bits.pageSize();    long size = Math.max(1L, (long)cap + (pa ? ps : 0));    Bits.reserveMemory(size, cap);    long base = 0;    try &#123;        base = unsafe.allocateMemory(size); //申请内存    &#125; catch (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        throw x;    &#125;    unsafe.setMemory(base, size, (byte) 0);    if (pa &amp;&amp; (base % ps != 0)) &#123;        // Round up to page boundary        address = base + ps - (base &amp; (ps - 1));    &#125; else &#123;        address = base;    &#125;    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象    att = null;&#125;Copy</code></pre><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><pre><code>public void clean() &#123;       if (remove(this)) &#123;           try &#123;               this.thunk.run(); //调用run方法           &#125; catch (final Throwable var2) &#123;               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                   public Void run() &#123;                       if (System.err != null) &#123;                           (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();                       &#125;                       System.exit(1);                       return null;                   &#125;               &#125;);           &#125;Copy</code></pre><p>对应对象的run方法</p><pre><code>public void run() &#123;    if (address == 0) &#123;        // Paranoia        return;    &#125;    unsafe.freeMemory(address); //释放直接内存中占用的内存    address = 0;    Bits.unreserveMemory(size, capacity);&#125;Copy</code></pre><h5><span id="直接内存的回收机制总结">直接内存的回收机制总结</span></h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2><span id="三-垃圾回收">三、垃圾回收</span></h2><h3><span id="1-如何判断对象可以回收">1、如何判断对象可以回收</span></h3><h4><span id="引用计数法">引用计数法</span></h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p><h4><span id="可达性分析算法">可达性分析算法</span></h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4><span id="五种引用">五种引用</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p><h5><span id="强引用">强引用</span></h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5><span id="软引用">软引用</span></h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6><span id="软引用的使用">软引用的使用</span></h6><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        final int _4M = 4*1024*1024;        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);    &#125;&#125;Copy</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        final int _4M = 4*1024*1024;        //使用引用队列，用于移除引用为空的软引用对象        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);        //遍历引用队列，如果有元素，则移除        Reference&lt;? extends byte[]&gt; poll = queue.poll();        while(poll != null) &#123;            //引用队列不为空，则从集合中移除该元素            list.remove(poll);            //移动到引用队列中的下一个元素            poll = queue.poll();        &#125;    &#125;&#125;Copy</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5><span id="弱引用">弱引用</span></h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5><span id="虚引用"><strong>虚引用</strong></span></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5><span id="终结器引用">终结器引用</span></h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5><span id="引用队列">引用队列</span></h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3><span id="2-垃圾回收算法">2、垃圾回收算法</span></h3><h4><span id="标记-清除">标记-清除</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4><span id="标记-整理">标记-整理</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4><span id="复制">复制</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3><span id="3-分代回收">3、分代回收</span></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p><h4><span id="回收流程">回收流程</span></h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4><span id="gc-分析">GC 分析</span></h4><h5><span id="大对象处理策略">大对象处理策略</span></h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5><span id="线程内存溢出">线程内存溢出</span></h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3><span id="4-垃圾回收器">4、垃圾回收器</span></h3><h4><span id="相关概念">相关概念</span></h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4><span id="串行">串行</span></h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5><span id="serial-收集器">Serial 收集器</span></h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5><span id="parnew-收集器">ParNew 收集器</span></h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5><span id="serial-old-收集器">Serial Old 收集器</span></h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4><span id="吞吐量优先">吞吐量优先</span></h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p><h5><span id="parallel-scavenge-收集器">Parallel Scavenge 收集器</span></h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5><span id="parallel-old-收集器"><strong>Parallel Old 收集器</strong></span></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4><span id="响应时间优先">响应时间优先</span></h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p><h5><span id="cms-收集器">CMS 收集器</span></h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4><span id="g1">G1</span></h4><h5><span id="定义"><strong>定义</strong>：</span></h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p><h5><span id="适用场景">适用场景</span></h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p><h5><span id="g1垃圾回收阶段">G1垃圾回收阶段</span></h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5><span id="young-collection">Young Collection</span></h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p><h5><span id="young-collection-cm">Young Collection + CM</span></h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p><h5><span id="mixed-collection">Mixed Collection</span></h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p><h5><span id="full-gc">Full GC</span></h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5><span id="young-collection-跨代引用">Young Collection 跨代引用</span></h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p><h5><span id="remark">Remark</span></h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p><h5><span id="jdk-8u20-字符串去重">JDK 8u20 字符串去重</span></h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5><span id="jdk-8u40-并发标记类卸载">JDK 8u40 并发标记类卸载</span></h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5><span id="jdk-8u60-回收巨型对象">JDK 8u60 回收巨型对象</span></h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p><h3><span id="5-gc-调优">5、GC 调优</span></h3><p>查看虚拟机参数命令</p><pre><code>&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;Copy</code></pre><p>可以根据参数去查询具体的信息</p><h4><span id="调优领域">调优领域</span></h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4><span id="确定目标">确定目标</span></h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4><span id="最快的gc是不发生gc">最快的GC是不发生GC</span></h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4><span id="新生代调优">新生代调优</span></h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4><span id="幸存区调优">幸存区调优</span></h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4><span id="老年代调优">老年代调优</span></h4><h2><span id="四-类加载与字节码技术">四、类加载与字节码技术</span></h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p><h3><span id="1-类文件结构">1、类文件结构</span></h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><pre><code>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 640000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14Copy</code></pre><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><pre><code>u4              magicu2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-1];    u2             access_flags;    u2             this_class;    u2             super_class;   u2             interfaces_count;    u2             interfaces[interfaces_count];   u2             fields_count;    field_info     fields[fields_count];   u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];Copy</code></pre><h4><span id="魔数">魔数</span></h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4><span id="版本">版本</span></h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4><span id="常量池">常量池</span></h4><p>见资料文件</p><p>…略</p><h3><span id="2-字节码指令">2、字节码指令</span></h3><p>可参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4><span id="javap工具">javap工具</span></h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code>javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopyF:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified 2020-6-6; size 434 bytes  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from &quot;Demo1.java&quot;public class com.nyima.JVM.day5.Demo1  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #18            // hello world   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #21            // com/nyima/JVM/day5/Demo1   #6 = Class              #22            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               ([Ljava/lang/String;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #16 = Class              #23            // java/lang/System  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;  #18 = Utf8               hello world  #19 = Class              #26            // java/io/PrintStream  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/String;)V&#123;  public com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #3                  // String hello world         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 9: 0        line 10: 8&#125;Copy</code></pre><h4><span id="图解方法执行流程">图解方法执行流程</span></h4><p>代码</p><pre><code>public class Demo3_1 &#123;        public static void main(String[] args) &#123;                int a = 10;                int b = Short.MAX_VALUE + 1;                int c = a + b;                System.out.println(c);       &#125; &#125;Copy</code></pre><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><pre><code>a = 10Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4><span id="通过字节码指令来分析问题">通过字节码指令来分析问题</span></h4><p>代码</p><pre><code>public class Demo2 &#123;    public static void main(String[] args) &#123;        int i=0;        int x=0;        while(i&lt;10) &#123;            x = x++;            i++;        &#125;        System.out.println(x); //接过为0    &#125;&#125;Copy</code></pre><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><pre><code>Code:     stack=2, locals=3, args_size=1    //操作数栈分配2个空间，局部变量表分配3个空间        0: iconst_0    //准备一个常数0        1: istore_1    //将常数0放入局部变量表的1号槽位 i=0        2: iconst_0    //准备一个常数0        3: istore_2    //将常数0放入局部变量的2号槽位 x=0            4: iload_1        //将局部变量表1号槽位的数放入操作数栈中        5: bipush        10    //将数字10放入操作数栈中，此时操作数栈中有2个数        7: if_icmpge     21    //比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空       10: iload_2        //将局部变量2号槽位的数放入操作数栈中，放入的值是0       11: iinc          2, 1    //将局部变量2号槽位的数加1，自增后，槽位中的值为1       14: istore_2    //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0       15: iinc          1, 1 //1号槽位的值自增1       18: goto          4 //跳转到第4条指令       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       24: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       28: returnCopy</code></pre><h4><span id="构造方法">构造方法</span></h4><h5><span id="cinitv">cinit()V</span></h5><pre><code>public class Demo3 &#123;    static int i = 10;    static &#123;        i = 20;    &#125;    static &#123;        i = 30;    &#125;    public static void main(String[] args) &#123;        System.out.println(i); //结果为30    &#125;&#125;Copy</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><pre><code>stack=1, locals=0, args_size=0         0: bipush        10         2: putstatic     #3                  // Field i:I         5: bipush        20         7: putstatic     #3                  // Field i:I        10: bipush        30        12: putstatic     #3                  // Field i:I        15: returnCopy</code></pre><h5><span id="initv">init()V</span></h5><pre><code>public class Demo4 &#123;    private String a = &quot;s1&quot;;    &#123;        b = 20;    &#125;    private int b = 10;    &#123;        a = &quot;s2&quot;;    &#125;    public Demo4(String a, int b) &#123;        this.a = a;        this.b = b;    &#125;    public static void main(String[] args) &#123;        Demo4 d = new Demo4(&quot;s3&quot;, 30);        System.out.println(d.a);        System.out.println(d.b);    &#125;&#125;Copy</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><pre><code>Code:     stack=2, locals=3, args_size=3        0: aload_0        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V        4: aload_0        5: ldc           #2                  // String s1        7: putfield      #3                  // Field a:Ljava/lang/String;       10: aload_0       11: bipush        20       13: putfield      #4                  // Field b:I       16: aload_0       17: bipush        10       19: putfield      #4                  // Field b:I       22: aload_0       23: ldc           #5                  // String s2       25: putfield      #3                  // Field a:Ljava/lang/String;       //原始构造方法在最后执行       28: aload_0       29: aload_1       30: putfield      #3                  // Field a:Ljava/lang/String;       33: aload_0       34: iload_2       35: putfield      #4                  // Field b:I       38: returnCopy</code></pre><h4><span id="方法调用">方法调用</span></h4><pre><code>public class Demo5 &#123;    public Demo5() &#123;    &#125;    private void test1() &#123;    &#125;    private final void test2() &#123;    &#125;    public void test3() &#123;    &#125;    public static void test4() &#123;    &#125;    public static void main(String[] args) &#123;        Demo5 demo5 = new Demo5();        demo5.test1();        demo5.test2();        demo5.test3();        Demo5.test4();    &#125;&#125;Copy</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><pre><code>Code:      stack=2, locals=2, args_size=1         0: new           #2                  // class com/nyima/JVM/day5/Demo5          3: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: aload_1         9: invokespecial #4                  // Method test1:()V        12: aload_1        13: invokespecial #5                  // Method test2:()V        16: aload_1        17: invokevirtual #6                  // Method test3:()V        20: invokestatic  #7                  // Method test4:()V        23: returnCopy</code></pre><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4><span id="多态原理">多态原理</span></h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4><span id="异常处理">异常处理</span></h4><h5><span id="try-catch">try-catch</span></h5><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125;catch (Exception e) &#123;            i = 20;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码指令</p><pre><code>Code:     stack=1, locals=3, args_size=1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          12        8: astore_2        9: bipush        20       11: istore_1       12: return     //多出来一个异常表     Exception table:        from    to  target type            2     5     8   Class java/lang/ExceptionCopy</code></pre><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5><span id="多个single-catch">多个single-catch</span></h5><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125;catch (ArithmeticException e) &#123;            i = 20;        &#125;catch (Exception e) &#123;            i = 30;        &#125;    &#125;&#125;Copy</code></pre><p>对应的字节码</p><pre><code>Code:     stack=1, locals=3, args_size=1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          19        8: astore_2        9: bipush        20       11: istore_1       12: goto          19       15: astore_2       16: bipush        30       18: istore_1       19: return     Exception table:        from    to  target type            2     5     8   Class java/lang/ArithmeticException            2     5    15   Class java/lang/ExceptionCopy</code></pre><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5><span id="finally">finally</span></h5><pre><code>public class Demo2 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125; catch (Exception e) &#123;            i = 20;        &#125; finally &#123;            i = 30;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=4, args_size=1        0: iconst_0        1: istore_1        //try块        2: bipush        10        4: istore_1        //try块执行完后，会执行finally            5: bipush        30        7: istore_1        8: goto          27       //catch块            11: astore_2 //异常信息放入局部变量表的2号槽位       12: bipush        20       14: istore_1       //catch块执行完后，会执行finally               15: bipush        30       17: istore_1       18: goto          27       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码          21: astore_3       22: bipush        30       24: istore_1       25: aload_3       26: athrow  //抛出异常       27: return     Exception table:        from    to  target type            2     5    11   Class java/lang/Exception            2     5    21   any           11    15    21   anyCopy</code></pre><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5><span id="finally中的return">finally中的return</span></h5><pre><code>public class Demo3 &#123;    public static void main(String[] args) &#123;        int i = Demo3.test();        //结果为20        System.out.println(i);    &#125;    public static int test() &#123;        int i;        try &#123;            i = 10;            return i;        &#125; finally &#123;            i = 20;            return i;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=3, args_size=0        0: bipush        10        2: istore_0        3: iload_0        4: istore_1  //暂存返回值        5: bipush        20        7: istore_0        8: iload_0        9: ireturn    //ireturn会返回操作数栈顶的整型值20       //如果出现异常，还是会执行finally块中的内容，没有抛出异常       10: astore_2       11: bipush        20       13: istore_0       14: iload_0       15: ireturn    //这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！     Exception table:        from    to  target type            0     5    10   anyCopy</code></pre><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5><span id="被吞掉的异常">被吞掉的异常</span></h5><pre><code>public class Demo3 &#123;   public static void main(String[] args) &#123;      int i = Demo3.test();      //最终结果为20      System.out.println(i);   &#125;   public static int test() &#123;      int i;      try &#123;         i = 10;         //这里应该会抛出异常         i = i/0;         return i;      &#125; finally &#123;         i = 20;         return i;      &#125;   &#125;&#125;Copy</code></pre><p>会发现打印结果为20，并未抛出异常</p><h5><span id="finally不带return">finally不带return</span></h5><pre><code>public class Demo4 &#123;    public static void main(String[] args) &#123;        int i = Demo4.test();        System.out.println(i);    &#125;    public static int test() &#123;        int i = 10;        try &#123;            return i;        &#125; finally &#123;            i = 20;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=3, args_size=0        0: bipush        10        2: istore_0 //赋值给i 10        3: iload_0    //加载到操作数栈顶        4: istore_1 //加载到局部变量表的1号位置        5: bipush        20        7: istore_0 //赋值给i 20        8: iload_1 //加载局部变量表1号位置的数10到操作数栈        9: ireturn //返回操作数栈顶元素 10       10: astore_2       11: bipush        20       13: istore_0       14: aload_2 //加载异常       15: athrow //抛出异常     Exception table:        from    to  target type            3     5    10   anyCopy</code></pre><h4><span id="synchronized">Synchronized</span></h4><pre><code>public class Demo5 &#123;    public static void main(String[] args) &#123;        int i = 10;        Lock lock = new Lock();        synchronized (lock) &#123;            System.out.println(i);        &#125;    &#125;&#125;class Lock&#123;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=2, locals=5, args_size=1        0: bipush        10        2: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V       10: astore_2 //剩下的一份放到局部变量表的2号位置       11: aload_2 //加载到操作数栈       12: dup //复制一份，放到操作数栈，用于加锁时消耗       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用       14: monitorenter //加锁       //锁住后代码块中的操作           15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       18: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       //加载局部变量表中三号槽位对象的引用，用于解锁           22: aload_3           23: monitorexit //解锁       24: goto          34       //异常操作           27: astore        4       29: aload_3       30: monitorexit //解锁       31: aload         4       33: athrow       34: return     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。           Exception table:        from    to  target type           15    24    27   any           27    31    27   anyCopy</code></pre><h3><span id="3-编译期处理">3、编译期处理</span></h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4><span id="默认构造函数">默认构造函数</span></h4><pre><code>public class Candy1 &#123;&#125;Copy</code></pre><p>经过编译期优化后</p><pre><code>public class Candy1 &#123;   //这个无参构造器是java编译器帮我们加上的   public Candy1() &#123;      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V      super();   &#125;&#125;Copy</code></pre><h4><span id="自动拆装箱">自动拆装箱</span></h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><pre><code>public class Demo2 &#123;   public static void main(String[] args) &#123;      Integer x = 1;      int y = x;   &#125;&#125;Copy</code></pre><p>转换过程如下</p><pre><code>public class Demo2 &#123;   public static void main(String[] args) &#123;      //基本类型赋值给包装类型，称为装箱      Integer x = Integer.valueOf(1);      //包装类型赋值给基本类型，称谓拆箱      int y = x.intValue();   &#125;&#125;Copy</code></pre><h4><span id="泛型集合取值">泛型集合取值</span></h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><pre><code>public class Demo3 &#123;   public static void main(String[] args) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      list.add(10);      Integer x = list.get(0);   &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:    stack=2, locals=3, args_size=1       0: new           #2                  // class java/util/ArrayList       3: dup       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V       7: astore_1       8: aload_1       9: bipush        10      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      //这里进行了泛型擦除，实际调用的是add(Objcet o)      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      19: pop      20: aload_1      21: iconst_0      //这里也进行了泛型擦除，实际调用的是get(Object o)         22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;//这里进行了类型转换，将Object转换成了Integer      27: checkcast     #7                  // class java/lang/Integer      30: astore_2      31: returnCopy</code></pre><p>所以调用get函数取值时，有一个类型转换的操作</p><pre><code>Integer x = (Integer) list.get(0);Copy</code></pre><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><pre><code>int x = (Integer) list.get(0).intValue();Copy</code></pre><h4><span id="可变参数">可变参数</span></h4><pre><code>public class Demo4 &#123;   public static void foo(String... args) &#123;      //将args赋值给arr，可以看出String...实际就是String[]       String[] arr = args;      System.out.println(arr.length);   &#125;   public static void main(String[] args) &#123;      foo(&quot;hello&quot;, &quot;world&quot;);   &#125;&#125;Copy</code></pre><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><pre><code>public class Demo4 &#123;   public Demo4 &#123;&#125;       public static void foo(String[] args) &#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   public static void main(String[] args) &#123;      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);   &#125;&#125;Copy</code></pre><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4><span id="foreach">foreach</span></h4><pre><code>public class Demo5 &#123;    public static void main(String[] args) &#123;        //数组赋初值的简化写法也是一种语法糖。        int[] arr = &#123;1, 2, 3, 4, 5&#125;;        for(int x : arr) &#123;            System.out.println(x);        &#125;    &#125;&#125;Copy</code></pre><p>编译器会帮我们转换为</p><pre><code>public class Demo5 &#123;    public Demo5 &#123;&#125;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;        for(int i=0; i&lt;arr.length; ++i) &#123;            int x = arr[i];            System.out.println(x);        &#125;    &#125;&#125;Copy</code></pre><p><strong>如果是集合使用foreach</strong></p><pre><code>public class Demo5 &#123;   public static void main(String[] args) &#123;      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);      for (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;Copy</code></pre><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><pre><code>public class Demo5 &#123;    public Demo5 &#123;&#125;       public static void main(String[] args) &#123;      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);      //获得该集合的迭代器      Iterator&lt;Integer&gt; iterator = list.iterator();      while(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;Copy</code></pre><h4><span id="switch字符串">switch字符串</span></h4><pre><code>public class Demo6 &#123;   public static void main(String[] args) &#123;      String str = &quot;hello&quot;;      switch (str) &#123;         case &quot;hello&quot; :            System.out.println(&quot;h&quot;);            break;         case &quot;world&quot; :            System.out.println(&quot;w&quot;);            break;         default:            break;      &#125;   &#125;&#125;Copy</code></pre><p>在编译器中执行的操作</p><pre><code>public class Demo6 &#123;   public Demo6() &#123;         &#125;   public static void main(String[] args) &#123;      String str = &quot;hello&quot;;      int x = -1;      //通过字符串的hashCode+value来判断是否匹配      switch (str.hashCode()) &#123;         //hello的hashCode         case 99162322 :            //再次比较，因为字符串的hashCode有可能相等            if(str.equals(&quot;hello&quot;)) &#123;               x = 0;            &#125;            break;         //world的hashCode         case 11331880 :            if(str.equals(&quot;world&quot;)) &#123;               x = 1;            &#125;            break;         default:            break;      &#125;      //用第二个switch在进行输出判断      switch (x) &#123;         case 0:            System.out.println(&quot;h&quot;);            break;         case 1:            System.out.println(&quot;w&quot;);            break;         default:            break;      &#125;   &#125;&#125;Copy</code></pre><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4><span id="switch枚举">switch枚举</span></h4><pre><code>public class Demo7 &#123;   public static void main(String[] args) &#123;      SEX sex = SEX.MALE;      switch (sex) &#123;         case MALE:            System.out.println(&quot;man&quot;);            break;         case FEMALE:            System.out.println(&quot;woman&quot;);            break;         default:            break;      &#125;   &#125;&#125;enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><p>编译器中执行的代码如下</p><pre><code>public class Demo7 &#123;   /**         * 定义一个合成类（仅 jvm 使用，对我们不可见）         * 用来映射枚举的 ordinal 与数组元素的关系         * 枚举的 ordinal 表示枚举对象的序号，从 0 开始         * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1         */    static class $MAP &#123;      //数组大小即为枚举元素个数，里面存放了case用于比较的数字      static int[] map = new int[2];      static &#123;         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1         map[SEX.MALE.ordinal()] = 1;         map[SEX.FEMALE.ordinal()] = 2;      &#125;   &#125;   public static void main(String[] args) &#123;      SEX sex = SEX.MALE;      //将对应位置枚举元素的值赋给x，用于case操作      int x = $MAP.map[sex.ordinal()];      switch (x) &#123;         case 1:            System.out.println(&quot;man&quot;);            break;         case 2:            System.out.println(&quot;woman&quot;);            break;         default:            break;      &#125;   &#125;&#125;enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><h4><span id="枚举类">枚举类</span></h4><pre><code>enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><p>转换后的代码</p><pre><code>public final class Sex extends Enum&lt;Sex&gt; &#123;      //对应枚举类中的元素   public static final Sex MALE;       public static final Sex FEMALE;       private static final Sex[] $VALUES;       static &#123;               //调用构造函数，传入枚举元素的值及ordinal        MALE = new Sex(&quot;MALE&quot;, 0);            FEMALE = new Sex(&quot;FEMALE&quot;, 1);           $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;    &#125;        //调用父类中的方法    private Sex(String name, int ordinal) &#123;             super(name, ordinal);        &#125;       public static Sex[] values() &#123;          return $VALUES.clone();      &#125;    public static Sex valueOf(String name) &#123;         return Enum.valueOf(Sex.class, name);      &#125;    &#125;Copy</code></pre><h4><span id="匿名内部类">匿名内部类</span></h4><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(&quot;running...&quot;);         &#125;      &#125;;   &#125;&#125;Copy</code></pre><p>转换后的代码</p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      //用额外创建的类来创建匿名内部类对象      Runnable runnable = new Demo8$1();   &#125;&#125;//创建了一个额外的类，实现了Runnable接口final class Demo8$1 implements Runnable &#123;   public Demo8$1() &#123;&#125;   @Override   public void run() &#123;      System.out.println(&quot;running...&quot;);   &#125;&#125;Copy</code></pre><p>如果匿名内部类中引用了<strong>局部变量</strong></p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      int x = 1;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;Copy</code></pre><p>转化后代码</p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      int x = 1;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;final class Demo8$1 implements Runnable &#123;   //多创建了一个变量   int val$x;   //变为了有参构造器   public Demo8$1(int x) &#123;      this.val$x = x;   &#125;   @Override   public void run() &#123;      System.out.println(val$x);   &#125;&#125;Copy</code></pre><h3><span id="4-类加载阶段">4、类加载阶段</span></h3><h4><span id="加载">加载</span></h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4><span id="链接">链接</span></h4><h5><span id="验证">验证</span></h5><p>验证类是否符合 JVM规范，安全性检查</p><h5><span id="准备">准备</span></h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5><span id="解析">解析</span></h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><pre><code>jpsCopy</code></pre><ul><li>打开HSDB</li></ul><pre><code>java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDBCopy</code></pre><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><pre><code>public class Demo1 &#123;   public static void main(String[] args) throws IOException, ClassNotFoundException &#123;      ClassLoader loader = Demo1.class.getClassLoader();      //只加载不解析      Class&lt;?&gt; c = loader.loadClass(&quot;com.nyima.JVM.day8.C&quot;);      //用于阻塞主线程      System.in.read();   &#125;&#125;class C &#123;   D d = new D();&#125;class D &#123;&#125;Copy</code></pre><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p><h4><span id="初始化">初始化</span></h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5><span id="发生时机">发生时机</span></h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3><span id="5-类加载器">5、类加载器</span></h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4><span id="类与类加载器">类与类加载器</span></h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4><span id="启动类加载器">启动类加载器</span></h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4><span id="拓展类加载器">拓展类加载器</span></h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4><span id="双亲委派模式">双亲委派模式</span></h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException&#123;    synchronized (getClassLoadingLock(name)) &#123;        // 首先查找该类是否已经被该类加载器加载过了        Class&lt;?&gt; c = findLoadedClass(name);        //如果没有被加载过        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null                if (parent != null) &#123;                    c = parent.loadClass(name, false);                &#125; else &#123;                    //看是否被启动类加载器加载过                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader                //捕获异常，但不做任何处理            &#125;            if (c == null) &#123;                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常                //然后让应用类加载器去找classpath下找该类                long t1 = System.nanoTime();                c = findClass(name);                // 记录时间                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;Copy</code></pre><h4><span id="自定义类加载器">自定义类加载器</span></h4><h5><span id="使用场景">使用场景</span></h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5><span id="步骤">步骤</span></h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4><span id="破坏双亲委派模式">破坏双亲委派模式</span></h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3><span id="6-运行期优化">6、运行期优化</span></h3><h4><span id="分层编译">分层编译</span></h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5><span id="即时编译器jit与解释器的区别">即时编译器（JIT）与解释器的区别</span></h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5><span id="逃逸分析">逃逸分析</span></h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4><span id="方法内联">方法内联</span></h4><h5><span id="内联函数"><strong>内联函数</strong></span></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5><span id="jvm内联函数"><strong>JVM内联函数</strong></span></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><pre><code>public final void doSomething() &#123;          // to do something  &#125;Copy</code></pre><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><pre><code>private int add4(int x1, int x2, int x3, int x4) &#123;         //这里调用了add2方法        return add2(x1, x2) + add2(x3, x4);      &#125;      private int add2(int x1, int x2) &#123;          return x1 + x2;      &#125;Copy</code></pre><p>方法调用被替换后</p><pre><code>private int add4(int x1, int x2, int x3, int x4) &#123;          //被替换为了方法本身        return x1 + x2 + x3 + x4;      &#125;Copy</code></pre><h4><span id="反射优化">反射优化</span></h4><pre><code>public class Reflect1 &#123;   public static void foo() &#123;      System.out.println(&quot;foo...&quot;);   &#125;   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;      Method foo = Demo3.class.getMethod(&quot;foo&quot;);      for(int i = 0; i&lt;=16; i++) &#123;         foo.invoke(null);      &#125;   &#125;&#125;Copy</code></pre><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><pre><code>@CallerSensitivepublic Object invoke(Object obj, Object... args)    throws IllegalAccessException, IllegalArgumentException,       InvocationTargetException&#123;    if (!override) &#123;        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类    MethodAccessor ma = methodAccessor;             // read volatile    if (ma == null) &#123;        ma = acquireMethodAccessor();    &#125;    return ma.invoke(obj, args);&#125;Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><pre><code>class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;    private final Method method;    private DelegatingMethodAccessorImpl parent;    private int numInvocations;    NativeMethodAccessorImpl(Method var1) &#123;        this.method = var1;    &#125;        //每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一    //如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());            this.parent.setDelegate(var3);        &#125;        return invoke0(this.method, var1, var2);    &#125;    void setParent(DelegatingMethodAccessorImpl var1) &#123;        this.parent = var1;    &#125;    private static native Object invoke0(Method var0, Object var1, Object[] var2);&#125;Copy//ReflectionFactory.inflationThreshold()方法的返回值private static int inflationThreshold = 15;Copy</code></pre><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2022/01/21/Stream%E6%B5%81/"/>
      <url>/2022/01/21/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1><span id="stream流">Stream流</span></h1><p><strong>自我感觉是一流的形式传递操作，上一个操作返回的结果放到下一个</strong></p><p><strong>可以被用来对集合或数组进行链状流式的操作</strong></p><p>可以先写出匿名内部类的形式，然后再快捷转换为lambda表达式</p><p><strong>eg:</strong></p><pre><code class="java">// 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 getAuthors()         .stream()         .distinct()         .filter(author -&gt; author.getAge()&lt;18)         .forEach(author -&gt; System.out.println(author.getName()));</code></pre><h2><span id="操作种类">操作种类</span></h2><h3><span id="创建流">创建流</span></h3><pre><code class="java">//创建流,有两种方式public static void test01()&#123;    Integer[] list=&#123;1,2,3,4,5&#125;;    Stream&lt;Integer&gt; stream=Arrays.stream(list);    Stream&lt;Integer&gt; stream1 = Stream.of(list);    stream.distinct().filter(integer -&gt; integer&lt;3).forEach(integer -&gt; System.out.println(integer));    stream1.distinct().filter(integer -&gt; integer&lt;3).forEach(integer -&gt; System.out.println(integer));&#125;</code></pre><h3><span id="中间操作">中间操作</span></h3><h5><span id="filter">filter</span></h5><p>​    可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。</p><h5><span id="map">map</span></h5><p>​    可以把对流中的元素进行计算或转换。</p><pre><code class="java">public static void test03()&#123;    //输出作者的描述    getAuthors()            .stream()            .map(Author::getIntro)            .forEach(author-&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121213239914.png" alt="image-20220121213239914"></p><h5><span id="distinct">distinct</span></h5><p>​    可以去除流中的重复元素。</p><h5><span id="sorted">sorted</span></h5><p>​    可以对流中的元素进行排序，排序规则可自定义。</p><pre><code class="java">public static void test04()&#123;    //按年龄升序的顺序排列    getAuthors()            .stream()            .distinct()            .sorted(new Comparator&lt;Author&gt;() &#123;                @Override                public int compare(Author o1, Author o2) &#123;                    return o1.getAge()- o2.getAge();                &#125;            &#125;)            .forEach(author -&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121213640079.png" alt="image-20220121213640079"></p><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p><h5><span id="limit">limit</span></h5><p>​    可以设置流的最大长度，超出的部分将被抛弃。</p><pre><code class="java">//实现输出年龄最小的两个人public static void test05()&#123;    getAuthors()            .stream()            .distinct()            .sorted()//这里实体类实现了Comparable接口            .limit(2)            .forEach(author -&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121214448565.png" alt="image-20220121214448565"></p><h5><span id="skip">skip</span></h5><p>​    跳过流中的前n个元素，返回剩下的元素</p><p>跳过年龄最小的</p><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121214634846.png" alt="image-20220121214634846"></p><h5><span id="flatmap">flatMap</span></h5><p>​    map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p><h3><span id="终结操作">终结操作</span></h3><h5><span id="foreach">forEach</span></h5><p>​    对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><h5><span id="count">count</span></h5><p>​    可以用来获取当前流中元素的个数。</p><p>例子：</p><p>​    打印这些作家的所出书籍的数目，注意删除重复元素。</p><pre><code class="java">//        打印这些作家的所出书籍的数目，注意删除重复元素。        List&lt;Author&gt; authors = getAuthors();        long count = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .distinct()                .count();        System.out.println(count);</code></pre><h5><span id="maxampmin">max&amp;min</span></h5><p>​    可以用来获取流中的最值。</p><p>例子：</p><p>​    分别获取这些作家的所出书籍的最高分和最低分并打印。</p><pre><code class="java">        public static void test09()&#123;        //    分别获取这些作家的所出书籍的最高分和最低分并打印。        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Integer&gt; max = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())                .max(new Comparator&lt;Integer&gt;() &#123;                    @Override                    public int compare(Integer o1, Integer o2) &#123;                        return o1-o2;                    &#125;                &#125;);        Optional&lt;Integer&gt; min = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())                .min((score1, score2) -&gt; score1 - score2);        System.out.println(max.get());        System.out.println(min.get());    &#125;</code></pre><h5><span id="collect">collect</span></h5><p>​    把当前流转换成一个集合。</p><p>例子：</p><p>​    获取一个存放所有作者名字的List集合。</p><pre><code class="java">public static void test10()&#123;        //        获取一个存放所有作者名字的List集合。        List&lt;Author&gt; authors=getAuthors();        List&lt;String&gt; names=authors.stream()                .distinct()                .map(author -&gt; author.getName())                .collect(Collectors.toList());        System.out.println(names);    &#125;</code></pre><p>​    获取一个所有书名的Set集合。</p><p><img src="/2022/01/21/Stream%E6%B5%81/Stream%E6%B5%81image-20220123122758892.png" alt="image-20220123122758892"></p><p>​    获取一个Map集合，map的key为作者名，value为List<book></book></p><pre><code class="java">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;        List&lt;Author&gt; authors = getAuthors();        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()                .distinct()                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));        System.out.println(map);</code></pre><h5><span id="查找与匹配">查找与匹配</span></h5><h6><span id="anymatch">anyMatch</span></h6><p>​    可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><p>例子：</p><p>​    判断是否有年龄在29以上的作家</p><pre><code class="java">//        判断是否有年龄在29以上的作家        List&lt;Author&gt; authors = getAuthors();        boolean flag = authors.stream()                .anyMatch(author -&gt; author.getAge() &gt; 29);        System.out.println(flag);</code></pre><h6><span id="allmatch">allMatch</span></h6><p>​    可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><p>例子：</p><p>​    判断是否所有的作家都是成年人</p><pre><code class="java">//        判断是否所有的作家都是成年人        List&lt;Author&gt; authors = getAuthors();        boolean flag = authors.stream()                .allMatch(author -&gt; author.getAge() &gt;= 18);        System.out.println(flag);</code></pre><h6><span id="nonematch">noneMatch</span></h6><p>​    可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p><p>例子：</p><p>​    判断作家是否都没有超过100岁的。</p><pre><code class="java">//        判断作家是否都没有超过100岁的。        List&lt;Author&gt; authors = getAuthors();        boolean b = authors.stream()                .noneMatch(author -&gt; author.getAge() &gt; 100);        System.out.println(b);</code></pre><h6><span id="findany">findAny</span></h6><p>​    获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​    获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><pre><code class="java">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; optionalAuthor = authors.stream()                .filter(author -&gt; author.getAge()&gt;18)                .findAny();        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre><h6><span id="findfirst">findFirst</span></h6><p>​    获取流中的第一个元素。</p><p>例子：</p><p>​    获取一个年龄最小的作家，并输出他的姓名。</p><pre><code class="java">//        获取一个年龄最小的作家，并输出他的姓名。        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; first = authors.stream()                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())                .findFirst();        first.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre><h5><span id="reduce归并">reduce归并</span></h5><p>​    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​    reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>​    reduce两个参数的重载形式内部的计算方式如下：</p><pre><code class="java">T result = identity;for (T element : this stream)    result = accumulator.apply(result, element)return result;</code></pre><p>​    其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p><p>例子：</p><p>​    使用reduce求所有作者年龄的和</p><pre><code class="java">//        使用reduce求所有作者年龄的和        List&lt;Author&gt; authors = getAuthors();        Integer sum = authors.stream()                .distinct()                .map(author -&gt; author.getAge())                .reduce(0, (result, element) -&gt; result + element);        System.out.println(sum);</code></pre><p>​    使用reduce求所有作者中年龄的最大值</p><pre><code class="java">//        使用reduce求所有作者中年龄的最大值        List&lt;Author&gt; authors = getAuthors();        Integer max = authors.stream()                .map(author -&gt; author.getAge())                .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);        System.out.println(max);</code></pre><p>​    使用reduce求所有作者中年龄的最小值</p><pre><code class="java">//        使用reduce求所有作者中年龄的最小值        List&lt;Author&gt; authors = getAuthors();        Integer min = authors.stream()                .map(author -&gt; author.getAge())                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);        System.out.println(min);</code></pre><p>​    reduce一个参数的重载形式内部的计算</p><pre><code class="java">      boolean foundAny = false;     T result = null;     for (T element : this stream) &#123;         if (!foundAny) &#123;             foundAny = true;             result = element;         &#125;         else             result = accumulator.apply(result, element);     &#125;     return foundAny ? Optional.of(result) : Optional.empty();</code></pre><p>​    如果用一个参数的重载方法去求最小值代码如下：</p><pre><code class="java">        //        使用reduce求所有作者中年龄的最小值        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Integer&gt; minOptional = authors.stream()                .map(author -&gt; author.getAge())                .reduce((result, element) -&gt; result &gt; element ? element : result);        minOptional.ifPresent(age-&gt; System.out.println(age));</code></pre><h3><span id="35-注意事项">3.5 注意事项</span></h3><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/2022/01/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2><span id="1lambda表达式">1.Lambda表达式</span></h2><h3><span id="11核心原则">1.1核心原则</span></h3><blockquote><p>可推导可省略</p></blockquote><h3><span id="12基本格式">1.2基本格式</span></h3><pre><code>(参数列表)-&gt;&#123;d&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASE</title>
      <link href="/2022/01/20/JAVASE/"/>
      <url>/2022/01/20/JAVASE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化</title>
      <link href="/2022/01/17/mysql%E4%BC%98%E5%8C%96/"/>
      <url>/2022/01/17/mysql%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220117114857930.png" alt="image-20220117114857930"></p><p>显示字符集编码</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220117121933893.png" alt="image-20220117121933893"></p><h1><span id="mysql架构">mysql架构</span></h1><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173346275.png" alt="image-20220125173346275"></p><h2><span id="逻辑架构">逻辑架构</span></h2><p><img src="https://img-blog.csdnimg.cn/20190311133729340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzQ1MTAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>Client :</strong><br>提供连接MySQL服务器功能的常用工具集</li><li><strong>Server :</strong><br>MySQL实例，真正提供数据存储和数据处理功能的MySQL服务器进程</li><li><strong>mysqld:</strong><br>MySQL服务器守护程序，在后台运行。它管理着客户端请求。mysqld是一个多线程的进程，允许多个会话连接，端口监听连接，管理MySQL实例</li><li><strong>MySQL memory allocation:</strong><br>MySQL的要求的内存空间是动态的，比如 <code>innodb_buffer_pool_size (from 5.7.5), key_buffer_size</code>。每个会话都有独一无二的执行计划，我们只能共享同一会话域内的数据集。</li><li><strong>SESSION</strong><br>为每个客户端连接分配一个会话，动态分配和回收。用于查询处理，每个会话同时具备一个缓冲区。每个会话是作为一个线程执行的</li><li><strong>Parser</strong><br>检测SQL语句语法，为每条SQL语句生成<code>SQL_ID</code>，用户认证也发生在这个阶段</li><li><strong>Optimizer</strong><br>创造一个有效率的执行计划（根据具体的存储引擎）。它将会重写查询语句。比如：InnoDB有共享缓冲区，所以，优化器会首先从预先缓存的数据中提取。使用 table statistics optimizer将会为SQL查询生成一个执行计划。用户权限检查也发生在这个阶段。</li><li><strong>Metadata cache</strong><br>缓存对象元信息和统计信息</li><li><strong>Query cache</strong><br>共享在内存中的完全一样的查询语句。如果完全相同的查询在缓存命中，MySQL服务器会直接从缓存中去检索结果。缓存是会话间共享的，所以为一个客户生成的结果集也能为另一个客户所用。查询缓存基于<code>SQL_ID</code>。将SELECT语句写入视图就是查询缓存最好的例子。</li><li><strong>key cache</strong><br>缓存表索引。<code>MySQL keys</code>是索引。如果索引数据量小，它将缓存索引结构和叶子节点（存储索引数据）。如果索引很大，它只会缓存索引结构，通常供<strong>MyISAM存储引擎</strong>使用</li></ul><h2><span id="数据库引擎">数据库引擎：</span></h2><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173524623.png" alt="image-20220125173524623"></p><p>引擎对比：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173746074.png" alt="image-20220125173746074"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125174645385.png" alt="image-20220125174645385"></p><h2><span id="sql性能下降的原因">SQL性能下降的原因</span></h2><ul><li>查询语句写的差。</li><li>索引失效：索引建了，但是没有用上。</li><li>关联 查询太多<code>join</code>（设计缺陷或者不得已的需求）。</li><li>服务器调优以及各个参数的设置（缓冲、线程数等）。</li></ul><h2><span id="机读顺序">机读顺序</span></h2><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126104245756.png" alt="image-20220126104245756"></p><h2><span id="七种join理论">七种JOIN理论</span></h2><p><a href="https://camo.githubusercontent.com/86ddd9cb519bf327ca485e638dd17d8ec15e10778a6b1d85b7c6dfa54d553df1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313231323031313535392e6a70673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/86ddd9cb519bf327ca485e638dd17d8ec15e10778a6b1d85b7c6dfa54d553df1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313231323031313535392e6a70673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="七种JOIN理论"></a></p><pre><code class="sql">/* 1 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;/* 2 */SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;/* 3 */SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;/* 4 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;/* 5 */SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;/* 6 */SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.KeyUNIONSELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;/* 7 */SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;UNIONSELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</code></pre><p>训练：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112014110.png" alt="image-20220126112014110"></p><p>笛卡尔积</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112141713.png" alt="image-20220126112141713"></p><p>inner join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112509976.png" alt="image-20220126112509976"></p><p>left join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112649545.png" alt="image-20220126112649545"></p><p>right join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112731024.png" alt="image-20220126112731024"></p><p>返回所有记录</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126113400563.png" alt="image-20220126113400563"></p><h2><span id></span></h2><h1><span id="索引">索引</span></h1><p>索引的本质：<strong>索引是排好序的快速查找数据结构。</strong></p><p><strong>重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！</strong></p><p><strong>除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</strong></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p><pre><code>Linux下查看磁盘空间命令 df -h </code></pre><pre><code class="shell">[root@VM-16-3-centos ~]# df -hFilesystem      Size  Used Avail Use% Mounted ondevtmpfs        908M     0  908M   0% /devtmpfs           919M   32K  919M   1% /dev/shmtmpfs           919M  624K  919M   1% /runtmpfs           919M     0  919M   0% /sys/fs/cgroup/dev/vda1        59G  7.4G   50G  14% /tmpfs           184M     0  184M   0% /run/user/0</code></pre><p>我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</p><blockquote><p>索引的优势和劣势</p></blockquote><p>优势：</p><ul><li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p>劣势：</p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li><li>虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。</li></ul><h2><span id="mysql索引分类">MySQL索引分类</span></h2><p>索引分类：</p><ul><li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引。</li><li>唯一索引：索引列的值必须唯一，但是允许空值。</li><li>复合索引：一个索引包含多个字段。</li></ul><p><strong>建议：一张表建的索引最好不要超过5个！</strong></p><pre><code class="sql">/* 基本语法 *//* 1、创建索引 [UNIQUE]可以省略*//* 如果只写一个字段就是单值索引，写多个字段就是复合索引 */CREATE [UNIQUE] INDEX indexName ON tabName(columnName(length));/* 2、删除索引 */DROP INDEX [indexName] ON tabName;/* 3、查看索引 *//* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 */SHOW INDEX FROM tabName \G;</code></pre><p>使用<code>ALTER</code>命令来为数据表添加索引</p><pre><code class="sql">/* 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL */ALTER TABLE tabName ADD PRIMARY KEY(column_list);/* 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次) */ALTER TABLE tabName ADD UNIQUE indexName(column_list);/* 3、该语句创建普通索引，索引值可以出现多次 */ALTER TABLE tabName ADD INDEX indexName(column_list);/* 4、该语句指定了索引为FULLTEXT，用于全文检索 */ALTER TABLE tabName ADD FULLTEXT indexName(column_list);</code></pre><h2><span id="mysql索引数据结构">MySQL索引数据结构</span></h2><p>索引数据结构：</p><ul><li><code>BTree</code>索引。</li><li><code>Hash</code>索引。</li><li><code>Full-text</code>全文索引。</li><li><code>R-Tree</code>索引。</li></ul><p><code>BTree</code>索引检索原理：</p><p><a href="https://camo.githubusercontent.com/585e16bba5e6911f7d81728ab9731894fd6631963a028f79d6f327d50109b42d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313233333133343933312e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/585e16bba5e6911f7d81728ab9731894fd6631963a028f79d6f327d50109b42d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313233333133343933312e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="BTree"></a></p><h2><span id="哪些情况不要建索引">哪些情况不要建索引</span></h2><ul><li>记录太少的表。</li><li>经常增删改的表。</li><li>频繁更新的字段不适合创建索引。</li><li>Where条件里用不到的字段不创建索引。</li><li>假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</li></ul><h1><span id="性能分析">性能分析</span></h1><h2><span id="explain简介">EXPLAIN简介</span></h2><blockquote><p>EXPLAIN是什么？</p></blockquote><p>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p><blockquote><p>EXPLAIN怎么使用？</p></blockquote><p>语法：<code>explain</code> + <code>SQL</code>。</p><pre><code class="sql">mysql&gt; explain select * from tbl_emp\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tbl_emp         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: NULL1 row in set (0.00 sec)ERROR: No query specified</code></pre><blockquote><p>EXPLAIN能干嘛？</p></blockquote><p>可以查看以下信息：</p><ul><li><code>id</code>：表的读取顺序。</li><li><code>select_type</code>：数据读取操作的操作类型。</li><li><code>possible_keys</code>：哪些索引可以使用。</li><li><code>key</code>：哪些索引被实际使用。</li><li><code>ref</code>：表之间的引用。</li><li><code>rows</code>：每张表有多少行被优化器查询。</li></ul><h2><span id="explain字段">EXPLAIN字段</span></h2><blockquote><p>id</p></blockquote><p><code>id</code>：表的读取和加载顺序。</p><p>值有以下三种情况：</p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>有相同有不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul><blockquote><p>select_type</p></blockquote><p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p><ul><li><p><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION </code>。</p></li><li><p><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p></li><li><p><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</p></li><li><p><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</p></li><li><p><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</p></li><li><p><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</p><p><strong>eg:</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129211613525.png" alt="image-20220129211613525"></p></li></ul><blockquote><p>type</p></blockquote><p><code>type</code>：访问类型排列。</p><p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了<code>ALL</code>没有用到索引，其他级别都用到索引了。</p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code>。</p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</li><li><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</li><li><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code> const</code> 类型之外, 这是最好的联接类型。</li><li><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</li><li><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></li><li><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</li></ul><blockquote><p>possible_keys 和 key</p></blockquote><p><code>possible_keys</code>：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p><p><code>key</code>：实际使用的索引。如果为<code>NULL</code>，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在<code>key</code>列表中。</p><blockquote><p>key_len</p></blockquote><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p><p><code>key_len</code>计算规则：<strong><a href="https://blog.csdn.net/qq_34930488/article/details/102931490">https://blog.csdn.net/qq_34930488/article/details/102931490</a></strong></p><pre><code class="sql">mysql&gt; desc category;+---------------+------------+------+-----+---------+----------------+| Field         | Type       | Null | Key | Default | Extra          |+---------------+------------+------+-----+---------+----------------+| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment || name          | char(50)   | YES  |     | NULL    |                || parent_cid    | bigint(20) | YES  |     | NULL    |                || cat_level     | int(11)    | YES  |     | NULL    |                || show_status   | tinyint(4) | YES  |     | NULL    |                || sort          | int(11)    | YES  |     | NULL    |                || icon          | char(255)  | YES  |     | NULL    |                || product_unit  | char(50)   | YES  |     | NULL    |                || product_count | int(11)    | YES  |     | NULL    |                |+---------------+------------+------+-----+---------+----------------+9 rows in set (0.00 sec)mysql&gt; explain select cat_id from category where cat_id between 10 and 20 \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！          ref: NULL         rows: 11     filtered: 100.00        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><blockquote><p>ref</p></blockquote><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><blockquote><p>rows</p></blockquote><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p><blockquote><p>Extra</p></blockquote><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></li></ul><pre><code class="sql"># 排序没有使用索引mysql&gt; explain select name from category where name=&#39;Tangs&#39; order by cat_level \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: refpossible_keys: idx_name_parentCid_catLevel          key: idx_name_parentCid_catLevel      key_len: 201          ref: const         rows: 1     filtered: 100.00        Extra: Using where; Using index; Using filesort1 row in set, 1 warning (0.00 sec)#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~# 排序使用到了索引mysql&gt; explain select name from category where name=&#39;zz&#39; order by parent_cid,cat_level\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: refpossible_keys: idx_name_parentCid_catLevel          key: idx_name_parentCid_catLevel      key_len: 201          ref: const         rows: 1     filtered: 100.00        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>Using temporary</code>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></li><li><code>Using index</code>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</li></ul><pre><code class="sql"># 覆盖索引# 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。# 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。mysql&gt; explain select cat_id from category \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: indexpossible_keys: NULL                 key: PRIMARY      key_len: 8          ref: NULL         rows: 1425     filtered: 100.00        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。</li><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul><pre><code class="sql">mysql&gt; explain select name from staffs where name = &#39;zz&#39; and name = &#39;cc&#39;\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: NULL   partitions: NULL         type: NULLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: NULL     filtered: NULL        Extra: Impossible WHERE   # 不可能字段同时查到两个名字1 row in set, 1 warning (0.00 sec)</code></pre><h2><span id="mysql中explain的extra字段值using-index和using-whereusing-index和using-where以及using-index-condition的区别">MySQL中Explain的Extra字段值Using index和Using where；Using index和Using where以及Using index condition的区别</span></h2><p> 在分别介绍以上四个值之前，我们需要知道，MySQL的架构分成了server层和存储引擎层（storage engine），server层通过调用存储引擎层来返回数据。       </p><p>其中Using index表示查询的列被索引覆盖，因而无需再回表（如果你不知道啥叫回表，请参见第3篇博客）查询，因而效率较高。例如：select id from test where id = 5;其中id为主键。</p><p>​    Using where;Using index表示查询的列被索引覆盖，且where筛选条件是索引列前导列的一个范围，或者是索引列的非前导列，例如：select id from test where id &gt; 5;。很明显，效率也很高。</p><p>​    Using where表示查询的列未被索引覆盖，且where筛选条件是索引列前导列的一个范围，或者是索引列的非前导列，或者是非索引列，例如：select * from test where id &gt; 30; 。因为未被索引覆盖，所以需要回表，因而性能比前两者差。</p><p>​    Extra为null表示查询的列未被索引覆盖，且where筛选条件是索引的前导列，这意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，因而性能也比前两者差。</p><p>​    Using index condition是MySQL 5.6中引入的一种新特性，叫做Index Condition Pushdown(ICP)，是一种在存储引擎层使用索引过滤数据的一种优化方式。这里的“下推” 是指将原来在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。使用ICP可以减少存储引擎层返回需要被index filter过滤掉的行记录，省去了存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。Using index condition仅适用于二级索引，原因是ICP的目的是减少全行读取的次数，从而减少IO操作。而对于innodb聚集索引，完整的记录已被读入到innodb缓冲区，在这种情况下，ICP不会减少io，所以ICP只适用于二级索引，一般发生在查询字段无法被二级索引覆盖的场景，该场景下往往需要回表。通过ICP，可以减少存储引擎返回的行记录，从而减少了IO操作</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129210757192.png" alt="image-20220129210757192"></p><h1><span id="索引分析">索引分析</span></h1><h2><span id="单表索引分析">单表索引分析</span></h2><blockquote><p>数据准备</p></blockquote><pre><code></code></pre><blockquote><p>案例：查询<code>category_id</code>为1且<code>comments</code>大于1的情况下，<code>views</code>最多的<code>article_id</code>。</p></blockquote><pre><code class="sql"># 1、sql语句SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;# 2、sql执行计划mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: article   partitions: NULL         type: ALL  #最坏的情况possible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 5     filtered: 20.00        Extra: Using where; Using filesort  # 产生了文件内排序，需要优化SQL1 row in set, 1 warning (0.00 sec)</code></pre><p>2、创建索引<code>idx_article_ccv</code>。</p><pre><code class="sql">CREATE INDEX idx_article_ccv ON article(category_id,comments,views);</code></pre><p>3、查看当前索引。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129213500083.png" alt="image-20220129213500083"></p><p>4、查看现在SQL语句的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129213519241.png" alt="image-20220129213519241"></p><p>发现创建符合索引<code>idx_article_ccv</code>之后，虽然解决了全表扫描的问题，但是在<code>order by</code>排序的时候没有用到索引，MySQL居然还是用的**<code>Using filesort</code>**</p><p>5、我们试试把SQL修改为<code>SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;</code>看看SQL的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214319416.png" alt="image-20220129214319416"></p><p>推论：当<code>comments &gt; 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就用不上，但是当<code>comments = 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就可以用上！！！</p><p><strong>所以，范围值使索引失效。</strong></p><p>6、我们现在知道<strong>范围之后的索引会失效</strong>，原来的索引<code>idx_article_ccv</code>最后一个字段<code>views</code>会失效，那么我们如果删除这个索引，创建<code>idx_article_cv</code>索引呢？？？？</p><pre><code class="sql">/* 创建索引 idx_article_cv */CREATE INDEX idx_article_cv ON article(category_id,views);</code></pre><p>查看当前的索引</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214725701.png" alt="image-20220129214725701"></p><p>7、当前索引是<code>idx_article_cv</code>，来看一下SQL执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214743296.png" alt="image-20220129214743296"></p><p>成功了</p><h2><span id="两表索引分析">两表索引分析</span></h2><blockquote><p>数据准备</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215115964.png" alt="image-20220129215115964"></p></blockquote><pre><code></code></pre><blockquote><p>两表连接查询的SQL执行计划</p></blockquote><p>1、不创建索引的情况下，SQL的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215318710.png" alt="image-20220129215318710"></p><p><code>book</code>和<code>class</code>两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在<code>book</code>表还是创建在<code>class</code>表</p><p>2、左表(<code>book</code>表)创建索引。</p><p>创建索引<code>idx_book_card</code></p><pre><code class="sql">/* 在book表创建索引 */CREATE INDEX idx_book_card ON book(card);</code></pre><p>在<code>book</code>表中有<code>idx_book_card</code>索引的情况下，查看SQL执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215436042.png" alt="image-20220129215436042"></p><p>3、删除<code>book</code>表的索引，右表(<code>class</code>表)创建索引。</p><p>创建索引<code>idx_class_card</code></p><pre><code class="sql">/* 在class表创建索引 */CREATE INDEX idx_class_card ON class(card);</code></pre><p>在<code>class</code>表中有<code>idx_class_card</code>索引的情况下，查看SQL执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215703969.png" alt="image-20220129215703969"></p><p><strong>由此可见，左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。</strong></p><h2><span id="三张表索引分析">三张表索引分析</span></h2><blockquote><p>数据准备</p></blockquote><pre><code class="sql">DROP TABLE IF EXISTS `phone`;CREATE TABLE IF NOT EXISTS `phone`(`phone_id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;主键&#39;,`card` INT(10) UNSIGNED NOT NULL COMMENT &#39;分类&#39; ) COMMENT &#39;手机&#39;;</code></pre><blockquote><p>三表连接查询SQL优化</p></blockquote><p>1、不加任何索引，查看SQL执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130195042549.png" alt="image-20220130195042549"></p><p>2、根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在<code>book</code>表和<code>phone</code>表上添加索引。</p><pre><code class="sql">/* 在book表创建索引 */CREATE INDEX idx_book_card ON book(card);/* 在phone表上创建索引 */CREATE INDEX idx_phone_card ON phone(card);</code></pre><p>再次执行SQL的执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130195317676.png" alt="image-20220130195317676"></p><h2><span id="结论">结论</span></h2><p><code>JOIN</code>语句的优化：</p><ul><li>尽可能减少<code>JOIN</code>语句中的<code>NestedLoop</code>（嵌套循环）的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li><li>优先优化<code>NestedLoop</code>的内层循环。</li><li>保证<code>JOIN</code>语句中被驱动表上<code>JOIN</code>条件字段已经被索引。</li><li>当无法保证被驱动表的<code>JOIN</code>条件字段被索引且内存资源充足的前提下，不要太吝惜<code>Join Buffer</code> 的设置。</li></ul><h1><span id="索引失效">索引失效</span></h1><p>建表：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130202619301.png" alt="image-20220130202619301"></p><p>建立索引 </p><pre><code class="sql">ALTER TABLE staffs ADD INDEX index_staffs_nameAgePos(`name`,`age`,`pos`);</code></pre><p>查看效果</p><p>三条查询语句</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203429755.png" alt="image-20220130203429755"></p><p>只有长度在变化，其他都是好的</p><h2><span id="索引失效应该避免"><strong>索引失效（应该避免）</strong></span></h2><h3><span id="从左开始且不跳列才不会失效"><strong>从左开始且不跳列才不会失效</strong></span></h3><ul><li>最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过复合索引中间列</strong>。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203719338.png" alt="image-20220130203719338"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203842786.png" alt="image-20220130203842786"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203749391.png" alt="image-20220130203749391"></p><p>key_len不对，索引失效，不符合最佳左前缀</p><h3><span id="索引列上不做额外操作才不会失效">索引列上不做额外操作才不会失效</span></h3><p>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130205238614.png" alt="image-20220130205238614"></p><h3><span id="少用gtltbetweenand等结构">少用&gt;，&lt;，between…and等结构</span></h3><ul><li>存储引擎不能使用索引中<code>范围条件右边的列</code>。（就是&gt;，&lt;，between…and）</li><li>范围条件右边的索引失效</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130222810515.png" alt="image-20220130222810515"></p><h3><span id="减少select">减少select *</span></h3><ul><li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致））<br>区别在于extra，索引的不同，速度不一样</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130223926414.png" alt="image-20220130223926414"></p><h3><span id="不用-is-null-is-not-null">不用 is null, is not null</span></h3><ul><li>is null, is not null 也无法使用索引。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224127150.png" alt="image-20220130224127150"></p><h3><span id="模糊查询">模糊查询</span></h3><ul><li>like以通配符开头（’%abc…’），mysql索引失效会变成全表扫描的操作。</li><li><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224520085.png" alt="image-20220130224520085"></li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224447994.png" alt="image-20220130224447994"></p><p>只有xx%前缀查询才不会失效</p><p>解决方法：</p><p>把*替换为索引的字段值（id可以不加索引）</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224928257.png" alt="image-20220130224928257"></p><h3><span id="类型要正确">类型要正确</span></h3><p>即使类型不正确也可以查询，但是底层会帮你转换类型，在判断，但会浪费时间，索引直接失效，变成了全表查询</p><ul><li><p>字符串不加单引号索引失效。</p></li><li><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225213417.png" alt="image-20220130225213417"></p><p>把*替换为字段值会好些</p></li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225125971.png" alt="image-20220130225125971"></p><h3><span id="不用or关键字就不会失效">不用or关键字就不会失效</span></h3><ul><li>少用or，用它来连接时会索引失效。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225352233.png" alt="image-20220130225352233"></p><h1><span id="面试常考">面试常考</span></h1><p><strong>建表</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190057941.png" alt="image-20220201190057941"></p><p><strong>建立索引</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190132165.png" alt="image-20220201190132165"></p><p><strong>explain</strong></p><p><strong>正常顺序</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190200564.png" alt="image-20220201190200564"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190228297.png" alt="image-20220201190228297"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190243309.png" alt="image-20220201190243309"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190317209.png" alt="image-20220201190317209"></p><p><strong>乱序</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190613078.png" alt="image-20220201190613078"></p><p>打乱顺序mysql的最左前缀原则仍符合，因为mysql有优化器会帮你查询是否匹配</p><p><strong>范围</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201195817005.png" alt="image-20220201195817005"></p><p>如果开始限定范围<br>第一条会用到3个索引，前两个用来查找，c3用来排序<br>第二条用到了4个索引，前3个用来查找，c4用来排序</p><p>因为mysql引擎会优化第二个sql语句在底层已经变成</p><p><strong>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4&gt;’a4’;</strong></p><p><strong>使用order by</strong><br>下面那个例子都是一样的<br>前两个都是在查找，第三个只是在排序，到了这里就已经断了，所以c4可有可无</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201200304494.png" alt="image-20220201200304494"></p><p>如果使用c4排序，会出现Using filesort。，因为优化器会给你文件排序（因为中间跳了一个）</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204121522497.png" alt="image-20220204121522497"></p><p>这个也会出现Using filesort，因为顺序颠倒了</p><pre><code class="sql"> explain select * from test03 where c1=&#39;a1&#39; and c5=&#39;a5&#39; order by c3,c2;</code></pre><p>这个就不会出现filesort，因为c2的值已经确认了</p><p> <img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204122519176.png" alt="image-20220204122519176"></p><p>groupby之前必排序，规则和orderby差不多</p><p>模糊查询</p><p>%在左边会导致索引失效，在右边可以不失效</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204123846471.png" alt="image-20220204123846471"></p><h2><span id="总结">总结</span></h2><p>对于单键索引，尽量选择针对当前query过滤性更好的索引。<br>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。<br>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引。<br>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</p><p>口诀：</p><p><strong>全值匹配我最爱， 最左前缀要遵守；</strong></p><p><strong>带头大哥不能死， 中间兄弟不能断；</strong></p><p><strong>索引列上少计算， 范围之后全失效；</strong></p><p><strong>LIKE 百分写最右， 覆盖索引不写 <code>\*</code>；</strong></p><p><strong>不等空值还有 OR， 索引影响要注意；</strong></p><p><strong>VAR 引号不可丢， SQL 优化有诀窍。</strong></p><h1><span id="查询截取分析">查询截取分析</span></h1><h2><span id="sql调优过程">SQL调优过程：</span></h2><p>观察，至少跑1天，看看生产的慢SQL情况。<br>开启慢查询日志，设置阙值，比如超过5秒钟的就是慢SQL，并将它抓取出来。<br>explain + 慢SQL分析。<br>show profile。<br>运维经理 or DBA，进行SQL数据库服务器的参数调优。</p><h2><span id="总结">总结：</span></h2><p>慢查询的开启并捕获<br>explain + 慢SQL分析<br>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况<br>SQL数据库服务器的参数调优。</p><h2><span id="in和exists的区别">in和exists的区别</span></h2><h3><span id="小表驱动大表">小表驱动大表</span></h3><p>RBO原理：</p><p>当B表的数据集必须小于A表的数据集时，用in优于exists。</p><p> <strong>select * from A where id in (select id from B)</strong><br> 等价于:<br> <strong>for select id from B</strong><br> <strong>for select * from A where A.id = B.id</strong><br> 当A表的数据集系小于B表的数据集时，用exists优于in</p><p> <strong>select * from A where exists (select 1 from B where B.id = A.id)</strong><br> 等价于：<br> <strong>for select * from A</strong><br> <strong>for select * from B where B.id = A.id</strong></p><h3><span id="关于exists的关键字">关于exists的关键字</span></h3><p>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。</p><p>提示</p><p>EXSTS(subquey)只返回TRUE或FALSE，因此子查询中的SELECT * 也可以是 SELECT 1 或select ‘X’，官方说法是实际执行时会忽略SELECT清单，因此没有区别。<br>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。<br>EXISTS子查询往往也可以用条件表达式，其他子查询或者JOIN来替代，何种最优需要具体问题具体分析<br>3.2 OrderBy优化<br>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p><p>建立一张表以及一个索引</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204195232493.png" alt="image-20220204195232493"></p><p>如果索引的时候也是按照顺序，两种情况都是一样的</p><p>但是索引的时候不按顺序<br>就会出现这样的情况</p><h2><span id="mysql支持二种方式的排序filesort和lindex">MySQL支持二种方式的排序：FileSort和lIndex</span></h2><p>Index效率高，它指MySQL扫描索引本身完成排序，FileSort方式效率较低。</p><h4><span id="order-by满足两情况会使用index方式排序">ORDER BY满足两情况，会使用Index方式排序：</span></h4><p><strong>1.ORDER BY语句使用索引最左前列。</strong><br><strong>2</strong>.<strong>使用where子句与Order BY子句条件列组合满足索引最左前列。</strong><br>如果不在索引列上，mysql的filesort有两种算法：<strong>双路排序、单路排序</strong></p><blockquote><p>双路排序：MySQL4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和OrderBy列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读对应的数据输出。<br>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p></blockquote><blockquote><p>单路排序：从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序压的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。<br>但是用单路有问题</p></blockquote><p>在sort_buffer中，单路排序比双路排序要多占用很多空间，因为单路排序是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取取sort_buffer容量大小，再排……从而多次I/O。<br>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><h4><span id="优化策略">优化策略</span></h4><p>1.增大sort_buffer_size参数的设置<br>2.增大max_length_for_sort_data参数的设置<br>3.为什么设置sort_buffer_size、max_length_for_sort_data参数能优化排序？</p><p>主要是因为可以提高Order By的速度</p><h4><span id="具体原因如下">具体原因如下：</span></h4><p>Order by时select * 是一个Query需要的字段，这点非常重要。在这里的影响是;</p><p>当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。<br>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer__size。<br>尝试提高sort_buffer_size，不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。<br>尝试提高max_length_for_sort_data，提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。</p><pre><code></code></pre><h3><span id="小结">小结</span></h3><p>为排序使用索引</p><p>MySql两种排序方式∶文件排序 或 扫描有序索引排序</p><p>MySql能为 排序 与 查询 使用相同的索引</p><p>创建复合索引 a_b_c (a, b, c)</p><p>order by能使用索引最左前缀</p><pre><code class="sql">ORDER BY aORDER BY a, bORDER BY a, b, cORDER BY a DESC, b DESC, c DESC</code></pre><p>如果WHERE使用素引的最左前缀定义为常量，则order by能使用索引</p><pre><code class="sql">WHERE a = const ORDER BY b,cWHERE a = const AND b = const ORDER BY cWHERE a = const ORDER BY b, cWHERE a = const AND b &gt; const ORDER BY b, c</code></pre><p>不能使用索引进行排序的情况</p><pre><code class="sql">ORDER BY a ASC, b DESC, c DESC //排序不—致WHERE g = const ORDER BY b, c //产丢失a索引WHERE a = const ORDER BY c //产丢失b索引WHERE a = const ORDER BY a, d //d不是素引的一部分WHERE a in (…) ORDER BY b, c //对于排序来说,多个相等条件也是范围查询</code></pre><h2><span id="groupby优化">GroupBy优化</span></h2><p>GroupBy优化（和order by差不多）</p><p>group by实质是先排序后进行分组，遵照索引建的最佳左前缀。<br>当无法使用索引列，增大max_length_for_sort_data参数的设置 + 增大sort_buffer_size参数的设置。<br>where高于having，能写在where限定的条件就不要去having限定了。</p><h2><span id="慢查询日志">慢查询日志</span></h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。<br>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析<br>默认情况下，MySQL数据库没有开启慢查询日速，需要我们手动来设置这个参数。</p><p>一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><p>通过如下命令进行操作</p><p>查看日志是否开启</p><pre><code class="sql">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204210832085.png" alt="image-20220204210832085"></p><p>开启 set global slow_query_log=1，只对当前数据库生效，默认关闭的<br>结果如下</p><p><strong>永久生效</strong><br>修改配置文件my.cnf<br>[mysqld]下增加或修改参数slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件</p><pre><code class="ABAP">slow_query_log =1slow_query_log_file=/var/lib/manongyanjiuseng-slow.log</code></pre><p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log（如果没有指定参数slow_query_log_file的话）</p><h3><span id="什么样的数据会放到慢查询日志">什么样的数据会放到慢查询日志</span></h3><p>需要设置一个多长的时间段就会放到日志中<br>这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒</p><p>命令：</p><pre><code class="sql">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</code></pre><p>运行时间正好等于long_query_time的情况，并不会被记录下来，需大于</p><p>设置阈值时间后还需要重启才可以生效 </p><pre><code class="sql">set global long_query_time=3;</code></pre><p>查询当前系统中有多少条慢查询记录 </p><pre><code class="sql">show global status like &#39;%Slow_queries%&#39;;</code></pre><p>如果在配置文件中设置阈值<br>具体配置如下</p><p>[mysqld]下配置:</p><pre><code class="sql">slow_query_log=1;slow_query_log_file=/var/lib/mysql/atguigu-slow.loglong_query_time=3;log_output=FILE;</code></pre><h2><span id="结合工具进行分析mysqldumpslow">==结合工具进行分析mysqldumpslow ==</span></h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p><p>查看mysqldumpslow的帮助信息，mysqldumpslow –help。</p><h3><span id="工作常用参考">工作常用参考</span></h3><pre><code class="sh">得到返回记录集最多的10个SQL ，mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log得到访问次数最多的10个SQL，mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log得到按照时间排序的前10条里面含有左连接的查询语句，mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log另外建议在使用这些命令时结合│和more 使用，否则有可能出现爆屏情况，mysqldumpslow -s r-t 10 /ar/lib/mysql/atguigu-slow.log | more</code></pre><p>3.5 批量插入数据脚本<br>为了更好的展示<br>先建立一张表</p><pre><code class="sql">create database bigData;use bigData;CREATE TABLE dept(    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,    dname VARCHAR(20)NOT NULL DEFAULT &quot;&quot;,    loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;)ENGINE=INNODB DEFAULT CHARSET=utf8;CREATE TABLE emp(    id int unsigned primary key auto_increment,    empno mediumint unsigned not null default 0,    ename varchar(20) not null default &quot;&quot;,    job varchar(9) not null default &quot;&quot;,    mgr mediumint unsigned not null default 0,    hiredate date not null,    sal decimal(7,2) not null,    comm decimal(7,2) not null,    deptno mediumint unsigned not null default 0)ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><p>开启了可以创建存储函数的权限，主要是这个功能</p><p>设置参数<strong>log_bin_trust_function_creators</strong></p><pre><code class="sql">show variables like &#39;log_bin_trust_function_creators&#39;;set global log_bin_trust_function_creators=1;</code></pre><p>这是在终端上输入的<br>但是重启后会失效</p><p>如果要配置永久的，需要在配置文件上配置</p><p>windows下my.ini[mysqld]加上</p><pre><code class="sh">log_bin_trust_function_creators=1</code></pre><p>linux下/etc/my.cnf 下my.cnf[mysqld]加上</p><pre><code class="sh">log_bin_trust_function_creators=1</code></pre><p>创建函数，保证每条数据都不同</p><p>随机产生字符串</p><pre><code class="sql">delimiter $$ # 两个 $$ 表示结束create function rand_string(n int) returns varchar(255)begin    declare chars_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyz&#39;;    declare return_str varchar(255) default &#39;&#39;;    declare i int default 0;    while i &lt; n do        set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));        set i=i+1;    end while;    return return_str;end $$</code></pre><p>执行完语句后，在终端上输入select rand_string(2)$$;，要以$$结尾</p><p>随机产生部门编号    </p><pre><code class="sql">delimiter $$create function rand_num() returns int(5)begin    declare i int default 0;    set i=floor(100+rand()*10);    return i;end $$</code></pre><p>执行完语句后，在终端上输入select rand_num()$$，要以$$结尾</p><p>创建存储过程，创建往emp表中插入数据的存储过程</p><pre><code class="sql">delimiter $$create procedure insert_emp(in start int(10),in max_num int(10))begin    declare i int default 0;    set autocommit = 0;    repeat        set i = i+1;        insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),rand_string(6),&#39;salesman&#39;,0001,curdate(),2000,400,rand_num());        until i=max_num        end repeat;    commit;end $$</code></pre><p>创建往dept表中插入数据的存储过程</p><pre><code class="sql">delimiter $$create procedure insert_dept(in start int(10),in max_num int(10))begin    declare i int default 0;    set autocommit = 0;    repeat        set i = i+1;        insert into dept(deptno,dname,loc) values((start+i),rand_string(10),rand_string(8));        until i=max_num        end repeat;    commit;end $$</code></pre><p>调用存储过程<br>往dept表中插入数据</p><pre><code class="sql">DELIMITER ;CALL insert_dept(100, 10);</code></pre><p>往emp表中插入50万数据</p><pre><code class="sql">DELIMITER ;CALL insert_emp(100001, 500000);</code></pre><h2><span id="show-profile">Show Profile</span></h2><p>Show Profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><p>查看当前状态是否开启了， </p><pre><code class="sql">show variables like &#39;profiling&#39;;</code></pre><p>开启 ，</p><pre><code class="sql">set profiling=on;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206120852097.png" alt="image-20220206120852097"></p><p>通过执行show profiles;</p><ul><li><p>诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL数字号码;<br>例如</p><pre><code class="sql">show profile cpu,block io for query 3;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206120949041.png" alt="image-20220206120949041"></p></li></ul><p>具体的参数介绍</p><blockquote><p>ALL：显示所有的开销信息。</p></blockquote><blockquote><p>BLOCK IO：显示块lO相关开销。<br>CONTEXT SWITCHES ：上下文切换相关开销。<br>CPU：显示CPU相关开销信息。<br>IPC：显示发送和接收相关开销信息。<br>MEMORY：显示内存相关开销信息。<br>PAGE FAULTS：显示页面错误相关开销信息。<br>SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。<br>SWAPS：显示交换次数相关开销的信息。<br>在查询该文件的时候如果出现了这些一定要特别注意</p></blockquote><h3><span id="不理想字段">不理想字段</span></h3><p><strong>converting HEAP to MyISAM</strong> 查询结果太大，内存都不够用了往磁盘上搬了。<br><strong>Creating tmp table</strong> 创建临时表，拷贝数据到临时表，用完再删除<br><strong>Copying to tmp table on disk</strong> 把内存中临时表复制到磁盘，危险!<br>locked</p><h2><span id="全局查询日志">全局查询日志</span></h2><p>General log默认不开启的原因有两个：</p><p>日志将会非常大，对磁盘是一个很大的压力。因为所有的操作都会被记录下来。<br>对MySQL数据的性能有一定的影响。</p><p>不要在生产环境开启这个功能。</p><ul><li><p>开启</p><pre><code>set global general_log=1</code></pre><p>#记录日志文件的路径</p><pre><code>general_log_file=/path/logfile</code></pre><p>#输出格式</p><pre><code>log_output=FILE</code></pre></li></ul><p>查看状态是否开启，<strong>show variables like ‘general_log’;</strong></p><pre><code class="sql">set global general_log=1;set global log_output=&#39;TABLE&#39;;</code></pre><p>log_output=‘FILE‘表示将日志存入文件,默认值是‘FILE‘</p><p>log_output=‘TABLE‘表示将日志存入数据库,这样日志信息就会被写入到mysql.slow_log表中.</p><p>所编写的sql语句，将会记录到mysql库里的geneial_log表，可以用下面的命令查看：</p><p>select * from mysql.general_log;</p><p>查出来会有输出语句</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206211546434.png" alt="image-20220206211546434"></p><h2><span id="锁机制">锁机制</span></h2><h3><span id="从读写来分">从读写来分</span></h3><p>读锁：可共同读</p><p>写锁：不可共同写，在任务完成前，会阻断其他读锁和写锁</p><p>表锁：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206223240669.png" alt="image-20220206223240669"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206224230948.png" alt="image-20220206224230948"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206224728944.png" alt="image-20220206224728944"></p><p>innoDB索引失效行锁会切换为表锁</p><h3><span id="间隙锁的危害">间隙锁的危害</span></h3><blockquote><p>什么是间隙锁？</p></blockquote><p>当我们用范围条件而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁，对于键值在条件范文内但并不存在的记录，叫做”间隙(GAP)”。</p><p><code>InnoDB</code>也会对这个”间隙”加锁，这种锁的机制就是所谓的”间隙锁”。</p><blockquote><p>间隙锁的危害</p></blockquote><p>因为<code>Query</code>执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p><p>间隙锁有一个比较致命的缺点，就是<strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong>在某些场景下这可能会対性能造成很大的危害。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220207212800265.png" alt="image-20220207212800265"></p><h3><span id="行锁">行锁</span></h3><pre><code class="sql">SELECT .....FOR UPDATE`在锁定某一行后，其他写操作会被阻塞，直到锁定的行被`COMMIT</code></pre><h3><span id="行锁分析">行锁分析</span></h3><pre><code class="sql">mysql&gt; SHOW STATUS LIKE &#39;innodb_row_lock%&#39;;+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0     || Innodb_row_lock_time          | 11131 || Innodb_row_lock_time_avg      | 11131 || Innodb_row_lock_time_max      | 11131 || Innodb_row_lock_waits         | 1     |+-------------------------------+-------+5 rows in set (0.00 sec)</code></pre><ul><li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量。</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度（重要）。</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花的平均时间（重要）。</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间。</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（重要）。</li></ul><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化策略。</p><h2><span id="主从复制">主从复制</span></h2><p><a href="https://www.cnblogs.com/phpstudy2015-6/p/6485819.html">https://www.cnblogs.com/phpstudy2015-6/p/6485819.html</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2021/12/29/spring/"/>
      <url>/2021/12/29/spring/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring">Spring</span></h1><h5><span id="spring容器">Spring容器</span></h5><h6><span id="容器是什么">容器是什么？</span></h6><p><strong>代码层次</strong>：Spring容器就是一个实现了<code>ApplicationContext</code>接口的对象</p><p><strong>从功能上来看</strong>： Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</p><p>工作流程</p><p><img src="https://img-blog.csdnimg.cn/20191217235039696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Spring容器通过我们提交的pojo类以及配置元数据产生一个充分配置的可以使用的系统</strong></p><p>这里说的配置元数据，实际上我们就是我们提供的XML配置文件，或者通过注解方式提供的一些配置信息</p><h5><span id="spring-bean">Spring bean</span></h5><p>通过不同的创建bean的手段，来分别验证对象的实例化方法</p><p>通过<code>@compent</code>,<code>@Service</code>等注解的方式，当没有进行特殊的处理的时候，默认会使用无参构造函数进行对象的实例化</p><p>通过普通XML的方式（同<code>@compent</code>注解，这里就不赘诉了）</p><p>通过<code>@Configuration</code>注解的方式，同样，断点也进入最后一行</p><p><img src="https://img-blog.csdnimg.cn/20191217235332887.jpg" alt="在这里插入图片描述"></p><p>通过<code>@Bean</code>的方式</p><p><img src="https://img-blog.csdnimg.cn/20191217235341477.jpg" alt="在这里插入图片描述"></p><p>可以发现，通过<code>@Bean</code>方法创建对象时，Spring底层是通过<code>factoryMethod</code>的方法进行实例化对象的。Spring会在我们需要实例化的这个对象对应的<code>BeanDefinition</code>中记录<code>factoryBeanName</code>是什么（在上面的例子中factoryBeanName就是config）,同时会记录这个factoryBean中创建对象的<code>factoryMethodName</code>是什么，最后通过<code>factoryBeanName</code>获取一个Bean然后反射调用<code>factoryMethod</code>实例化一个对象。</p><h6><span id="实例化总结">实例化总结：</span></h6><ol><li><p>对象实例化，只是得到一个对象，还不是一个完全的Spring中的Bean，我们实例化后的这个对象还没有完成依赖注入，没有走完一系列的声明周期，这里需要大家注意</p></li><li><p>Spring官网上指明了，在Spring中实例化一个对象有三种方式：</p><ul><li>构造函数</li><li>实例工厂方法</li><li>静态工厂方法</li></ul></li><li><p>总结：</p><p>Spring通过解析我们的配置元数据，以及我们提供的类对象得到一个Beanfinition对象。通过这个对象可以实例化出一个java bean对象。主要流程如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20191217235508810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5><span id="依赖注入">依赖注入：</span></h5><p>根据官网介绍，依赖注入主要分为两种方式</p><ol><li><p>构造函数注入</p></li><li><p>Setter方法注入</p></li></ol><blockquote><p>在<em><strong>默认的注入模型</strong></em>下，Spring如果同时找到了两个<em><strong>符合要求的构造函数</strong></em>，那么Spring会采用默认的无参构造进行实例化，如果这个时候没有无参构造，那么此时会报错<code>java.lang.NoSuchMethodException</code>。什么叫符合要求的构造函数呢？就是构造函数中的参数Spring能找到，参数被Spring所管理。</p></blockquote><blockquote><p>这里需要着重记得：<strong>一，默认注入模型；二，符合要求的构造函数</strong></p></blockquote><p>如果我们同时采用构造注入加属性注入会怎么样呢？</p><p>Spring虽然能在构造函数里完成属性注入，但是这属于实例化对象阶段做的事情，那么在后面真正进行属性注入的时候，肯定会将其覆盖掉</p><p>结论：</p><ol><li>构造函数注入跟setter方法注入可以混用<ol><li>对于一些强制的依赖，我们最好使用构造函数注入，对于一些可选依赖我们可以采用setter方法注入</li></ol></li><li>Spring团队推荐使用构造函数的方式完成注入。但是对于一些参数过长的构造函数，Spring是不推荐的</li></ol><h5><span id="方法注入">方法注入：</span></h5><ol><li><p>通过注入上下文（applicationContext对象）</p></li><li><p>通过@LookUp的方式（也分为注解跟XML两种方式，这里只演示注解的）</p></li><li><p>方法注入还有一种方式，即通过<code> replace-method</code>这种形式，xml方式。</p></li></ol><p>可以说，一个对象的依赖就是它自身的属性，Spring中的<strong>依赖注入就是属性注入</strong>。</p><ul><li>我们知道一个对象由两部分组成：属性+行为（方法），可以说Spring通过属性注入+方法注入的方式掌控的整个bean。</li><li>属性注入跟方法注入都是Spring提供给我们用来处理Bean之间协作关系的手段</li><li>属性注入有两种方式：构造函数，Setter方法。</li><li>方法注入（LookUp Method跟Replace Method）需要依赖动态代理完成</li><li>方法注入对属性注入进行了一定程度上的补充，因为属性注入的情况下，原型对象可能会失去原型的意义，见：<a href="#jump">为什么需要方法注入</a></li></ul><p>画图如下：</p><p><img src="https://img-blog.csdnimg.cn/20191217235851939.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目整合security</title>
      <link href="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/"/>
      <url>/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/</url>
      
        <content type="html"><![CDATA[<h1><span id="整合security">整合security</span></h1><h2><span id="security流程">security流程</span></h2><p><strong>核心过滤器</strong></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20211214144425527-16404064926651.png" alt="image-20211214144425527"></p><p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要由它负责。</p><p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p><p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p><p>​    </p><h2><span id="解决面向接口开发">解决（面向接口开发）</span></h2><p>登录</p><p>​    ①自定义登录接口  </p><p>​                调用ProviderManager的方法进行认证 如果认证通过生成jwt</p><p>​                把用户信息存入redis中</p><p>​    ②自定义UserDetailsService </p><p>​                在这个实现类中去查询数据库</p><pre><code class="java">/** * &lt;p&gt; * 自定义userDetailsService - 认证用户详情 * &lt;/p&gt; * * @author qy * @since 2019-11-08 */@Service(&quot;userDetailsService&quot;)public class UserDetailsServiceImpl implements UserDetailsService &#123;    @Autowired    private UserService userService;    @Autowired    private PermissionService permissionService;    /***     * 根据账号获取用户信息     * @param username:     * @return: org.springframework.security.core.userdetails.UserDetails     */    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        // 从数据库中取出用户信息        User user = userService.selectByUsername(username);        // 判断用户是否存在        if (null == user)&#123;            //throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);        &#125;        // 返回UserDetails实现类        com.atguigu.serurity.entity.User curUser = new com.atguigu.serurity.entity.User();        BeanUtils.copyProperties(user,curUser);        List&lt;String&gt; authorities = permissionService.selectPermissionValueByUserId(user.getId());        SecurityUser securityUser = new SecurityUser(curUser);        securityUser.setPermissionValueList(authorities);        return securityUser;    &#125;&#125;</code></pre><p>校验：</p><p>​    ①定义Jwt认证过滤器</p><p>​                获取token</p><p>​                解析token获取其中的userid</p><p>​                从redis中获取用户信息</p><p>​                存入SecurityContextHolder</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162733957.png" alt="image-20220120162733957"></p><h3><span id="具体思路">具体思路：</span></h3><p>因为系统的模块众多，每个模块都需要就进行认证与授权，所以选择基于<strong>token</strong>的形式进行认证与授权，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以<strong>用户名为key</strong>，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认<strong>将token携带到header请求头中</strong>，Spring-security解析header头获取token信息，<strong>解析token获取当前用户名</strong>，根据用户名就可以从redis中获取<strong>权限列表</strong>，这样Spring-security就能够判断当前请求是否有权限访问。</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120161410796.png" alt="image-20220120161410796"></p><p>获取权限部分：</p><p>SercurityUser类中：</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162121198.png" alt="image-20220120162121198"></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162046037.png" alt="image-20220120162046037"></p><p>往所需权限管理的模块中引入依赖：</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120170457804.png" alt="image-20220120170457804"></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120212933077.png" alt="image-20220120212933077"></p>]]></content>
      
      
      <categories>
          
          <category> 安全框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习开发记录</title>
      <link href="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="实习开发记录">实习开发记录</span></h1><p><strong>自定义异常（OBS）</strong></p><pre><code class="Java">@Getter@ToStringpublic class ImgException extends SystemException &#123;    /**     * 错误代码     */    private final int code;    public ImgException(ExceptionTypeEnum exceptionTypeEnum) &#123;        super(exceptionTypeEnum.getDesc());        this.code = exceptionTypeEnum.getCode();    &#125;&#125;</code></pre><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222095602282-16401381770531.png" alt="image-20211222095602282"></p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220304123839769.png" alt="image-20220304123839769"></p><p>根据OBS服务器返回的HTTP响应信息截取状态码和自定义的异常枚举类中的状态码进行对比，返回SDK文档中定义的相应的返回码对应的错误信息。</p><p>持久层框架采用JPA</p><h2><span id="jsonincludejsonincludeincludenon_null">@JsonInclude(JsonInclude.Include.NON_NULL)</span></h2><p>标记是jackson包提供的json序列化方法，已经集成于Springboot2.0中，此方法的配置意在可以对实体json序列化的时候进行对应的数值处理，</p><p>//将该标记放在属性上，如果该属性为NULL则不参与序列化<br>//如果放在类上边,那对这个类的全部属性起作用<br>//Include.Include.ALWAYS 默认<br>//Include.NON_DEFAULT 属性为默认值不序列化<br>//Include.NON_EMPTY 属性为 空（“”） 或者为 NULL 都不序列化<br>//Include.NON_NULL 属性为NULL 不序列化 </p><p>此注解适用于类标头，可以对实体类引用会自动按规则过滤实体类生成的json数据，也可以通过实现Serializable接口来标识此注解，用于对类的最终json结构进行过滤处理</p><p>eg：</p><pre><code class="java">/** * 获取当前业务的当前文件的数据，用于更新 * * @param businessId 业务ID * @param name 文件名 * @return 返回文件信息 */@Query(&quot;select i from ImpFile i where i.businessId = ?1 and &quot; +        &quot;i.name = ?2 and i.delFlag &lt;&gt; &#39;1&#39; and i.status = &#39;CURRENT&#39;&quot;)ImpFile getCurrentVersion(Long businessId, String name);</code></pre><p>&lt;&gt;为不等于，“？1”，“？2” 表示参数位置及序号</p><p>BaseModel基础实体类</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222112057709.png" alt="image-20211222112057709"></p><p>@JsonSerialize是转换为字符串。主要是后台传递给前台时的日期格式；</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222112331398.png" alt="image-20211222112331398"></p><p>这里则是解决后台传递给前台的id精度丢失问题</p><p>控制层采用ResponseResult作为统一返回结果</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222115319388.png" alt="image-20211222115319388"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2021/12/15/nginx/"/>
      <url>/2021/12/15/nginx/</url>
      
        <content type="html"><![CDATA[<h1><span id="nginx学习">nginx学习</span></h1><p>反向代理（代理服务器端 ）</p><p>负载均衡</p><p>高性能</p><p>各项功能通过配置文件进行配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒学院项目历程2</title>
      <link href="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/"/>
      <url>/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h1><span id="谷粒学院项目">谷粒学院项目</span></h1><h2><span id="redis">redis</span></h2><p>由于客户端首页访问量比较大，所以集成一下redis</p><p>当需要把分页参数和querywapper作为参数在sql语句中进行查询时，需要在mapper层加**@Param(Constants.WAPPER)**注解</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208113652994.png" alt="image-20211208113652994"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208114512577.png" alt="image-20211208114512577"></p><p><strong>@Param(Constants.WAPPER)<strong>相当于</strong>@Param(“ew”)</strong></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208113823141.png" alt="image-20211208113823141"></p><p>${ew.customSqlSegment}这个语句会自动把分页和querywapper参数传到sql查询内</p><p>在使用oss上传图片时，在前端直接调用后端接口，在前端直接给url赋值，附带moudle属性</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208131741706.png" alt="image-20211208131741706"></p><h2><span id="注册页面获取验证码前端部分">注册页面获取验证码前端部分</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211209174045597.png" alt="image-20211209174045597"></p><pre><code class="vue">// 倒计时    timeDown() &#123;      this.codeText = this.second      // 定义计时器      const timer = setInterval(() =&gt; &#123;        this.codeText--        if (this.codeText &lt; 1) &#123;          clearInterval(timer)          this.codeText = &#39;获取验证码&#39;          this.sending = false          this.second = 60        &#125;        // console.log(new Date())      &#125;, 1000)    &#125;,</code></pre><h2><span id="用户身份认证">用户身份认证</span></h2><ul><li>传统方式为单一服务器模式。</li></ul><ul><li>单点登录（sso）：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/346672f4-9c52-42bf-8fa3-464bf34a8873.jpg" alt="img"></p><p>使用redis和认证中心</p><p><strong>优点 ：</strong>  </p><p>用户身份信息独立管理，更好的分布式管理。可以自己扩展安全策略</p><p><strong>缺点：</strong></p><p>认证服务器访问压力较大，session的可用性和一致性为矛盾性质，服务器也有性能瓶颈</p><ul><li>token模式   sso模式的一种演变</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/0.9709434306629741.png" alt="img"></p><p><strong>优点：</strong></p><ul><li>无状态： token是无状态，session是有状态的</li><li>基于标准化：你的API可以采用标准化的 JSON Web Token (JWT)</li></ul><p><strong>缺点：</strong></p><ul><li>占用带宽</li><li>无法在服务器端销毁</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTI2MTc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>token详细学习</p><p><a href="https://www.jianshu.com/p/24825a2683e6">什么是token - 简书 (jianshu.com)</a></p><h2><span id="jwt">JWT</span></h2><p><strong>JWT头部</strong>分是一个描述JWT元数据的JSON对象</p><pre><code class="json">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><p><strong>有效载荷部分</strong>，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。</p><pre><code class="json">iss: jwt签发者sub: 主题aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</code></pre><p>不要在这一部分放隐私数据</p><p><strong>签名哈希</strong>部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p><pre><code class="json">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret)</code></pre><p><strong>Base64URL算法</strong></p><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p><p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法。</p><p><strong>注意：</strong>base64编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以把base64编码解成明文，所以不要在JWT中放入涉及私密的信息</p><h2><span id="后端生成token-根据token获取信息">后端生成token 根据token获取信息</span></h2><p>1.引入依赖</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;joda-time&lt;/groupId&gt;        &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>2.工具类</p><pre><code class="java">/**     * stoken     * @param jwtInfo     * @param expire     * @return     */    public static String getJwtToken(JwtInfo jwtInfo, int expire)&#123;        String JwtToken = Jwts.builder()                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)                .setSubject(&quot;guli-user&quot;)//主题                .setIssuedAt(new Date())//颁发时间                .setExpiration(DateTime.now().plusSeconds(expire).toDate())//过期时间                .claim(&quot;id&quot;, jwtInfo.getId())//用户id                .claim(&quot;nickname&quot;, jwtInfo.getNickname())//用户昵称                .claim(&quot;avatar&quot;, jwtInfo.getAvatar())//用户头像                .signWith(SignatureAlgorithm.HS256, getKeyInstance())                .compact();        return JwtToken;    &#125;/** * 根据token获取会员id * @param request * @return */public static JwtInfo getMemberIdByJwtToken(HttpServletRequest request) &#123;    String jwtToken = request.getHeader(&quot;token&quot;);    if(StringUtils.isEmpty(jwtToken)) return null;    Jws&lt;Claims&gt; claimsJws =  Jwts.parser().setSigningKey(getKeyInstance()).parseClaimsJws(jwtToken);    Claims claims = claimsJws.getBody();    JwtInfo jwtInfo = new JwtInfo(claims.get(&quot;id&quot;).toString(),                                   claims.get(&quot;nickname&quot;).toString(),                                   claims.get(&quot;avatar&quot;).toString());    return jwtInfo;&#125;</code></pre><p>JwtInfo为根据token获取的用户信息，注意：不能放有敏感信息</p><h2><span id="前端登录功能">前端登录功能</span></h2><p>token在cookie中，前端header携带cookie返回后端</p><pre><code class="vue">// 登录submitLogin() &#123;// 执行远程登录接口调用loginApi.submitLogin(this.user).then(response =&gt; &#123;// 将JWT写进cookiecookie.set(&#39;guli_jwt_token&#39;, response.data.token, &#123; domain: &#39;localhost&#39; &#125;)// 跳转到网站的首页面window.location.href = &#39;/&#39;&#125;)&#125;</code></pre><p><strong>{ domain: ‘localhost’ }</strong>  cookie的第三个参数</p><p>设置可以共享cookie的父域名</p><h2><span id="创建dtodata-transfer-object服务和服务之间的数据传输对象">创建DTO（Data Transfer Object）：服务和服务之间的数据传输对象</span></h2><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。</p><h3><span id="left-join-关键字语法">LEFT JOIN 关键字语法</span></h3><pre><code class="sql">SELECT column_name(s)FROM table_name1LEFT JOIN table_name2 ON table_name1.column_name=table_name2.column_name</code></pre><p>serviceimpl层中 this.remove和baseMapper.delete所达成的效果是一样的</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211214115329754-16394540114113.png" alt="image-20211214115329754"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211214115259908-16394539816312.png" alt="image-20211214115259908"></p><p>只是this调用删除方法返回布尔值</p><h2><span id="微信支付">微信支付</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215113757450.png" alt="image-20211215113757450"></p><h3><span id="内网穿透">内网穿透</span></h3><p>使用ngrock</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215132549706.png" alt="image-20211215132549706"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215132522036.png" alt="image-20211215132522036"></p><p>微信回调需要访问到local host</p><p>根据微信返回的二维码url地址生成二维码  </p><p>前端生成：npm install <a href="mailto:&#118;&#x75;&#101;&#x2d;&#x71;&#114;&#105;&#x6f;&#x75;&#115;&#x6c;&#121;&#x40;&#x31;&#x2e;&#49;&#x2e;&#49;">&#118;&#x75;&#101;&#x2d;&#x71;&#114;&#105;&#x6f;&#x75;&#115;&#x6c;&#121;&#x40;&#x31;&#x2e;&#49;&#x2e;&#49;</a></p><p>处理一个幂等性，防止重复调用不必要的方法</p><pre><code class="java">//接口调用的幂等性：无论接口被调用多少次，最后所影响的结果都是一致的if(order.getStatus() == 0)&#123;    //更新订单状态    orderService.updateOrderStatus(notifyMap);&#125;</code></pre><h2><span id="api服务网关">API服务网关</span></h2><p>使用springcloudgateway作为网关</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code class="yaml">spring:  profiles:    active: dev # 环境设置  application:    name: infrastructure-apigateway # 服务名  cloud:    nacos:      discovery:        server-addr: localhost:8848 # nacos服务地址    gateway:      discovery:        locator:          enabled: true # gateway可以发现nacos中的微服务      routes:        - id: service-edu        uri: lb://service-edu        predicates:        - Path=/user/**, /*/edu/**        filters:        - SetStatus=250 #修改返回状态码</code></pre><p>predicates为断言，有路径断言，时间断言，远程IP断言，cookie断言，header断言，Query请求断言，路由权重断言</p><p>uri配置，如果服务器使用集群模式，自动运用负载均衡模式进行配置</p><h3><span id="处理跨域问题">处理跨域问题</span></h3><pre><code class="java">@Configurationpublic class CorsConfig &#123;    @Bean    public CorsWebFilter corsFilter() &#123;        CorsConfiguration config = new CorsConfiguration();        config.addAllowedMethod(&quot;*&quot;);        config.addAllowedOrigin(&quot;*&quot;);        config.addAllowedHeader(&quot;*&quot;);        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());        source.registerCorsConfiguration(&quot;/**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;</code></pre><p>有了config配置之后需把@CrossOrigin屏蔽掉</p><h3><span id="自定义全局过滤器">自定义全局过滤器</span></h3><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211217174019270.png" alt="image-20211217174019270"></p><p>未登录状态下购买课程显示network error</p><p>可优化用户体验，未登录状态下点击购买的话会直接跳转到登录页面</p><h2><span id="遇到问题">遇到问题</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220131709314.png" alt="image-20211220131709314"></p><p>配置了双跨域问题</p><p><strong>原因：</strong>controller类上加了@CrossOrigin 注解，在网关配置中又配置了跨域问题</p><p><strong>解决方法：</strong>去掉@CrossOrigin 注解，保留网关配置</p><p>问题：404</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/20190620105924821.png" alt="img"></p><p><strong>原因：</strong>控制类中的mapping没有和网关配置中的path完全匹配</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/Blog\source_posts\谷粒学院项目历程2\image-20211220134104612.png" alt="image-20211220134104612"></p><p><strong>解决方法：</strong>完全匹配就好</p><h2><span id="配置中心-nacos-config">配置中心  nacos config</span></h2><p>导入依赖</p><p>远程配置中心的配置优先生效</p><p>配置动态刷新：<strong>在controller类上添加@RefershScope注解</strong></p><p>多环境配置:</p><p>在bootstrap.yml中配置环境</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220143121397.png" alt="image-20211220143121397"></p><p>然后在nacos配置中心新建配置文件，命名规则为  <strong>服务名-环境.yaml</strong></p><p>可以用名称空间做微服务隔离，结合多环境配置使用</p><p>单独配置各种服务参数</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220144514397.png" alt="image-20211220144514397"></p><p>然后在nacos配置中心新增配置文件</p><h2><span id="权限配置">权限配置</span></h2><h3><span id="递归操作">递归操作</span></h3><h4><span id="eg获取全部菜单">eg：获取全部菜单</span></h4><pre><code class="java">//获取全部菜单    @Override    public List&lt;Permission&gt; queryAllMenuGuli() &#123;        //1 查询菜单表所有数据        QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.orderByDesc(&quot;id&quot;);        List&lt;Permission&gt; permissionList = baseMapper.selectList(wrapper);        //2 把查询所有菜单list集合按照要求进行封装        List&lt;Permission&gt; resultList = bulidPermission(permissionList);        return resultList;    &#125;//把返回所有菜单list集合进行封装的方法    public static List&lt;Permission&gt; bulidPermission(List&lt;Permission&gt; permissionList) &#123;        //创建list集合，用于数据最终封装        List&lt;Permission&gt; finalNode = new ArrayList&lt;&gt;();        //把所有菜单list集合遍历，得到顶层菜单 pid=0菜单，设置level是1        for(Permission permissionNode : permissionList) &#123;            //得到顶层菜单 pid=0菜单            if(&quot;0&quot;.equals(permissionNode.getPid())) &#123;                //设置顶层菜单的level是1                permissionNode.setLevel(1);                //根据顶层菜单，向里面进行查询子菜单，封装到finalNode里面                finalNode.add(selectChildren(permissionNode,permissionList));            &#125;        &#125;        return finalNode;    &#125;    private static Permission selectChildren(Permission permissionNode, List&lt;Permission&gt; permissionList) &#123;        //1 因为向一层菜单里面放二层菜单，二层里面还要放三层，把对象初始化        permissionNode.setChildren(new ArrayList&lt;Permission&gt;());        //2 遍历所有菜单list集合，进行判断比较，比较id和pid值是否相同        for(Permission it : permissionList) &#123;            //判断 id和pid值是否相同            if(permissionNode.getId().equals(it.getPid())) &#123;                //把父菜单的level值+1                int level = permissionNode.getLevel()+1;                it.setLevel(level);                //如果children为空，进行初始化操作                if(permissionNode.getChildren() == null) &#123;                    permissionNode.setChildren(new ArrayList&lt;Permission&gt;());                &#125;                //把查询出来的子菜单放到父菜单里面                permissionNode.getChildren().add(selectChildren(it,permissionList));            &#125;        &#125;        return permissionNode;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷粒学院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搜索技巧</title>
      <link href="/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1><span id="github搜索技巧">github搜索技巧</span></h1><p><img src="/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/e8dbfb80948296e496f574f8186d6553e61dd9ea.png@942w_659h_progressive.webp" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒学院项目历程</title>
      <link href="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/"/>
      <url>/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1><span id="谷粒学院项目">谷粒学院项目</span></h1><h2><span id="搭建环境">搭建环境</span></h2><p>了解到非业务流程开发正好符合我之前影像系统开发的某些功能，原来是以这个名词来进行概括</p><h3><span id="项目总体架构">项目总体架构</span></h3><ul><li><input disabled type="checkbox"> common 模块的公共配置</li><li><input disabled type="checkbox"> canal_client 数据库同步模块（统计同步数据）</li><li><input disabled type="checkbox"> infrastructure：基础服务模块父节点</li><li><input disabled type="checkbox"> service api接口服务父节点</li><li><input disabled type="checkbox"> node.js做BFF层</li></ul><h2><span id="数据库">数据库</span></h2><h3><span id="分布式id">分布式ID</span></h3><p><strong>雪花算法生成</strong></p><p>它能够保证不同表的主键的不重复性，以及相同表的主键的有序性</p><p>整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p><h3><span id="自动填充">自动填充</span></h3><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等</p><p>实现：</p><p>1.<strong>数据库修改</strong></p><p>在User表中添加datetime类型的新的字段 create_time、update_time</p><p><strong>2、实体类修改</strong></p><p>实体上增加字段并添加自动填充注解</p><p><strong>3、实现元对象处理器接口</strong></p><h3><span id="批量删除">批量删除</span></h3><p>batch操作</p><h3><span id="逻辑删除">逻辑删除</span></h3><p>sql执行的是update操作</p><p>父项目只管理依赖的版本，就做到了按需加载依赖，而且版本统一</p><p><dependencymanagement>用于父项目中对子项目进行统一依赖管理</dependencymanagement></p><p>遇到问题：IDEA中删除模块后，重新创建同名模块，显示已存在该模块</p><p>解决：</p><p><strong>1.在项目区单击右键找到load/Unload Modules…unload出问题的模块就可以</strong></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xleHVlaXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3><span id="后台业务接口配置">后台业务接口配置</span></h3><h4><span id></span></h4><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211112190716874.png" alt="image-20211112190716874"></p><h3><span id="设置统一返回结果">设置统一返回结果：</span></h3><pre><code class="java">@Data@ApiModel(value = &quot;全局统一返回结果&quot;)public class R &#123;    @ApiModelProperty(value = &quot;是否成功&quot;)    private Boolean success;    @ApiModelProperty(value = &quot;返回码&quot;)    private Integer code;    @ApiModelProperty(value = &quot;返回消息&quot;)    private String message;    @ApiModelProperty(value = &quot;返回数据&quot;)    private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();    public R()&#123;&#125;    public static R ok()&#123;        R r = new R();        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());        r.setCode(ResultCodeEnum.SUCCESS.getCode());        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());        return r;    &#125;    public static R error()&#123;        R r = new R();        r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());        r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());        r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());        return r;    &#125;    public static R setResult(ResultCodeEnum resultCodeEnum)&#123;        R r = new R();        r.setSuccess(resultCodeEnum.getSuccess());        r.setCode(resultCodeEnum.getCode());        r.setMessage(resultCodeEnum.getMessage());        return r;    &#125;    public R success(Boolean success)&#123;        this.setSuccess(success);        return this;    &#125;    public R message(String message)&#123;        this.setMessage(message);        return this;    &#125;    public R code(Integer code)&#123;        this.setCode(code);        return this;    &#125;    public R data(String key, Object value)&#123;        this.data.put(key, value);        return this;    &#125;    public R data(Map&lt;String, Object&gt; map)&#123;        this.setData(map);        return this;    &#125;&#125;</code></pre><h4><span id="各种状态信息返回码是由我们前端使用的vue框架决定的">各种状态信息，返回码是由我们前端使用的VUE框架决定的</span></h4><pre><code class="Java">@Getter@ToStringpublic enum ResultCodeEnum &#123;    SUCCESS(true, 20000,&quot;成功&quot;),    UNKNOWN_REASON(false, 20001, &quot;未知错误&quot;),    BAD_SQL_GRAMMAR(false, 21001, &quot;sql语法错误&quot;),    JSON_PARSE_ERROR(false, 21002, &quot;json解析异常&quot;),    PARAM_ERROR(false, 21003, &quot;参数不正确&quot;),    FILE_UPLOAD_ERROR(false, 21004, &quot;文件上传错误&quot;),    FILE_DELETE_ERROR(false, 21005, &quot;文件刪除错误&quot;),    EXCEL_DATA_IMPORT_ERROR(false, 21006, &quot;Excel数据导入错误&quot;),    VIDEO_UPLOAD_ALIYUN_ERROR(false, 22001, &quot;视频上传至阿里云失败&quot;),    VIDEO_UPLOAD_TOMCAT_ERROR(false, 22002, &quot;视频上传至业务服务器失败&quot;),    VIDEO_DELETE_ALIYUN_ERROR(false, 22003, &quot;阿里云视频文件删除失败&quot;),    FETCH_VIDEO_UPLOADAUTH_ERROR(false, 22004, &quot;获取上传地址和凭证失败&quot;),    REFRESH_VIDEO_UPLOADAUTH_ERROR(false, 22005, &quot;刷新上传地址和凭证失败&quot;),    FETCH_PLAYAUTH_ERROR(false, 22006, &quot;获取播放凭证失败&quot;),    URL_ENCODE_ERROR(false, 23001, &quot;URL编码失败&quot;),    ILLEGAL_CALLBACK_REQUEST_ERROR(false, 23002, &quot;非法回调请求&quot;),    FETCH_ACCESSTOKEN_FAILD(false, 23003, &quot;获取accessToken失败&quot;),    FETCH_USERINFO_ERROR(false, 23004, &quot;获取用户信息失败&quot;),    LOGIN_ERROR(false, 23005, &quot;登录失败&quot;),    COMMENT_EMPTY(false, 24006, &quot;评论内容必须填写&quot;),    PAY_RUN(false, 25000, &quot;支付中&quot;),    PAY_UNIFIEDORDER_ERROR(false, 25001, &quot;统一下单错误&quot;),    PAY_ORDERQUERY_ERROR(false, 25002, &quot;查询支付结果错误&quot;),    ORDER_EXIST_ERROR(false, 25003, &quot;课程已购买&quot;),    GATEWAY_ERROR(false, 26000, &quot;服务不能访问&quot;),    CODE_ERROR(false, 28000, &quot;验证码错误&quot;),    LOGIN_PHONE_ERROR(false, 28009, &quot;手机号码不正确&quot;),    LOGIN_MOBILE_ERROR(false, 28001, &quot;账号不正确&quot;),    LOGIN_PASSWORD_ERROR(false, 28008, &quot;密码不正确&quot;),    LOGIN_DISABLED_ERROR(false, 28002, &quot;该用户已被禁用&quot;),    REGISTER_MOBLE_ERROR(false, 28003, &quot;手机号已被注册&quot;),    LOGIN_AUTH(false, 28004, &quot;需要登录&quot;),    LOGIN_ACL(false, 28005, &quot;没有权限&quot;),    SMS_SEND_ERROR(false, 28006, &quot;短信发送失败&quot;),    SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL(false, 28007, &quot;短信发送过于频繁&quot;);    private Boolean success;    private Integer code;    private String message;    ResultCodeEnum(Boolean success, Integer code, String message) &#123;        this.success = success;        this.code = code;        this.message = message;    &#125;&#125;</code></pre><p>遇到问题：<strong>pom文件变橘红</strong>：idea没有识别，我们可以通过右键pom.xml文件选择Add as Maven Poject 来解决</p><p>​                    <strong>pom文件变灰</strong>：打开setting，搜索ignored<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211112212242759.png" alt="image-20211112212242759"></p><h3><span id="定义前端查询的对象">定义前端查询的对象</span></h3><p>讲师：</p><pre><code class="java">public class TeacherQueryVo implements Serializable &#123;    private static final long serialVersionUID = 1L;    @ApiModelProperty(value = &quot;讲师姓名&quot;)    private String name;    @ApiModelProperty(value = &quot;讲师级别&quot;)    private Integer level;    @ApiModelProperty(value = &quot;开始时间&quot;)    private String joinDateBegin;    @ApiModelProperty(value = &quot;结束时间&quot;)    private String joinDateEnd;&#125;</code></pre><p>关于设置自动填充类</p><p>如果没有设置的话，save方法前端以json形式返回后台数据中没有创建时间和更新时间，但是数据库中两字段为必填字段，程序就会报错</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211113135408082.png" alt="image-20211113135408082"></p><p>所以就要设置自动配置handler类</p><pre><code class="Java">@Componentpublic class CommonMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject);        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;&#125;</code></pre><h3><span id="定义统一异常处理器">定义统一异常处理器</span></h3><p>因为要返回前台，所以要统一异常处理，并以json格式返回</p><pre><code class="Java">package com.atguigu.guli.service.base.handler;import com.atguigu.guli.common.base.result.R;import com.atguigu.guli.common.base.result.ResultCodeEnum;import com.atguigu.guli.common.base.util.ExceptionUtils;import com.atguigu.guli.service.base.exception.GuliException;import lombok.extern.slf4j.Slf4j;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.jdbc.BadSqlGrammarException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zz * @since 2021/11/13 */@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)    @ResponseBody    public R error(Exception e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.error();    &#125;    @ExceptionHandler(BadSqlGrammarException.class)    @ResponseBody    public R error(BadSqlGrammarException e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.setResult(ResultCodeEnum.BAD_SQL_GRAMMAR);    &#125;    @ExceptionHandler(HttpMessageNotReadableException.class)    @ResponseBody    public R error(HttpMessageNotReadableException e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.setResult(ResultCodeEnum.JSON_PARSE_ERROR);    &#125;    @ExceptionHandler(GuliException.class)    @ResponseBody    public R error(GuliException e) &#123;        //oss的错误由这里返回前台        log.error(ExceptionUtils.getMessage(e));        return R.error().message(e.getMessage()).code(e.getCode());    &#125;&#125;</code></pre><h2><span id="oss参数配置小技巧">OSS参数配置小技巧</span></h2><p>@Data<br>@Component<br>@ConfigurationProperties(prefix = “aliyun.oss”)</p><pre><code class="java">/** * @author zz * @since 2021/11/20 * 一启动就可以从yaml文件中读取变量值 */@Data@Component@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)public class OssProperties &#123;    private String endpoint;    private String keyid;    private String keysecret;    private String bucketname;&#125;</code></pre><pre><code class="yml">aliyun:  oss:    endpoint: oss-cn-beijing.aliyuncs.com    keyid: LTAI5tHQjqR36XKKGZ4e4dxt    keysecret: ad5M6HuxGRUX0KGVCjmHBhYSCAj2i7    #bucket可以在控制台创建，也可以使用java代码创建，注意先测试bucket是否已被占用    bucketname: guli-academy-01</code></pre><h2><span id="前端">前端</span></h2><p>vue axios</p><p>跨域问题：@crossOrigin</p><p>npm</p><p><strong>安装生产环境依赖</strong>：npm install –save-dev  ***</p><p>或者 npm i -D ***</p><p>安装全局依赖：npm install –global ***</p><p>webpack进行项目打包 ，创建webpack.config.js文件：</p><pre><code class="js">const path = require(&quot;path&quot;) //Node.js内置模块module.exports = &#123;    entry: &#39;./src/main.js&#39;, //配置入口文件    output: &#123;        path: path.resolve(__dirname, &#39;./dist&#39;), //输出路径，__dirname：当前文件所在路径        filename: &#39;bundle.js&#39; //输出文件    &#125;,    module: &#123;        rules: [              &#123;                  test: /\.css$/,    //打包规则应用到以css结尾的文件上                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]            &#125;          ]      &#125;&#125;</code></pre><p>然后执行webpack –mode=development命令</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211116160418094.png" alt="image-20211116160418094"></p><p>webpack压缩</p><p>执行webpack –mode=production命令</p><p>之后这些命令都会集成在脚本里，直接执行脚本就可以了</p><p>webpack打包css</p><p>安装两个依赖</p><pre><code class="js">&quot;devDependencies&quot;: &#123;  &quot;css-loader&quot;: &quot;^3.5.2&quot;,  &quot;style-loader&quot;: &quot;^1.1.3&quot;&#125;</code></pre><p>然后在webpak.config.js文件中加上以下配置</p><pre><code class="js">module: &#123;        rules: [              &#123;                  test: /\.css$/,    //打包规则应用到以css结尾的文件上                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]            &#125;          ]      &#125;</code></pre><p>页面渲染流程：创建路由–创建API–创建页面组件</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118111357610.png" alt="image-20211118111357610"></p><p>遇到问题：<br>回显页切到新增页表单没有更新，两个页面通用一个表单，两个页面切换没有更新，因为vue会组件复用</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118113144519.png" alt="image-20211118113144519"></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118113800410.png" alt="image-20211118113800410"></p><p>需要在appmain中进行配置</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118114000851.png" alt="image-20211118114000851"></p><pre><code class="vue">&lt;template&gt;  &lt;section class=&quot;app-main&quot;&gt;    &lt;transition name=&quot;fade-transform&quot; mode=&quot;out-in&quot;&gt;      &lt;!-- or name=&quot;fade&quot; --&gt;      &lt;!-- 如果为路由出口定义一个唯一key值，那么组件会被强制重新渲染 --&gt;      &lt;router-view :key=&quot;key&quot;/&gt;      &lt;!-- 如果路由指向的页面组件是同一个，那么路由出口显示的页面组件不会重新被渲染 --&gt;      &lt;!--      &lt;router-view/&gt;--&gt;    &lt;/transition&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;AppMain&#39;,  // 计算属性  computed: &#123;    key() &#123;      return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>计算属性效率很高</p><h2><span id="自定义异常">自定义异常</span></h2><p>更为灵活</p><p>一般情况下自定义异常类型都为运行时异常，继承RuntimeException</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20220228200805440.png" alt="image-20220228200805440"></p><p>异常处理器对异常进行捕获抛出</p><h2><span id="注册中心和服务容错">注册中心和服务容错</span></h2><h3><span id="nacos">nacos</span></h3><p>使用它充当注册中心</p><h2><span id="负载均衡">负载均衡</span></h2><p>OpenFeign默认集成了 Ribbon， 所以在Nacos下使用OpenFeign默认就实现了负载均衡的效果</p><h2><span id="openfeign的超时控制">OpenFeign的超时控制</span></h2><p>超时后，服务消费者端默认会发起一次重试</p><h3><span id="使用jmeter测试并发">使用JMeter测试并发</span></h3><p>服务之间的雪崩效应</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211124224106908.png" alt="image-20211124224106908"></p><h3><span id="容错方案">容错方案</span></h3><p>隔离，超时，限流，熔断，降级        经典容错组件：Spring Cloud Hystrix、Sentinel。</p><h4><span id="隔离">隔离</span></h4><p>线程池隔离和信号量隔离</p><h4><span id="超时">超时</span></h4><p>所有的接口调用必须设置超时时间，不设置超时时间请求有可能陷入长期等待，甚至有可能导致整个服务不可用</p><h4><span id="限流"><strong>限流</strong></span></h4><p>限流即流量限制，或者高大上一点，叫做流量整形，限流的目的是在遇到流量高峰期或者流量突增（流量尖刺）时，把流量速率限制在系统所能接受的合理范围之内，不至于让系统被高流量击垮。限流可以保证系统在调用量猛增时的基本可用性，目前有几种常见的限流方式：</p><p>1）通过限制单位时间段内调用量来限流</p><p>2）通过限制系统的并发调用程度来限流</p><p>3）使用漏桶（Leaky Bucket）算法来进行限流</p><p>4）使用令牌桶（Token Bucket）算法来进行限流</p><h4><span id="熔断">熔断</span></h4><p>当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体可用性，可以暂时切断对下游服务的调用，这种牺牲局部，保全整体的措施就叫做熔断</p><h4><span id="降级">降级</span></h4><p>为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案</p><h3><span id="sentinel">sentinel</span></h3><p>新增流控规则</p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222458818.png" alt="image-20211125222458818" style="zoom:150%;"><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222525377.png" alt="image-20211125222525377"></p><p>在swaager中快速点击try，一秒超过两次的话就会出现下面的情况</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222651777.png" alt="image-20211125222651777"></p><p><strong>流量控制</strong></p><p><strong>保证自己不被上游服务压垮</strong></p><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，简单来说，就是Sentinel可以根据具体的需求来对不同的请求定义不同的控制策略。如下图所示：</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nob25nYmFvemhvbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。主要的控制方向如下：</p><ul><li><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</p></li><li><p>运行指标，例如 QPS、线程池、系统负载等；</p></li><li><p>控制的效果，例如直接限流、冷启动、排队等。</p></li></ul><p><strong>熔断降级</strong></p><p><strong>保证自己不被下游服务压垮</strong></p><p> 什么是熔断降级<br> 简单来说就是负载保护，不让服务器因为过多的并发而瘫痪。除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 Hystrix 里面描述的问题是一样的。</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nob25nYmFvemhvbmc=,size_16,color_FFFFFF,t_70#pic_center-16378508600642" alt="在这里插入图片描述"></p><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><p><strong>Sentinel熔断降级设计理念</strong><br>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。<br>Hystrix 通过线程池的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。<br>Sentinel 对这个问题采取了两种手段:</p><p>1.<strong>通过并发线程数进行限制</strong><br>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><p>2.<strong>通过响应时间对资源进行降级</strong><br>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><p><strong>负载保护</strong><br>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。<br>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2><span id="遇到问题">遇到问题：</span></h2><p>项目进行打包时没有把xml文件打包进去，导致运行sql语句时报错</p><p>解决方案：<br>pom.xml文件中配置</p><pre><code class="xml">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;</code></pre><p>然后再在application.yml文件中配置：</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211127215103746.png" alt="image-20211127215103746"></p><p><strong>com.aliyun.oss.ClientException: UnknownHost</strong></p><p>没联网！！！🤐🤐🤐</p><h2><span id="数据库优化课程管理">数据库优化（课程管理）</span></h2><p>纵向拆表</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128195950279.png" alt="image-20211128195950279"></p><p>由于有一列长文本字段数据过多，展示课程列表时并不需要这种庞杂繁多的信息，所以拆表可优化性能。</p><p>因为edu_course_description和edu_course为一对一关系，所以edu_course_description的主键生成策略应该跟随edu_course的主键生成策略。</p><pre><code class="Java">@ApiModelProperty(value = &quot;讲师ID&quot;)@TableId(value = &quot;id&quot;, type = IdType.NONE)private String id;</code></pre><pre><code class="java">private BigDecimal price;</code></pre><p>使用bigdecimal定义价格，避免精度丢失</p><p>快速赋予值</p><pre><code class="Java">BeanUtils.copyProperties( 给予=&gt;courseInfoForm, 接受=&gt;course);</code></pre><p>前段课程类别</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128212211788.png" alt="image-20211128212211788"></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128212227154.png" alt="image-20211128212227154"></p><p>可以使用两种方式加载资源</p><p>一次性加载（适合数据量不大）</p><p>延迟加载（适合数据量大，移动端考虑到流量问题）</p><h2><span id="多表联查">多表联查</span></h2><p>使用外联查询，因为不需查询出所有列</p><pre><code class="xml">&lt;sql id=&quot;columns&quot;&gt;    c.id,  c.title,  c.lesson_num AS lessonNum,  CONVERT(c.price, DECIMAL(8,2)) AS price,  c.cover,  c.buy_count AS buyCount,  c.view_count AS viewCount,  c.status,  c.gmt_create AS gmtCreate,  t.name AS teacherName,  s1.title AS subjectParentTitle,  s2.title AS subjectTitle&lt;/sql&gt;&lt;sql id=&quot;tables&quot;&gt;    edu_course c    LEFT JOIN edu_teacher t ON c.teacher_id = t.id    LEFT JOIN edu_subject s1 ON c.subject_parent_id = s1.id    LEFT JOIN edu_subject s2 ON c.subject_id = s2.id&lt;/sql&gt;&lt;select id=&quot;selectPageByCourseQueryVo&quot; resultType=&quot;com.atguigu.guli.service.edu.entity.vo.CourseVo&quot;&gt;    SELECT &lt;include refid=&quot;columns&quot; /&gt;    FROM &lt;include refid=&quot;tables&quot; /&gt;    $&#123;ew.customSqlSegment&#125; &lt;/select&gt;</code></pre><h3><span id="难点">难点：</span></h3><p>使用MyBatis Plus的分页插件和QueryWrapper结合自定义mapper xml实现多表关联查询</p><p>当我们需要把组装的querywapper传到mapper让mybatis自动查询时</p><p>1.<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211129204210637.png" alt="image-20211129204210637"></p><p>2.<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211129204255198.png" alt="image-20211129204255198"></p><h3><span id="删除业务">删除业务：</span></h3><pre><code class="java"> 数据库中外键约束的设置： 互联网分布式项目中不允许使用外键与级联更新，一切设计级联的操作不要依赖数据库层，要在业务层解决 &lt;p&gt; 如果业务层解决级联删除功能 那么先删除子表数据，再删除父表数据</code></pre><h2><span id="章节管理部分">章节管理部分</span></h2><p>优化嵌套查询回显嵌套列表</p><p>优化sql语句</p><p>方案1为显示课程分类列表时使用的sql查询方法，查询效率低</p><p>方案2为在业务层解决这个问题，直接sql查询两次得出全部的数据然后在进行组装 </p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211202142759148.png" alt="image-20211202142759148"></p><h2><span id="视频上传服务">视频上传服务</span></h2><p>本地仓库导入jar包</p><pre><code class="cmd">mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar</code></pre><h2><span id="前端渲染和服务器端渲染">前端渲染和服务器端渲染</span></h2><h3><span id="1-什么是服务端渲染">1、什么是服务端渲染</span></h3><p>服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容渲染，而不是在客户端完成页面内容的渲染。</p><p>SSR并不是前端特有的技术，我们学习过的JSP技术和Thymeleaf技术就是典型的SSR</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/a9b7b10a8fbfe2d36ee20f807a174a75.png" alt="img"></p><p>服务端渲染的特点：</p><ul><li>在服务端生成html网页的dom元素</li><li>客户端（浏览器）只负责显示dom元素内容</li></ul><h3><span id="2-什么是客户端渲染">2、什么是客户端渲染</span></h3><p>客户端（浏览器） 使用AJAX向服务端发起http请 求，获取到了想要的数据，开始渲染html网页，生成dom元素，并最终将网页内容展示给用户。</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/aa49e5a9caa4641002d5608cd5acd136.png" alt="img"></p><p>客户端渲染的特点：</p><ul><li>在服务端只是给客户端响应的了数据，而不是html网页</li><li>客户端（浏览器）负责获取服务端的数据生成dom元素</li></ul><h2><span id="3-两种方式各有什么优缺点">3、两种方式各有什么优缺点？</span></h2><p><strong>客户端渲染：</strong> </p><ol><li><p>缺点：不利于网站进行SEO，因为网站大量使用javascript技术，不利于搜索引擎抓取网页。 </p></li><li><p>优点：客户端负责渲染，用户体验性好，服务端只提供数据不用关心用户界面的内容，有利于提高服务端的开发效率。 </p></li><li><p>适用场景：对SEO没有要求的系统，比如后台管理类的系统，如电商后台管理，用户管理等。</p></li></ol><p> <strong>服务端渲染：</strong> </p><ol><li><p>优点：有利于SEO，网站通过href的url将搜索引擎直接引到服务端，服务端提供优质的网页内容给搜索引擎。</p></li><li><p>缺点：服务端完成一部分客户端的工作，通常完成一个需求需要修改客户端和服务端的代码，开发效率低，不利于系统的稳定性。</p></li><li><p>适用场景：对SEO有要求的系统，比如：门户首页、商品详情页面等。</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1046667">浅析前端渲染与服务端渲染 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>那就需要一个组件来既利于seo，又利于用户体验</p><h2><span id="nuxtjs">Nuxt.js</span></h2><p>在这里指的服务器端是前端服务器</p><p>Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可以用来创建服务端渲染 (SSR) 应用，也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性</p><p>具体代码实例：</p><pre><code class="vue">  // 服务器端渲染方案：  // 异步数据获取：在前端服务器端执行，爬虫直接在页面就可以爬到具体关键字信息  asyncData() &#123;    return teacherApi.getList().then(response =&gt; &#123;      return &#123;        items: response.data.items      &#125;    &#125;)  &#125;// 客户端渲染方案//   data() &#123;//     return &#123;//       items: []//     &#125;//   &#125;,//   created() &#123;//     teacherApi.getList().then(response =&gt; &#123;//       this.items = response.data.items//     &#125;)//   &#125;</code></pre><h2><span id="前端url组装参数">前端url组装参数</span></h2><p>使用queryString组件组装</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/Blog\source_posts\谷粒学院项目历程\image-20211206213423909.png" alt="image-20211206213423909"></p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷粒学院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件</title>
      <link href="/2021/11/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2021/11/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1><span id="基于消息中间件的分布式系统的架构">基于消息中间件的分布式系统的架构</span></h1><h2><span id="消息中间件应用的场景">消息中间件应用的场景</span></h2><p>1:跨系统数据传递<br>2:高并发的流量削峰<br>3:数据的分发和异步处理<br>4:大数据分析与传递<br>5:分布式事务<br>比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行。</p><h2><span id="常见的消息中间件">常见的消息中间件</span></h2><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</p><p>MQ消息队列：负责数据的传接受，存储和传递，所以性能要过于普通服务和技术。</p><h2><span id="消息中间件的核心组成部分">消息中间件的核心组成部分</span></h2><p>1：消息的协议<br>2：消息的持久化机制<br>3：消息的分发策略<br>4：消息的高可用，高可靠<br>5：消息的容错机制</p><h2><span id="消息队列协议">消息队列协议</span></h2><p><strong>面试题：为什么消息中间件不直接使用http协议呢？</strong><br>1: 因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。<br>2:大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p><h3><span id="常见的持久化方式">常见的持久化方式</span></h3><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th><strong>Kafka</strong></th><th>RocketMQ</th></tr></thead><tbody><tr><td>文件存储</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h2><span id="消息分发策略的机制和对比">消息分发策略的机制和对比</span></h2><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>公平分发</td><td>/</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>消息拉取</td><td>/</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2021/11/04/Redis/"/>
      <url>/2021/11/04/Redis/</url>
      
        <content type="html"><![CDATA[<h1><span id="redis">Redis</span></h1><p><img src="/2021/11/04/Redis/image-20211104130443874.png" alt="image-20211104130443874"></p><p>因为没有指定配置文件</p><p>需配置</p><pre><code>redis-server redis.windows.conf</code></pre><p>之后自动启动</p><h2><span id="测试性能"><strong>测试性能</strong></span></h2><pre><code class="bash">redis-benchmark -p 6379 -c 100 -n 10000</code></pre><p><img src="/2021/11/04/Redis/image-20211104140217226.png" alt="image-20211104140217226"></p><p><img src="/2021/11/04/Redis/image-20211104140647780.png" alt="image-20211104140647780"></p><h2><span id="基础概念">基础概念：</span></h2><p><img src="/2021/11/04/Redis/image-20211104141011197.png" alt="image-20211104141011197"></p><p><img src="/2021/11/04/Redis/image-20211104141230255.png" alt="image-20211104141230255"></p><p>清空当前数据库：flushdb</p><p>清空全部数据库：flushall</p><blockquote><p>redis是单线程的</p></blockquote><p>redis的瓶颈是机器的内存和网络的带宽，用单线程既然可以实现，就用单线程了</p><blockquote><p>为什么单线程还这么快呢</p></blockquote><p>redis是将所有的数据全部放在内存中，所以说用单线程操作效率最高，多线程（cpu上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上，在内存情况下，这个就是最佳的选择。</p><h2><span id="底层数据结构参考httpswwwcnblogscomysoceanp9080942html_label3">底层数据结构（参考</span></h2><h3><span id="简单动态字符串">简单动态字符串</span></h3><p><img src="/2021/11/04/Redis/1120165-20180527234349672-568401853.png" alt="img"></p><p>　　一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。</p><h3><span id="链表">链表</span></h3><p>　Redis链表特性：</p><p>　　①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p><p>　　②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　</p><p>　　③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</p><p>　　④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值</p><h3><span id="字典">字典</span></h3><p>Redis 的字典使用哈希表作为底层实现、</p><p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p><p>　　注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决<strong>哈希冲突</strong>。</p><h3><span id="跳表">跳表</span></h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p><p>　　1、由很多层结构组成；</p><p>　　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p><p>　　3、最底层的链表包含了所有的元素；</p><p>　　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p><p>　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p><p>​        ①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p>　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。</p><p>　　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p><h3><span id="五大数据类型的应用场景">五大数据类型的应用场景</span></h3><p>对于string 数据类型，因为string 类型是二进制安全的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作计数器（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。</p><p>对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。</p><p>对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能</p><p>对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等</p><h1><span id="五大数据类型">五大数据类型</span></h1><h3><span id="redis-key">redis-key</span></h3><pre><code class="bash">#移除name keymove name 1</code></pre><p><img src="/2021/11/04/Redis/image-20211104143325041.png" alt="image-20211104143325041"></p><pre><code class="bash">#设置过期时间expire name 10 </code></pre><p><img src="/2021/11/04/Redis/image-20211104143636111.png" alt="image-20211104143636111"></p><p>查看剩余过期时间：ttl name;</p><pre><code class="bash">#查看键的类型type name</code></pre><p><img src="/2021/11/04/Redis/image-20211104143922548.png" alt="image-20211104143922548"></p><h3><span id="string">String</span></h3><p><img src="/2021/11/04/Redis/image-20211104144412464.png" alt="image-20211104144412464"></p><p>如果append后的键不存在就创建一个，相当于set</p><p><img src="/2021/11/04/Redis/image-20211104145142401.png" alt="image-20211104145142401"></p><blockquote><p>获取一部分值</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104145422840.png" alt="image-20211104145422840"></p><blockquote><p>获取全部的值 </p></blockquote><p><img src="/2021/11/04/Redis/image-20211104145501629.png" alt="image-20211104145501629"></p><blockquote><p>替换值</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104145749240.png" alt="image-20211104145749240"></p><blockquote><p>setex 设置过期时间</p><p>setnx 如果没有这个键就设置值成功，如果已存在这个键就设置不成功（在分布式锁中常应用 ）</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104150144398.png" alt="image-20211104150144398"></p><blockquote><p>批量设置键和值，批量获取值</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104150700175.png" alt="image-20211104150700175"></p><blockquote><p>msetnx 具有原子性</p></blockquote><p>设置对象，以json字符串的形式</p><p><img src="/2021/11/04/Redis/image-20211104151319002.png" alt="image-20211104151319002"></p><blockquote><p>getset</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104151448797.png" alt="image-20211104151448797"></p><h3><span id="list">List</span></h3><p>在redis中，list可以被我们玩成栈，队列，阻塞队列</p><blockquote><p>lpush 放进列表数据</p><p>lrange 取出指定位置的数据，可以看出下标是倒着来的。</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104152112654.png" alt="image-20211104152112654"></p><p>说明rpush把值放在了队列的最后面</p><p><img src="/2021/11/04/Redis/image-20211104152548954.png" alt="image-20211104152548954"></p><blockquote><p>从列表中移除值，可以分为移除左边的和右边的</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104153013118.png" alt="image-20211104153013118"></p><blockquote><p>通过下标获取值</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104153153183.png" alt="image-20211104153153183"></p><blockquote><p>获取列表长度</p></blockquote><p>llen</p><blockquote><p>移除指定的值,可指定数量</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104153655790.png" alt="image-20211104153655790"></p><blockquote><p>通过下标截取指定的长度</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104154058106.png" alt="image-20211104154058106"></p><blockquote><p>移除列表的最后一个元素，将他移动到新列表中</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104154308321.png" alt="image-20211104154308321"></p><blockquote><p>更新指定位置的值</p></blockquote><p><img src="/2021/11/04/Redis/image-20211104154722495.png" alt="image-20211104154722495"></p><p><img src="/2021/11/04/Redis/image-20211104155347613.png" alt="image-20211104155347613"></p><h3><span id="set">set</span></h3><p><img src="/2021/11/04/Redis/image-20211104155948255.png" alt="image-20211104155948255"></p><p><img src="/2021/11/04/Redis/image-20211104160159057.png" alt="image-20211104160159057"></p><p><img src="/2021/11/04/Redis/image-20211104160308656.png" alt="image-20211104160308656"></p><p><img src="/2021/11/04/Redis/image-20211104160609153.png" alt="image-20211104160500757"></p><p><img src="/2021/11/04/Redis/image-20211104161114018.png" alt="image-20211104161114018"></p><h3><span id="hash">hash</span></h3><p>Map集合，key-map，那时候这个值是一个map集合，本质和String类型没有太大区别，还是一个简单的key-vlaue</p><p><img src="/2021/11/04/Redis/image-20211104162116587.png" alt="image-20211104162116587"></p><p>获取hash表的内容长度</p><p><img src="/2021/11/04/Redis/image-20211104162829439.png" alt="image-20211104162829439"></p><p>获取所有的field和所有的值</p><p><img src="/2021/11/04/Redis/image-20211104163226493.png" alt="image-20211104163226493"></p><p>hash更适合于对象的存储</p><h3><span id="zset有序集合">Zset（有序集合）</span></h3><p><strong>排列</strong></p><p><img src="/2021/11/04/Redis/image-20211104170955039.png" alt="image-20211104170955039"></p><p>显示工资小于2000的工资排列</p><p><img src="/2021/11/04/Redis/image-20211104171308530.png" alt="image-20211104171308530"></p><p>移除指定元素</p><p><img src="/2021/11/04/Redis/image-20211104172219379.png" alt="image-20211104172219379"></p><p>获取集合中的个数</p><pre><code class="bash">zcard salary</code></pre><p>获取指定区间的成员数量</p><p><img src="/2021/11/04/Redis/image-20211104173454977.png" alt="image-20211104173454977"></p><p>总结：</p><p><img src="/2021/11/04/Redis/image-20211104175033465.png" alt="image-20211104175033465"></p><h1><span id="三种特殊数据类型">三种特殊数据类型</span></h1><h2><span id="geospatial地理位置">Geospatial(地理位置)</span></h2><blockquote><p>geoadd 添加地理位置</p></blockquote><pre><code class="bash">geoadd key longitude latitude member [longitude latitude member ...]</code></pre><blockquote><p>geopos获得地理位置详细信息</p></blockquote><pre><code class="bash">geopos key member [member ...]</code></pre><blockquote><p>geodist获得两个地点之间的距离，可在后面追加获得结果的单位 km m</p></blockquote><pre><code class="bash">geodist key member1 member2 [unit]</code></pre><blockquote><p>georadius获得以某一点经纬度为圆心，一定距离为半径之内的元素</p></blockquote><pre><code class="bash">georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC</code></pre><blockquote><p>georadiusbymember获得某一成员为圆心，一定距离为半径之内的元素</p></blockquote><blockquote><p>geo底层的实现原理是zset，可以使用zset命令来操作geo</p></blockquote><h2><span id="hyperloglog">hyperloglog</span></h2><p>统计基数</p><p>可以用作网站的UV（一个人访问网站多次，但是还是算作一个人）</p><p>传统的方式是用set，如果存储量太大的话就比较麻烦</p><blockquote><p>测试</p></blockquote><p><img src="/2021/11/04/Redis/image-20211105221008371.png" alt="image-20211105221008371"></p><h2><span id="bitmaps">bitmaps</span></h2><blockquote><p>位存储</p></blockquote><p>位图，是数据结构，都是操作二进制为来进行操作，只有0和1两个状态</p><p>统计一周的打卡情况</p><p><img src="/2021/11/04/Redis/image-20211105221855488.png" alt="image-20211105221855488"></p><p>查看某一天的打卡情况</p><p><img src="/2021/11/04/Redis/image-20211105222028892.png" alt="image-20211105222028892"></p><p>查看打卡了几天</p><pre><code class="bash">127.0.0.1:6379&gt; bitcount si(integer) 2</code></pre><h1><span id="事务">事务</span></h1><p>本质：一组命令的集合，所有命令都会被序列化，执行过程中，按照顺序执行</p><p><strong>redis单挑命令保存原子性，但是事务不保证原子性，没有隔离级别的概念</strong></p><p>所有命令在事务中，并不被直接执行，只有发起执行命令的时候才被执行</p><ol><li>开启事务</li><li>命令入队</li><li>执行事务</li></ol><blockquote><p>正常执行事务</p></blockquote><pre><code class="bash">127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec#执行事务1) OK2) OK3) &quot;v2&quot;4) OK127.0.0.1:6379&gt;</code></pre><blockquote><p>放弃事务</p></blockquote><p>discard</p><blockquote><p>编译型异常（代码有问题），事务中所有命令都不会被执行</p><pre><code class="bash">127.0.0.1:6379&gt; get k1(nil)127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k3(error) ERR wrong number of arguments for &#39;getset&#39; command127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.#所有事务不会被运行127.0.0.1:6379&gt;</code></pre></blockquote><blockquote><p>运行时异常（1/0），其他命令正常执行，错误命令抛出异常 </p></blockquote><pre><code class="bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1#字符串不会加1QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range#属于运行时异常2) &quot;v1&quot; #正常执行127.0.0.1:6379&gt;</code></pre><h2><span id="监控">监控</span></h2><h4><span id="乐观锁">乐观锁</span></h4><p>获取version，比较version</p><blockquote><p>监视：</p></blockquote><p>watch key [key …]</p><p>执行之前，另外一个线程如果修改了我们的值，事务就会执行失败，就要放弃监视，然后重新监视</p><blockquote><p>放弃监视</p></blockquote><p>unwatch key</p><h1><span id></span></h1><h1><span id="jedis">Jedis</span></h1><p>配置依赖</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.62&lt;/version&gt;        &lt;/dependency&gt;          &lt;/dependencies&gt;</code></pre><p>创建连接进行测试</p><pre><code class="java">Jedis jedis=new Jedis(&quot;127.0.0.1&quot;, 6379);System.out.println(jedis.ping());</code></pre><h1><span id="springboot整合">springboot整合</span></h1><p>底层为lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况，NIO模式 </p><p>jeids采用直连，多线程不安全，如想避免不安全，就使用jedis pool连接池,BIO模式</p><p>操作各种基本类型</p><p><img src="/2021/11/04/Redis/image-20211106154640957.png" alt="image-20211106154640957"></p><p>获得链接，操作数据库</p><p><img src="/2021/11/04/Redis/image-20211106154840090.png" alt="image-20211106154840090"></p><h2><span id="序列化">序列化</span></h2><p>放入对象需序列化</p><pre><code class="java">@Configurationpublic class RedisConfig &#123;    //编写自己的redisTemplate    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException &#123;        RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        //Json序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper objectMapper=new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);        //String的序列化        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();        //key采用String的序列化方式        redisTemplate.setKeySerializer(stringRedisSerializer);        //Hash的序列化方式也采用String的方式        redisTemplate.setHashKeySerializer(stringRedisSerializer);        //value序列化方式采用jackson        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;&#125;</code></pre><p>———————–固定配置模板</p><h1><span id="redisconf详解">Redis.conf详解</span></h1><p><img src="/2021/11/04/Redis/image-20211106221030918.png" alt="image-20211106221030918"></p><p>对大小写不敏感</p><blockquote><p>包含</p><p><img src="/2021/11/04/Redis/image-20211106221148896.png" alt="image-20211106221148896"></p><p>可包含多个配置文件</p></blockquote><blockquote><p>网络</p></blockquote><pre><code class="bash">bind 127.0.0.1protected-mode yes #保护模式port 6379 #默认端口</code></pre><p>绑定的IP</p><blockquote><p>通用</p></blockquote><pre><code class="bash"># NOT SUPPORTED ON WINDOWS daemonize no #window端不支持此配置，配置此项须在linux端daemonize yes #以守护进程的方式运行，默认是no，我们需要自己开启为yes# NOT SUPPORTED ON WINDOWS pidfile /var/run/redis.pid#如果指定为后台方式运行，则需指定pid文件pidfile /var/run/redis.pid#日志级别# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel noticelogfile &quot;&quot; #日志文件位置databases 16 #默认数据库数量</code></pre><blockquote><p>快照</p></blockquote><p>持久化：在规定时间内，执行了多少次操作则会持久化到文件.rdb .aof</p><p>reids是内存数据库，如果没有持久化，那么数据断电即失。</p><pre><code class="bash">save 900 1 #如果900s内，有一个key进行了修改，我们将进行持久化操作。以下皆同save 300 10save 60 10000stop-writes-on-bgsave-error yes#持久化出错，redis是否还继续工作rdbcompression yes#是否压缩rdb文件rdbchecksum yes #保存rdb文件的时候，进行错误的检查校验dir ./ #rdb文件的保存目录</code></pre><blockquote><p>安全</p></blockquote><pre><code class="bash">127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config set requirepass 1234 #设置密码OK127.0.0.1:6379&gt; config get requirepass(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 1234 #登录OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;1234&quot;127.0.0.1:6379&gt;</code></pre><p><img src="/2021/11/04/Redis/image-20211107174514097.png" alt="image-20211107174514097"></p><blockquote><p>客户端连接相关</p></blockquote><pre><code class="bash"># maxclients 10000a 最大客户端数量# maxmemory &lt;bytes&gt; 最大内存限制# maxmemory-policy noeviction 内存到达极限值的处理策略</code></pre><h4><span id="maxmemory-policy-六种方式"><strong>maxmemory-policy 六种方式</strong></span></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p><p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p><p><strong>3、volatile-random：</strong>随机删除即将过期key</p><p><strong>4、allkeys-random：</strong>随机删除</p><p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p><p><strong>6、noeviction ：</strong> 永不过期，返回错误</p><h1><span id="redis持久化">Redis持久化</span></h1><p><strong>RDB：Redis Databases</strong></p><h2><span id="什么是rdb">什么是RDB</span></h2><hr><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16362795898172" alt="在这里插入图片描述"></p><p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3><span id="工作原理">工作原理</span></h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3><span id="触发机制">触发机制</span></h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h3><span id="优缺点">优缺点</span></h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2><span id="aof">AOF</span></h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><blockquote><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3><span id="什么是aof">什么是AOF</span></h3><p>快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src="/2021/11/04/Redis/20200513215247113.png" alt="在这里插入图片描述"></p><p><code>appendonly no yes</code>则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><pre><code class="bash">123456appendonly yes  # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用appendfilename &quot;appendonly.aof&quot;# appendfsync always # 每次修改都会sync 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据# appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</code></pre><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2><span id="rdb和aop选择">RDB和AOP选择</span></h2><h3><span id="rdb优势与劣势">RDB优势与劣势</span></h3><h4><span id="优势">优势</span></h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><h4><span id="劣势">劣势</span></h4><ul><li><p>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p></li><li><p>Fork的时候，内存中的数据被<code>克隆</code>了一份，<code>大致2倍</code>的膨胀性能需要考虑</p></li></ul><h3><span id="aof优势劣势">AOF优势/劣势</span></h3><h4><span id="优势">优势</span></h4><ul><li>每次修改同步：appendfsync always同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li><li>每秒同步：appendfsync everysec异步操作，每秒记录，如果一秒内宕机，仅一秒内的数据丢失</li></ul><h4><span id="劣势">劣势</span></h4><ul><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li></ul><p>RDB消耗性能大，如果宕机可能丢失最后一次所做的修改，但是文件小，恢复快</p><h3><span id="如何选择使用哪种持久化方式">如何选择使用哪种持久化方式？</span></h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h1><span id="redis发布订阅">Redis发布订阅</span></h1><blockquote><p>订阅</p></blockquote><pre><code class="bash">subscribe hongdouReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;hongdou&quot;3) (integer) 1</code></pre><blockquote><p>发布</p><pre><code class="bash">127.0.0.1:6379&gt; publish hongdou hahaha(integer) 1</code></pre><p>结果：</p><pre><code class="原理">1) &quot;message&quot;2) &quot;hongdou&quot;3) &quot;hahaha&quot;</code></pre></blockquote><h3><span id="原理">原理</span></h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16362932182646" alt="在这里插入图片描述"></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3><span id="缺点">缺点</span></h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3><span id="应用">应用</span></h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h1><span id="redis主从复制">Redis主从复制</span></h1><h3><span id="概念">概念</span></h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是<strong>单向</strong>的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p><strong>默认情况下，每台Redis服务器都是主节点</strong>，<strong>一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</strong></p><h3><span id="作用">作用</span></h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3><span id="为什么使用集群">为什么使用集群</span></h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3><span id="环境配置">环境配置</span></h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><pre><code class="bash">123456789101112127.0.0.1:6379&gt; info replication# Replicationrole:master # 角色connected_slaves:0 # 从机数量master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcffmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li><p>端口号</p></li><li><p>pid文件名</p></li><li><p>日志文件名</p></li><li><p>rdb文件名</p></li></ul><h5><span id="注意window配置方法">注意：window配置方法：</span></h5><p>开启多个端口服务器<br>1.配置文件<br>将redis.windows-service.conf复制一份，改名为相应文件，并更改配置文件中的端口为指定端口，以6380为例</p><p>port 6380</p><p>2.安装服务<br><strong>redis-server –service-install –service-name redis_6380 redis.windows-service-6380.conf</strong><br>3.启动服务<br><strong>redis-server –service-start –service-name redis_6380</strong><br>4.停止服务<br><strong>redis-server –service-stop –service-name redis_6380</strong><br>5.卸载服务<br><strong>redis-server –service-uninstall –service-name redis_6380</strong></p><p>指定端口启动客户端：<br><strong>redis.cli -p 端口号</strong></p><p><img src="/2021/11/04/Redis/image-20211108113934528.png" alt="image-20211108113934528"></p><p><strong>启动单机多服务集群：</strong></p><p><img src="/2021/11/04/Redis/20200513215610163.png" alt="在这里插入图片描述"></p><h3><span id="一主二从配置">一主二从配置</span></h3><p>默认情况下，每台Redis服务器都是主节点；一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p><p><img src="/2021/11/04/Redis/image-20211108114239188.png" alt="image-20211108114239188"></p><p><img src="/2021/11/04/Redis/image-20211108114323436.png" alt="image-20211108114323436"></p><p>主机截图：</p><p><img src="/2021/11/04/Redis/image-20211108114407873.png" alt="image-20211108114407873"></p><p>使用命令搭建是暂时的，真实开发中应该在从机的配置文件中进行配置，这样的话是永久的。</p><p><img src="/2021/11/04/Redis/image-20211108114911108.png" alt="image-20211108114911108"></p><h4><span id="规则">规则</span></h4><p>从机只能读，不能写，主机可读可写但是多用于写。</p><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理</p><blockquote><p>复制原理</p></blockquote><p>从机成功连接到主机后会发送一个同步命令</p><p>主机接到命令，启动后台存盘进程，同时收集所有的收到用于修改数据集命令，在后台进程执行完毕之后，主机将整个数据文件传送到从机，完成一次完全同步</p><p><strong>全量复制</strong>：第一次连接时，获取主机的全部数据</p><p><strong>增量复制</strong>：每次更新数据同步到从机</p><h3><span id="层层链路">层层链路</span></h3><p>主机从机成链路式连接</p><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点</p><blockquote><p>哨兵模式的全部配置</p></blockquote><p>完整的哨兵模式配置文件 sentinel.conf</p><pre><code class="bash">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1   # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。  #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，#一个是事件的类型，#一个是事件的描述。#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre><h2><span id="缓存穿透与雪崩">缓存穿透与雪崩</span></h2><h3><span id="缓存穿透查不到">缓存穿透（查不到）</span></h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16363526192282" alt="在这里插入图片描述"></p><p><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16363526320984" alt="在这里插入图片描述"></p><p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3><span id="缓存击穿量太大缓存过期">缓存击穿（量太大，缓存过期）</span></h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3><span id="缓存雪崩">缓存雪崩</span></h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p><img src="/2021/11/04/Redis/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70-16363526462886" alt="在这里插入图片描述"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li><li><p><img src="/2021/11/04/Redis/1647835150674.png" alt="1647835150674"></p></li></ul><h2><span id="缓存一致性">缓存一致性</span></h2><p>先更新数据库，在更新缓存，先更新缓存，再更新数据库都会有问题</p><p>先更新数据库再删除缓存可以解决，因为缓存的写入要快于数据库的写入，但是会影响缓存的命中率，</p><p>对于解决先删除缓存再更新数据库问题：此时就引入了延时双删：</p><pre><code>删除缓存更新数据库睡眠 需要大于第二个线程读取数据并写入缓存的时间删除缓存</code></pre><p>睡眠时间难以估算，所以还是先更新数据库再删除缓存比较好</p><h2><span id="淘汰策略">淘汰策略</span></h2><p>禁止淘汰</p><p>从设置了过期时间的数据中淘汰将要过期的</p><p>从设置了过期时间的数据中淘汰最近最久未使用的 </p><p>从设置了过期时间的数据中随机淘汰数据</p><p>淘汰最近最久未使用的</p><p>随机淘汰数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/2021/11/02/dubbo/"/>
      <url>/2021/11/02/dubbo/</url>
      
        <content type="html"><![CDATA[<h1><span id="dubbo">Dubbo</span></h1><h2><span id="rpc框架">RPC框架</span></h2><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。</p><p>Apache Dubbo (incubating) 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</p><h2><span id="注册中心-zookeeperregistry">注册中心 zookeeper(Registry)</span></h2><p><img src="/2021/11/02/dubbo/image-20211102170838813.png" alt="image-20211102170838813"></p><p><strong>服务提供者</strong>（<strong>Provider</strong>）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p><strong>服务消费者</strong>（<strong>Consumer</strong>）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p><strong>注册中心</strong>（<strong>Registry</strong>）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p><p><strong>监控中心</strong>（<strong>Monitor</strong>）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><h1><span id="dubbo配置">dubbo配置</span></h1><h2><span id="1-配置原则">1、配置原则</span></h2><p><img src="/2021/11/02/dubbo/wpsBCDE.tmp.png" alt="img"> </p><p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p><p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p><p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p><h2><span id="2-重试次数">2、重试次数</span></h2><p>失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</p><p>重试次数配置如下</p><pre><code class="xml">&lt;dubbo:service retries=&quot;2&quot; /&gt;或&lt;dubbo:reference retries=&quot;2&quot; /&gt;或&lt;dubbo:reference&gt;&lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt;</code></pre><h2><span id="3-超时时间">3、超时时间</span></h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p><h3><span id="1-dubbo消费端">1、Dubbo消费端</span></h3><pre><code class="xml">全局超时配置&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt; 指定接口以及特定方法超时配置&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;      &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;&lt;/dubbo:reference&gt;</code></pre><h3><span id="2-dubbo服务端">2、Dubbo服务端</span></h3><pre><code class="xml">全局超时配置&lt;dubbo:provider timeout=&quot;5000&quot; /&gt; 指定接口以及特定方法超时配置&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;  &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;&lt;/dubbo:provider&gt;</code></pre><h3><span id="3-配置原则">3、配置原则</span></h3><p>dubbo推荐在Provider上尽量多配置Consumer端属性：</p><p>1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p><p>配置的覆盖规则：</p><p>\1) 方法级配置别优于接口级别，即小Scope优先 </p><p>\2) Consumer端配置 优于 Provider配置 优于 全局配置，</p><p>\3) 最后是Dubbo Hard Code的配置值（见配置文档）</p><p><img src="/2021/11/02/dubbo/wpsBCDF.tmp.png" alt="img"> </p><h2><span id="4-版本号">4、版本号</span></h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><p>可以按照以下的步骤进行版本迁移：</p><p>在低压力时间段，先升级一半提供者为新版本</p><p>再将所有消费者升级为新版本</p><p>然后将剩下的一半提供者升级为新版本</p><pre><code class="xml">老版本服务提供者配置：&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;新版本服务提供者配置：&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; 老版本服务消费者配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt; 新版本服务消费者配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt; 如果不需要区分版本，可以按照以下的方式配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;</code></pre><h1><span id="三-高可用">三、高可用</span></h1><h2><span id="1-zookeeper宕机与dubbo直连">1、zookeeper宕机与dubbo直连</span></h2><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</p><p>原因：</p><p>健壮性l 监控中心宕掉不影响使用，只是丢失部分采样数据l 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务l 注册中心对等集群，任意一台宕掉后，将自动切换到另一台l <strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong>l 服务提供者无状态，任意一台宕掉后，不影响使用l 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 </p><p>高可用：通过设计，减少系统不能提供服务的时间；</p><h2><span id="2-集群下dubbo负载均衡配置">2、集群下dubbo负载均衡配置</span></h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><p>负载均衡策略</p><p><strong>Random LoadBalance</strong>随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。<strong>RoundRobin LoadBalance</strong>轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><p><strong>LeastActive LoadBalance</strong>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。<strong>ConsistentHash LoadBalance</strong>一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing%E7%BC%BA%E7%9C%81%E5%8F%AA%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0">http://en.wikipedia.org/wiki/Consistent_hashing缺省只对第一个参数</a> Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt;缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</p><h2><span id="3-整合hystrix服务熔断与降级处理">3、整合hystrix，服务熔断与降级处理</span></h2><h3><span id="1-服务降级">1、服务降级</span></h3><p><strong>什么是服务降级？</strong></p><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p>向注册中心写入动态配置覆盖规则：</p><pre><code class="java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;)); </code></pre><p>其中：</p><p>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</p><p>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p><h3><span id="2-集群容错">2、集群容错</span></h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><strong>集群容错模式</strong></p><p><strong>Failover Cluster</strong>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。 重试次数配置如下：&lt;dubbo:service retries=”2” /&gt;或&lt;dubbo:reference retries=”2” /&gt;或<a href="dubbo:reference">dubbo:reference</a>  &lt;dubbo:method name=”findFoo” retries=”2” /&gt; </p><p><strong>Failfast Cluster</strong>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 </p><p><strong>Failsafe Cluster</strong>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 <strong>Failback Cluster</strong>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 <strong>Forking Cluster</strong>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p><p> <strong>Broadcast Cluster</strong>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p> <strong>集群模式配置</strong>按照以下示例在服务提供方和消费方配置集群模式&lt;dubbo:service cluster=”failsafe” /&gt;或&lt;dubbo:reference cluster=”failsafe” /&gt;</p><h3><span id="3-整合hystrix">3、整合hystrix</span></h3><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p><h4><span id="1-配置spring-cloud-starter-netflix-hystrix"><strong>1、配置spring-cloud-starter-netflix-hystrix</strong></span></h4><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p><pre><code class="xml">    &lt;dependency&gt;              &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;              &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>然后在Application类上增加@EnableHystrix来启用hystrix starter：</p><pre><code class="java">@SpringBootApplication@EnableHystrixpublic class ProviderApplication &#123; </code></pre><h4><span id="2-配置provider端"><strong>2、配置Provider端</strong></span></h4><p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p><pre><code class="java">@Service(version = &quot;1.0.0&quot;)public class HelloServiceImpl implements HelloService &#123;      @HystrixCommand(commandProperties = &#123;       @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),       @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;)    @Override      public String sayHello(String name) &#123;            // System.out.println(&quot;async provider received: &quot; + name);            // return &quot;annotation: hello, &quot; + name;            throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);  &#125;&#125;</code></pre><h4><span id="3-配置consumer端"><strong>3、配置Consumer端</strong></span></h4><p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = “reliable”的调用里。</p><pre><code class="java"> @Reference(version = &quot;1.0.0&quot;)  private HelloService demoService;   @HystrixCommand(fallbackMethod = &quot;reliable&quot;)   public String doSayHello(String name) &#123;         return demoService.sayHello(name);  &#125;   public String reliable(String name) &#123;        return &quot;hystrix fallback value&quot;;  &#125;</code></pre><h1><span id="四-dubbo原理">四、dubbo原理</span></h1><h2><span id="1-rpc原理">1、RPC原理</span></h2><p><img src="/2021/11/02/dubbo/wpsBCEF.tmp.jpg" alt="img"> </p><p>一次完整的RPC调用流程（同步调用，异步另说）如下： <strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> 2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 3）client stub找到服务地址，并将消息发送到服务端； 4）server stub收到消息后进行解码； 5）server stub根据解码结果调用本地的服务； 6）本地服务执行并将结果返回给server stub； 7）server stub将返回结果打包成消息并发送至消费方； 8）client stub接收到消息，并进行解码； <strong>9）服务消费方得到最终结果。</strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h2><span id="2-netty通信原理">2、netty通信原理</span></h2><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><p>BIO：(Blocking IO)</p><p><img src="/2021/11/02/dubbo/wpsBCF0.tmp.jpg" alt="img"> </p><p>NIO (Non-Blocking IO)</p><p><img src="/2021/11/02/dubbo/wpsBCF1.tmp.jpg" alt="img"> </p><p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p><p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p><p>Netty基本原理：</p><p><img src="/2021/11/02/dubbo/wpsBCF2.tmp.jpg" alt="img"> </p><h2><span id="3-dubbo原理">3、dubbo原理</span></h2><h3><span id="1-dubbo原理-框架设计">1、dubbo原理    -框架设计</span></h3><p><img src="/2021/11/02/dubbo/wpsBCF3.tmp.png" alt="img"> </p><p>l config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</p><p>l proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</p><p>l registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</p><p>l cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</p><p>l monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</p><p>l protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</p><p>l exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</p><p>l transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</p><p>l serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</p><h3><span id="2-dubbo原理-启动解析-加载配置信息">2、dubbo原理    -启动解析、加载配置信息</span></h3><p><img src="/2021/11/02/dubbo/wpsBD04.tmp.jpg" alt="img"> </p><h3><span id="3-dubbo原理-服务暴露">3、dubbo原理    -服务暴露</span></h3><p><img src="/2021/11/02/dubbo/wpsBD05.tmp.png" alt="img"> </p><h3><span id="4-dubbo原理-服务引用">4、dubbo原理    -服务引用</span></h3><p><img src="/2021/11/02/dubbo/wpsBD06.tmp.png" alt="img"> </p><h3><span id="5-dubbo原理-服务调用">5、dubbo原理    -服务调用</span></h3><p><img src="/2021/11/02/dubbo/wpsBD07.tmp.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴婷儿的周末采风</title>
      <link href="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/"/>
      <url>/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/</url>
      
        <content type="html"><![CDATA[<h4><span id="2021-10-24">2021-10-24</span></h4><p>嘿嘿，先来一张试试手😁😁😁</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211025144914.jpg" alt="微信图片_20211025144914"></p><p>这张，邻家小妹的感觉！！！👩‍🦰</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211025145201.jpg" alt="微信图片_20211025145201"></p><p>说实话，这一张虽然很好看，但是属于只让我看的一种类型🤐🤐🤐</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449141.jpg" alt="微信图片_202110251449141"></p><p>哈哈，这张就很可爱啦~🤪🤪🤪</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449142-16351451102662.jpg" alt="微信图片_202110251449142"></p><p>很有港风文艺范的感觉</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449143.jpg" alt="微信图片_202110251449143"></p><p>吊带掉下来了😪😪😪</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449144.jpg" alt="微信图片_202110251449144"></p><p>假装自己在拍照系列😶😶😶👸👸👸</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449145.jpg" alt="微信图片_202110251449145"></p><p>这个也很好看！！！🥞🥞🥞</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449146.jpg" alt="微信图片_202110251449146"></p><p>回归可爱<strong>类型儿</strong>(✿◡‿◡)</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449147.jpg" alt="微信图片_202110251449147"></p><p>标准美照！！！🥩</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251449148.jpg" alt="微信图片_202110251449148"></p><p>这个也是，同上。</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452011.jpg" alt="微信图片_202110251452011"></p><p>接下来这两张就是满满的欢乐气息啦！！！🛴🛴🛴🛴</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452012.jpg" alt="微信图片_202110251452012"></p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452013.jpg" alt="微信图片_202110251452013"></p><p>同样邻家小妹类型儿</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452014.jpg" alt="微信图片_202110251452014"></p><p>哎呀，这不是宝贝和她姨嘛，额，看错了看错了，不好意思，是宝贝和美丽温柔还带有一点点成熟气息的小静<strong>儿</strong>🤗🤗🤗</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452015.jpg" alt="微信图片_202110251452015"></p><p>拍了一下午照，憔悴的美😎</p><p><img src="/2021/10/25/%E5%90%B4%E5%A9%B7%E5%84%BF%E7%9A%84%E5%91%A8%E6%9C%AB%E9%87%87%E9%A3%8E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202110251452016-16351451102663.jpg" alt="微信图片_202110251452016"></p>]]></content>
      
      
      <categories>
          
          <category> 生活园地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> record sweetheart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="/2021/10/23/UML/"/>
      <url>/2021/10/23/UML/</url>
      
        <content type="html"><![CDATA[<h1><span id="uml关系">uml关系</span></h1><p><strong>类之间的关系：依赖，泛化，实现，关联，聚合与组合</strong></p><h2><span id="依赖关系">依赖关系</span></h2><p><strong>———&gt;</strong>  </p><p><img src="/2021/10/23/UML/image-20211023201026812.png" alt="image-20211023201026812"></p><h2><span id="泛化关系">泛化关系</span></h2><p>就是继承关系</p><p>实线+空心箭头</p><h2><span id="实现关系">实现关系</span></h2><p>一个类实现接口关系</p><p>虚线+空心箭头</p><h2><span id="关联关系">关联关系</span></h2><p><img src="/2021/10/23/UML/image-20211023202554822.png" alt="image-20211023202554822"></p><h2><span id="聚合关系">聚合关系</span></h2><p><img src="/2021/10/23/UML/image-20211023202721548.png" alt="image-20211023202721548"></p><h2><span id></span></h2><h2><span id="组合关系">组合关系</span></h2><p>也是整体与部分的关系，只不过整体与部分不可分开‘</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式Study-0</title>
      <link href="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/"/>
      <url>/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/</url>
      
        <content type="html"><![CDATA[<h1><span id="设计模式七大原则">设计模式七大原则</span></h1><h3><span id="单一职责原则">单一职责原则</span></h3><p>通常在类级别实行单一职责，只有在类中方法足够少的情况下，才可以在方法级别保持单一职责原则。</p><p><strong>用类来化解分支</strong></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022104314536.png" alt="image-20211022104314536"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022102844895.png" alt="image-20211022102844895"><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022102908817.png" alt="image-20211022102908817"></p><h3><span id="接口隔离原则">接口隔离原则</span></h3><p><strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p><blockquote><p>初始版本</p></blockquote><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022110421886.png" alt="image-20211022110421886"></p><p>依赖关系示例图：</p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022110802941.png" alt="image-20211022110802941"></p><blockquote><p>改进版</p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022110528996.png" alt="image-20211022110528996"></p></blockquote><h3><span id="依赖倒转倒置原则">依赖倒转（倒置）原则</span></h3><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022112257188.png" alt="image-20211022112257188"></p><p>设计理念：相对于细节（具体的实现类），抽象（接口，抽象类）的东西更<strong>稳定</strong>（优点见上图），以<strong>抽象为基础搭建的架构</strong>比<strong>以细节为架构</strong>要更稳定</p><p>使用接口或抽象类的目的是<strong>制定好规范</strong>，不涉及<strong>具体的操作</strong>，把<strong>展现细节</strong>交给具体实现类去完成。</p><p>细节应该<strong>依赖抽象</strong>，核心思想是<strong>面向接口编程</strong></p><p>EXAMPLE:</p><p>客户端：</p><pre><code class="java">package 依赖倒转;import java.time.Period;public class Client &#123;    public static void main(String[] args) &#123;        Person person=new Person();        person.receive(new Email());        person.receive(new Weixin());    &#125;&#125;</code></pre><p>统一发信息接口：</p><pre><code class="java">package 依赖倒转;interface IReceiver &#123;    public String getInfo();&#125;</code></pre><p>微信和email分别建立实体类实现统一发送信息接口，由此可以在上图客户端中实现功能。</p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022115039056.png" alt="image-20211022115039056"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022114045857.png" alt="image-20211022114045857"></p><h3><span id="里氏替换原则">里氏替换原则</span></h3><p>引出：继承也有一些弊端：带来侵入性，增加了对象之间的耦合性。一个父类被多个子类继承时，当父类修改功能，则必须要考虑到所有的子类，而且修改后子类的功能会产生故障。</p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022122710402.png" alt="image-20211022122710402"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022122725461.png" alt="image-20211022122725461"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022122850226.png" alt="image-20211022122850226"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211022122914008.png" alt="image-20211022122914008"></p><h3><span id="开闭原则">开闭原则</span></h3><p>对扩展开放（提供方），对修改关闭（使用方）</p><p>尽量添加代码而不去修改</p><h3><span id="迪米特法则">迪米特法则</span></h3><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211023183516689.png" alt="image-20211023183516689"></p><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/image-20211023183343984.png" alt="image-20211023183343984"></p><h3><span id="合成复用原则">合成复用原则</span></h3><p>尽量使用合成或聚合的方式，不要使用继承，降低耦合度。</p><h2><span id="设计原则核心思想">设计原则核心思想</span></h2><p><img src="/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-0/Blog\source_posts\设计模式Study-0\image-20211023193922411.png" alt="image-20211023193922411"></p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> 设计模式 </category>
          
          <category> 开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS、Npm、Es6、Babel</title>
      <link href="/2021/10/20/NodeJS%E3%80%81Npm%E3%80%81Es6%E3%80%81Babel/"/>
      <url>/2021/10/20/NodeJS%E3%80%81Npm%E3%80%81Es6%E3%80%81Babel/</url>
      
        <content type="html"><![CDATA[<h1><span id="前端技能基础杂烩">前端技能基础杂烩</span></h1><p>学习文档地址：<a href="https://www.kuangstudy.com/bbs/1351463043300708353">https://www.kuangstudy.com/bbs/1351463043300708353</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS、Npm、Es6、Babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatisPlus</title>
      <link href="/2021/10/16/mybatisPlus/"/>
      <url>/2021/10/16/mybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatisplus">mybatisPlus</span></h1><p><img src="/2021/10/16/mybatisPlus/image-20211016165647437.png" alt="image-20211016165647437"></p><h2><span id="入门">入门</span></h2><p>mapper接口文件继承<strong>basemapper</strong>，记得加参数要显示查询对象类型</p><pre><code class="java">//继承Basemapper就可以不编写xml文件了@Repository//代表是持久层public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;</code></pre><p>注意：🧨🧨🧨🧨🧨要在主启动类下配置扫描的mapper包下所有的接口</p><pre><code class="java">@MapperScan(&quot;com.zz.mybatisplus.mapper&quot;)</code></pre><p>🎇🎇🎇🎇🎇🎇</p><h2><span id="日志配置">日志配置</span></h2><p>为了查看sql语句运用情况</p><pre><code class="yml">mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>结果：</p><p><img src="/2021/10/16/mybatisPlus/image-20211016173856822.png" alt="image-20211016173856822"></p><h2><span id></span></h2><h2><span id="主键生成策略">主键生成策略</span></h2><p>雪花算法</p><blockquote><p>默认 ID_WORKER 全局唯一id</p></blockquote><pre><code class="java">/** * &lt;p&gt; * 生成ID类型枚举类 * &lt;/p&gt; * * @author hubin * @since 2015-11-10 */@Getterpublic enum IdType &#123;    /**     * 数据库ID自增     */    AUTO(0),    /**     * 该类型为未设置主键类型     */    NONE(1),    /**     * 用户输入ID     * 该类型可以通过自己注册自动填充插件进行填充     */    INPUT(2),    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */    /**     * 全局唯一ID (idWorker)     */    ID_WORKER(3),    /**     * 全局唯一ID (UUID)     */    UUID(4),    /**     * 字符串全局唯一ID (idWorker 的字符串表示)     */    ID_WORKER_STR(5);    private int key;    IdType(int key) &#123;        this.key = key;    &#125;&#125;</code></pre><p><img src="/2021/10/16/mybatisPlus/image-20211017192539524.png" alt="image-20211017192539524"></p><blockquote><p>主键自增</p></blockquote><p>实体类字段上 </p><pre><code class="java">@TableId(type = IdType.AUTO)</code></pre><p>数据库字段一定要是自增！</p><h2><span id="更新操作"><img src="/2021/10/16/mybatisPlus/image-20211017193225402.png">更新操作</span></h2><p>参数为对象</p><pre><code class="java">@Test    void test1()&#123;        User user=new User(6,&quot;gzz&quot;,89,&quot;1614399965@qq.com&quot;);        userMapper.updateById(user);    &#125;</code></pre><h2><span id="自动填充时间">自动填充时间</span></h2><p>1.数据库管理工具设置</p><p>2.代码级别设置</p><blockquote><p>实体类字段属性上需要增加注解</p></blockquote><p><img src="/2021/10/16/mybatisPlus/image-20211017200938069.png" alt="image-20211017200938069"></p><p>实现自己的处理器</p><pre><code class="java">@Slf4j@Component//把自己的处理器添加到IOC容器中public class My implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        log.debug(&quot;=================insertFill被调用==================&quot;);        this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject);        this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        log.debug(&quot;==========updateFill被调用====================&quot;);        this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);    &#125;&#125;</code></pre><p>结果查看：</p><p><img src="/2021/10/16/mybatisPlus/image-20211017201647403.png" alt="image-20211017201647403"></p><h2><span id></span></h2><h2><span id="乐观锁">乐观锁</span></h2><p>原理：</p><p>  取出记录时，获取当前 version</p><p> 更新时，带上这个version </p><p>  执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败</p><pre><code class="sql">乐观锁：1、先查询，获得版本号 version = 1-- Aupdate user set name = &quot;kuangshen&quot;, version = version + 1where id = 2 and version = 1-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！update user set name = &quot;kuangshen&quot;, version = version + 1where id = 2 and version = 1</code></pre><p><img src="/2021/10/16/mybatisPlus/image-20211017211514770.png" alt="image-20211017211514770"></p><p>数据库增加<strong>version</strong>字段，默认为一</p><p>实体类加对应的字段，增加对应的注解</p><pre><code class="java">@Version//乐观锁private Integer version;</code></pre><p>注册组件</p><pre><code class="java">@MapperScan(&quot;com.zz.mybatisplus.mapper&quot;)@EnableTransactionManagement//自动管理事务@Configurationpublic class Myconfig &#123;    //注册乐观锁插件    @Bean     public OptimisticLockerInterceptor optimisticLockerInterceptor()&#123;        return new OptimisticLockerInterceptor();    &#125;&#125;</code></pre><p>测试</p><pre><code class="Java"> //测试乐观锁    @Test    void test3()&#123;        // 线程 1        User user = userMapper.selectById(1L);        user.setName(&quot;zz111&quot;);        // 模拟另外一个线程执行了插队操作        User user2 = userMapper.selectById(1L);        user2.setName(&quot;zz222&quot;);        userMapper.updateById(user2);        userMapper.updateById(user);//如果没有乐观锁就会覆盖插队线程的值    &#125;</code></pre><p>结果可以看到名字更新最终结果为zz222</p><p><img src="/2021/10/16/mybatisPlus/image-20211017212009400.png" alt="image-20211017212009400"></p><h2><span id></span></h2><h2><span id="逻辑删除">逻辑删除</span></h2><p>1.</p><p>数据库添加逻辑删除字段，默认为0<img src="/2021/10/16/mybatisPlus/image-20211018134702720.png" alt="image-20211018134702720"></p><p>2.</p><p>实体类添加注解和属性</p><pre><code class="java">@TableLogic//逻辑删除private Integer deleted;</code></pre><p>3.</p><p><strong>配置</strong></p><p>注册逻辑删除组件</p><pre><code class="java">  //逻辑删除    @Bean    public ISqlInjector sqlInjector()&#123;        return new LogicSqlInjector();    &#125;</code></pre><pre><code class="yml">mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  #逻辑删除配置  global-config:    db-config:      logic-delete-value: 1      logic-not-delete-value: 0</code></pre><p>体验：<img src="/2021/10/16/mybatisPlus/image-20211018134947771.png" alt="image-20211018134947771"></p><p><img src="/2021/10/16/mybatisPlus/image-20211018135228638.png" alt="image-20211018135228638"></p><p>可以看出实际是把deleted字段的值变为一，之后再查询的时候SQL语句会自动根据deleted=0来过滤，可以看下图</p><p><img src="/2021/10/16/mybatisPlus/image-20211018135453151.png" alt="image-20211018135453151"></p><h2><span id></span></h2><h2><span id="条件构造器">条件构造器</span></h2><p>实例在项目测试用例中查看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2021/10/13/Linux/"/>
      <url>/2021/10/13/Linux/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux">Linux</span></h1><blockquote><p><strong>/</strong> 为根目录</p></blockquote><p><img src="/2021/10/13/Linux/image-20211013121356670.png" alt="image-20211013121356670"></p><blockquote><p>pwd会显示当前用户所在的目录</p><p>递归创建目录   </p><pre><code>mkdir -p</code></pre></blockquote><p><strong>rmdir ( 删除空的目录 )</strong></p><h3><span id="基本属性">基本属性</span></h3><p><img src="/2021/10/13/Linux/image-20211013123219345.png" alt="image-20211013123219345"></p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li><p>当为[ <strong>d</strong> ]则是目录</p></li><li><p>当为[ <strong>-</strong> ]则是文件；</p></li><li><p>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</p></li><li><p>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</p></li><li><p>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</p></li><li><p><img src="/2021/10/13/Linux/image-20211013172707239.png" alt="image-20211013172707239"></p><p><strong>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</strong></p><p><strong>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</strong></p><p><strong>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</strong></p></li></ul><p><img src="/2021/10/13/Linux/640" alt="图片"></p><p>在以上实例中，属主和属组都为 root</p><blockquote><p>修改文件属性</p></blockquote><p><strong>1、chgrp：更改文件属组</strong></p><pre><code class="bash">chgrp [-R] 属组名 文件名</code></pre><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><pre><code class="bash">chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名</code></pre><p><strong>3、chmod：更改文件9个属性</strong></p><pre><code class="bash">chmod [-R] xyz 文件或目录</code></pre><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><pre><code class="bash">r:4     w:2         x:1</code></pre><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><pre><code class="bash">chmod 770 filename</code></pre><h3><span id="文件内容查看">文件内容查看</span></h3><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容 空格键表示下一页，回车键表示下一行  / 开启查询功能   </li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>ifconfig查看网络配置<img src="/2021/10/13/Linux/image-20211014103811937.png" alt="image-20211014103811937"></p><h3><span id="账号管理">账号管理</span></h3><p>用户账号的管理</p><blockquote><p>添加账号 useradd</p></blockquote><pre><code>useradd 选项 用户名</code></pre><p>参数说明：</p><ul><li><p>选项 :</p></li><li><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-m　使用者目录如不存在则自动建立。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul></li><li><p>用户名 :</p></li><li><p>指定新账号的登录名。</p></li></ul><blockquote><p>Linux下如何切换用户<br>  1.切换用户的命令为：su username 【username是你的用户名哦】</p></blockquote><blockquote><p>删除帐号  </p></blockquote><pre><code class="bash">userdel 选项 用户名</code></pre><p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><blockquote><p>修改帐号</p></blockquote><pre><code class="bash">usermod 选项 用户名</code></pre><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p><p>例如：</p><pre><code class="bash"># usermod -s /bin/ksh -d /home/z –g developer kuangshen</code></pre><p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p><blockquote><p><strong>etc/passwd</strong></p></blockquote><pre><code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><p><img src="/2021/10/13/Linux/image-20211015101642181.png" alt="image-20211015101642181"></p><p>查看磁盘：df -h     du查看当前目录使用空间情况</p><p><img src="/2021/10/13/Linux/image-20211015110307308.png" alt="image-20211015110307308"></p><p>挂载</p><p><img src="/2021/10/13/Linux/image-20211015110932717.png" alt="image-20211015110932717"></p><p>卸载 umount -f 【挂载位置】</p><blockquote><p>进程管理</p><p><img src="/2021/10/13/Linux/image-20211015115117601.png" alt="image-20211015115117601"></p></blockquote><p> pstree -pu</p><p>树状显示进程</p><blockquote><p>发布项目</p></blockquote><p>把项目文件打包成jar文件上传到服务器</p><p>查看项目的端口号，必须确保Linux的防火墙端口是开启的</p><pre><code class="bash"># 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all    # 查看全部信息firewall-cmd --list-ports  # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp  #添加端口，格式为：端口/通讯协议--permanent   #永久生效，没有此参数重启后失效</code></pre><blockquote><p>tomcat</p></blockquote><pre><code class="bash"># 执行：startup.sh --&gt;启动tomcat# 执行：shutdown.sh --&gt;关闭tomcat./startup.sh./shutdown.sh</code></pre><h2><span id="三种软件安装方式">三种软件安装方式</span></h2><p>1.rpm安装</p><p>2.解压缩安装</p><p>3.yum安装</p><p>各种命令无法识别：</p><p>解决：</p><pre><code class="bash">export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot随记</title>
      <link href="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/"/>
      <url>/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><span id="spring-boot随记">Spring boot随记</span></h1><p><strong>约定大于配置</strong></p><h2><span id="yaml配置">yaml配置:</span></h2><p>实体类上加</p><pre><code class="java">@ConfigurationProperties(prefix = &quot;dog&quot;)</code></pre><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20210929201905228.png" alt="image-20210929201905228"></p><p>创建application.yaml文件</p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20210929201940747.png" alt="image-20210929201940747"></p><p>使用时：<img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20210929202014480.png" alt="image-20210929202014480"></p><h3><span id="松散绑定">松散绑定</span></h3><p>实体类中为<strong>fistname</strong>，yaml文件中为<strong>first-name</strong>也可以赋值</p><h3><span id="jsr303数据校验">JSR303数据校验</span></h3><p>@validated注解实体类</p><pre><code class="java">@Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式    private String name;</code></pre><p><strong>使用数据校验，可以保证数据的正确性；</strong></p><pre><code class="java">@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;空检查@Null       验证对象是否为null@NotNull    验证对象是否不为null, 无法查检长度为0的字符串@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty   检查约束元素是否为NULL或者是EMPTY.    Booelan检查@AssertTrue     验证 Boolean 对象是否为 true  @AssertFalse    验证 Boolean 对象是否为 false      长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min=, max=) string is between min and max included.日期检查@Past       验证 Date 和 Calendar 对象是否在当前时间之前  @Future     验证 Date 和 Calendar 对象是否在当前时间之后  @Pattern    验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则</code></pre><p>yaml文件优先级：<br>优先级1：项目路径下的config文件夹配置文件</p><p>优先级2：项目路径下配置文件</p><p>优先级3：资源路径下的config文件夹配置文件</p><p>优先级4：资源路径下配置文件</p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20210929204121922.png" alt="image-20210929204121922"></p><p>多环境开发：</p><pre><code class="yaml">server:  port: 8080#选择要激活那个环境块spring:  profiles:    active: prod---server:  port: 8081spring:  profiles: prod---server:  port: 8082spring:  profiles: dev</code></pre><h3><span id="自动配置原理">自动配置原理：</span></h3><p>例子：</p><pre><code class="java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能；  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；  //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //Spring底层@Conditional注解  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication(    type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；  //如果不存在，判断也是成立的  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty(    prefix = &quot;spring.http.encoding&quot;,    value = &#123;&quot;enabled&quot;&#125;,    matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123;    //他已经和SpringBoot的配置文件映射了    private final Encoding properties;    //只有一个有参构造器的情况下，参数的值就会从容器中拿    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;        this.properties = properties.getEncoding();    &#125;        //给容器中添加一个组件，这个组件的某些值需要从properties中获取    @Bean    @ConditionalOnMissingBean //判断容器没有这个组件？    public CharacterEncodingFilter characterEncodingFilter() &#123;        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();        filter.setEncoding(this.properties.getCharset().name());        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));        return filter;    &#125;    //。。。。。。。&#125;</code></pre><p><strong>根据当前不同的条件判断，决定这个配置类是否生效！</strong></p><p>大体结构：</p><pre><code class="Java">//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties &#123;    // .....&#125;</code></pre><h3><span id="mvc自动配置原理">mvc自动配置原理</span></h3><pre><code class="java">Spring MVC Auto-configuration// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.// 自动配置在Spring默认设置的基础上添加了以下功能：The auto-configuration adds the following features on top of Spring’s defaults:// 包含视图解析器Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.// 支持静态资源文件夹的路径，以及webjarsSupport for serving static resources, including support for WebJars // 自动注册了Converter：// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】Automatic registration of Converter, GenericConverter, and Formatter beans.// HttpMessageConverters// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；Support for HttpMessageConverters (covered later in this document).// 定义错误代码生成规则的Automatic registration of MessageCodesResolver (covered later in this document).// 首页定制Static index.html support.// 图标定制Custom Favicon support (covered later in this document).// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document)./*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.</code></pre><h3><span id="国际化">国际化</span></h3><p><strong>1.设置properties的编码问题</strong></p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211003204335787.png" alt="image-20211003204335787"></p><p><strong>2</strong>.<img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211003204447879.png" alt="image-20211003204447879"></p><p>​    <strong>建立语言配置文件：</strong></p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211003204931853.png" alt="image-20211003204931853"></p><p><strong>3.接下来就是让springboot识别我们对于国际化的个性配置，于是涉及到了spring boot的自动配置    MessageSourceProperties类</strong></p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211003205859135.png" alt="image-20211003205859135"></p><p><em>// 设置国际化文件的基础名（去掉语言国家代码的）</em></p><pre><code class="properties">spring.messages.basename=i18n.login</code></pre><p><strong>4.配置国际化解析</strong></p><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p><p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p><pre><code class="html">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;zh_CN&#39;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#39;en_US&#39;)&#125;&quot;&gt;English&lt;/a&gt;</code></pre><h4><span id="编写一个处理的组件类">编写一个处理的组件类</span></h4><pre><code class="java">package com.zz.springboot03web.config;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123;    @Override    public Locale resolveLocale(HttpServletRequest request) &#123;        String language=request.getParameter(&quot;l&quot;);        Locale locale=Locale.getDefault();//如果没有获取到就使用系统默认的        //如果需求链接不为空        if(!StringUtils.isEmpty(language))&#123;            //分割请求需求            String [] split=language.split(&quot;_&quot;);            locale=new Locale(split[0],split[1]);        &#125;        return locale;    &#125;    @Override    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;    &#125;&#125;</code></pre><p><strong>为了使自己定义的组件生效，在我们自己的MvcConofig下添加bean</strong></p><pre><code class="Java">@Beanpublic LocaleResolver localeResolver()&#123;    return new MyLocaleResolver();&#125;</code></pre><h2><span id="使用addviewcontroller实现无业务逻辑跳转">使用addviewController()实现无业务逻辑跳转</span></h2><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211004174440961.png" alt="image-20211004174440961"></p><p>效果：实际跳转到了test.html页面</p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211004174507934.png" alt="image-20211004174507934"></p><h2><span id="requestparam和pathvariable">@RequestParam和@PathVariable</span></h2><blockquote><p> 相同点与区别</p></blockquote><p> @RequestParam和@PathVariable都能够完成类似的功能——因为本质上，它们都是用户的输入，只不过输入的部分不同，一个在URL路径部分，另一个在参数部分。要访问一篇博客文章，这两种URL设计都是可以的：</p><ul><li>通过@PathVariable，例如/blogs/1</li><li>通过@RequestParam，例如blogs?blogId=1</li></ul><p>那么究竟应该选择哪一种呢？建议：</p><p>1、当URL指向的是某一具体业务资源（或资源列表），例如博客，用户时，使用@PathVariable</p><p>2、当URL需要对资源或者资源列表进行过滤，筛选时，用@RequestParam</p><p>例如我们会这样设计URL：</p><ul><li>/blogs/{blogId}</li><li>/blogs?state=publish而不是/blogs/state/publish来表示处于发布状态的博客文章</li></ul><h2><span id="安全shiro-springsecurity">安全（shiro  SpringSecurity）</span></h2><h3><span id="shiro">shiro</span></h3><h4><span id="结合数据库进行验证和授权">结合数据库进行验证和授权</span></h4><p>实际工作中，我们都会把权限相关的内容放在数据库中</p><p>基于 <a href="https://how2j.cn/k/shiro/shiro-database/1721.html#step7539">RBAC 概念</a>， 就会存在3 张基础表： 用户，角色，权限， 以及 2 张中间表来建立 用户与角色的多对多关系，角色与权限的多对多关系。 用户与权限之间也是多对多关系，但是是通过 角色间接建立的。</p><h5><span id="一">一</span></h5><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211009223652791.png" alt="image-20211009223652791"></p><h5><span id="二">二</span></h5><p><strong>插入模拟数据</strong></p><h5><span id="三">三</span></h5><p>Dao类</p><p><strong>提供了和权限相关查询</strong></p><h5><span id="四">四</span></h5><p>DatabaseRealm 就是用来通过数据库 验证用户，和相关授权的类。两个方法分别做验证和授权：<br>doGetAuthenticationInfo(), doGetAuthorizationInfo()</p><p>这个类由用户提供，但是不由用户自己调用，而是由 Shiro 去调用。从而在shiro.ini中配置</p><pre><code class="java">public class DatabaseRealm extends AuthorizingRealm&#123;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        //能进入到这里，表示账号已经通过验证了        String userName =(String)principals.getPrimaryPrincipal();        //通过DAO获取角色和权限        Set&lt;String&gt; permissions = new Dao().listPermissions(userName);        Set&lt;String&gt; roles = new Dao().listRoles(userName);        //授权对象        SimpleAuthorizationInfo s = new SimpleAuthorizationInfo();        //把通过DAO获取到的角色和权限放进去        s.setStringPermissions(permissions);        s.setRoles(roles);        return s;    &#125;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        //获取账号密码        UsernamePasswordToken t = (UsernamePasswordToken) token;        String userName= token.getPrincipal().toString();        String password= new String( t.getPassword());        //获取数据库中的密码        String passwordInDB = new Dao().getPassword(userName);        //如果为空就是账号不存在，如果不相同就是密码错误，但是都抛出AuthenticationException，而不是抛出具体错误原因，免得给破解者提供帮助信息        if(null==passwordInDB || !passwordInDB.equals(password))&#123;            throw new AuthenticationException();&#125;        //认证信息里存放账号密码, getName() 是当前Realm的继承方法,通常返回当前类名 :databaseRealm        SimpleAuthenticationInfo a = new SimpleAuthenticationInfo(userName,password,getName());        return a;    &#125;    &#125;</code></pre><h5><span id="五">五</span></h5><pre><code class="ini">[main]databaseRealm=DatabaseRealmsecurityManager.realms=$databaseRealm</code></pre><h5><span id="结束-̀-ω-́">结束( •̀ ω •́ )✧</span></h5><h4><span id="加密">加密</span></h4><h2><span id="swagger">swagger</span></h2><h3><span id="配置swagger">配置swagger</span></h3><p>（Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。）</p><p>  可以通过apiInfo()属性配置文档信息</p><pre><code class="java"> //配置文档信息    private ApiInfo apiInfo() &#123;        Contact contact = new Contact(&quot;gzz&quot;, &quot;https://www.zhihu.com/people/sjbja&quot;, &quot;https://weibo.com/u/7194380917?is_all=1&quot;);        return new ApiInfo(                &quot;Swagger学习&quot;, // 标题                &quot;学习演示如何配置Swagger&quot;, // 描述                &quot;v1.0&quot;, // 版本                &quot;https://user.qzone.qq.com/1614399965?source=namecardhoverqzone&quot;, // 组织链接                contact, // 联系人信息                &quot;Apach 2.0 许可&quot;, // 许可                &quot;许可链接&quot;, // 许可连接                new ArrayList&lt;&gt;()// 扩展        );    &#125;//Docket 实例关联上 apiInfo()@Beanpublic Docket docket() &#123;   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125;</code></pre><h3><span id="配置接口扫描信息">配置接口扫描信息</span></h3><pre><code class="java"> .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) .build();</code></pre><p>上面为根据包路径扫描接口</p><p><strong>其他配置扫描接口的方式：</strong></p><pre><code class="java">any() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</code></pre><p>还可以配置接口扫描过滤：</p><pre><code class="Java"> // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</code></pre><p>配置开关</p><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211010183122574.png" alt="image-20211010183122574"></p><p>效果图：<img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211010183203887.png" alt="image-20211010183203887"></p><h3><span id="动态配置当项目处于test-dev环境时显示swagger处于prod时不显示">动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示</span></h3><pre><code class="java">@Bean    public Docket docket(Environment environment)&#123;        // 设置要显示swagger的环境        Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);        // 判断当前是否处于该环境        // 通过 enable() 接收此参数判断是否要显示        boolean b = environment.acceptsProfiles(of);        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问                .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口                .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))                // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口                .paths(PathSelectors.ant(&quot;/kuang/**&quot;))                .build();    &#125;</code></pre><h3><span id="配置api分组">配置api分组</span></h3><h4><span id="给自己分配组">给自己分配组</span></h4><pre><code>.groupName(&quot;wtt&quot;)// 配置分组</code></pre><h4><span id="配置多个分组">配置多个分组</span></h4><pre><code class="java">@Bean    public Docket docket1()&#123;        return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);    &#125;    @Bean    public Docket docket2()&#123;        return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);    &#125;    @Bean    public Docket docket3()&#123;        return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);    &#125;</code></pre><h3><span id="实体配置">实体配置</span></h3><h4><span id="新建实体类">新建实体类</span></h4><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211010192744837.png" alt="image-20211010192744837"></p><h4><span id="在controller中配置接口">在controller中配置接口</span></h4><p><img src="/2021/09/26/Spring-boot%E9%9A%8F%E8%AE%B0/image-20211010192927354.png" alt="image-20211010192927354"></p><h2><span id="异步-定时-邮件任务">异步、定时、邮件任务</span></h2><h6><span id="异步前台发送邮件点击发送前台瞬间响应后台进行多线程处理">异步：前台发送邮件，点击发送前台瞬间响应，后台进行多线程处理</span></h6><p>实现异步方法：<br>在需实现异步的方法上加</p><pre><code class="java">//告诉Spring这是一个异步方法@Async</code></pre><p>在主程序上加</p><pre><code class="java">@EnableAsync //开启异步注解功能</code></pre><p>完成🎇🎇🎇</p><h6><span id="定时和发送邮件组合起来可实现定时邮件功能">定时和发送邮件：组合起来可实现定时邮件功能</span></h6><p>导入邮件依赖：</p><pre><code class="xml">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>定时有两个注解，实现形式和异步差不多：</p><pre><code class="java">  @Scheduled(cron = &quot;0 0/2 * * * ? &quot;)//此注解放在要实现定时任务的方法上  @EnableScheduling //开启基于注解的定时任务，放在主程序上</code></pre><p>邮件配置：</p><pre><code class="properties">spring.mail.username=1614399965@qq.com#授权码spring.mail.password=zuursxqcywrddfhfspring.mail.host=smtp.qq.com# qq需要配置sslspring.mail.properties.mail.smtp.ssl.enable=true</code></pre><p>发送一个两分钟一次的邮件：</p><pre><code class="java">@Scheduled(cron = &quot;0 0/2 * * * ? &quot;)public void sendEmailTo()&#123;    //邮件设置1：一个简单的邮件    SimpleMailMessage message = new SimpleMailMessage();    message.setSubject(&quot;Love tt&quot;);    message.setText(&quot;一生所爱&quot;);    message.setTo(&quot;1614399965@qq.com&quot;);    message.setFrom(&quot;1614399965@qq.com&quot;);    mailSender.send(message);&#125;</code></pre><p>常用的表达式</p><pre><code>（1）0/2 * * * * ?   表示每2秒 执行任务（1）0 0/2 * * * ?   表示每2分钟 执行任务（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时（6）0 0 12 ? * WED   表示每个星期三中午12点（7）0 0 12 * * ?   每天中午12点触发（8）0 15 10 ? * *   每天上午10:15触发（9）0 15 10 * * ?     每天上午10:15触发（10）0 15 10 * * ?   每天上午10:15触发（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发（18）0 15 10 15 * ?   每月15日上午10:15触发（19）0 15 10 L * ?   每月最后一日的上午10:15触发（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发</code></pre><p><code>@RequestParam</code> 和 <code>@PathVariable</code> 注解是用于从 request 中接收请求的，两个都可以接收参数，关键点不同的是<code>@RequestParam</code> 是从 request 里面拿取值，而 <code>@PathVariable</code> 是从一个URI模板里面来填充</p>]]></content>
      
      
      <categories>
          
          <category> Spring boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis入门</title>
      <link href="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/"/>
      <url>/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="mybatis入门笔记">mybatis入门笔记</span></h1><h2><span id="sql注入问题">sql注入问题</span></h2><p><a href="https://www.cnblogs.com/loveyoulx/p/9526068.html">mybatis 学习笔记：mybatis SQL注入问题 - 小_小星 - 博客园 (cnblogs.com)</a></p><h2><span id="第一个项目搭建流程">第一个项目搭建流程</span></h2><ol><li><p>搭建实验数据库</p></li><li><p>导入mybatis相关jar包</p><pre><code class="java">&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.4&lt;/version&gt;        &lt;/dependency&gt;</code></pre></li><li><p>编写mybatis核心配置文件</p><p><strong><!--千万注意配置mapper映射--></strong></p></li></ol><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;             &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;             &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=false&amp;amp;characterEncoding=utf8&quot;/&gt;             &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;             &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;        &lt;!--千万注意配置mapper映射--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/zz/Userdao/UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>4.编写mybatis工具类（目的：获取sqlsession）</p><pre><code class="java">package com.zz.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.Configuration;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import javax.annotation.Resource;import java.io.InputStream;public class MybatisUtil &#123;    private static SqlSessionFactory sqlSessionFactory;    static &#123;        try&#123;            String resource=&quot;mybatis-config.xml&quot;;            InputStream inputStream= Resources.getResourceAsStream(resource);            Configuration config;            sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    //获取sqlsesion连接    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;</code></pre><p>5.创建实体类</p><pre><code class="java">package com.zz.pojo;public class User &#123;    int id;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, pwd=&quot; + pwd +                &#39;&#125;&#39;;    &#125;    public User(int id, String name, int pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setPwd(int pwd) &#123;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public String getName() &#123;        return name;    &#125;    public int getPwd() &#123;        return pwd;    &#125;    String name;    int pwd;&#125;</code></pre><p>6.编写mapper.xml</p><p><strong>UserMapper</strong></p><pre><code class="java">package com.zz.UserMapper;import com.zz.pojo.User;import java.util.List;public interface UserMapper &#123;    List&lt;User&gt; selectAll();&#125;</code></pre><p><strong>UserMapper.xml</strong></p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.zz.UserMapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.zz.pojo.User&quot;&gt;        select * from mybatis.user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>7.测试</p><pre><code class="java">import com.zz.UserMapper.UserMapper;import com.zz.pojo.User;import com.zz.utils.MybatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class test &#123;    @Test    public void select()&#123;        SqlSession session= MybatisUtil.getSqlSession();        List&lt;User&gt; list=session.getMapper(UserMapper.class).selectAll();        for(User u:list)&#123;            System.out.println(u);        &#125;    &#125;&#125;</code></pre><p>8.结果</p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210921140953500.png" alt="image-20210921140953500"></p><p>增删改需要提交事务：sqlsession.commit()</p><h2><span id="万能map">万能Map</span></h2><p>假设实体类，或数据库中的表，字段或参数过多时，应当使用map</p><p>步骤：🎇🎇🎇🎇</p><p> 1.在接口中添加方法</p><pre><code class="java">public int updateUser(Map&lt;String, Object&gt; map);</code></pre><p>2.在mapper.xml中添加</p><pre><code class="java">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;        update mybatis.user set name=#&#123;uname&#125;, pwd=#&#123;pwds&#125; where id=#&#123;id&#125;&lt;/update&gt;</code></pre><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210921210742855.png" alt="image-20210921210742855"></p><p>用map作为参数的好处就是便利，箭头所指元素捷克在定义map时自己定义，而参数为User实体类时，这些参数皆需要和在定义实体类时一样</p><p>3.测试</p><pre><code class="java"> Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;();        map.put(&quot;id&quot;,1);        map.put(&quot;uname&quot;,&quot;sadsada&quot;);        map.put(&quot;pwds&quot;,4646464);        System.out.println(u.updateUser(map));</code></pre><p>成功！</p><h2><span id="模糊查询">模糊查询</span></h2><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210921212535801.png" alt="image-20210921212535801"></p><h2><span id="结果集映射">结果集映射</span></h2><p>场景：实体类中属性名与数据库表中字段不匹配 如：数据库中为pwd，实体类中为password</p><p>解决方法：</p><p>​    1.</p><pre><code class="java">&lt;select id=&quot;selectUser&quot; resultType=&quot;com.zz.pojo.User&quot;&gt;        select id,name,pwd as password from mybatis.user;    &lt;/select&gt;</code></pre><p>​    2.使用结果集映射(ResultMap)</p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210922173708063.png" alt="image-20210922173708063"></p><h2><span id="日志">日志</span></h2><h3><span id="log4j">Log4j</span></h3><p>  1.导包</p><pre><code class="java">&lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2.配置文件编写logj.properties</p><pre><code class="java">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/zz.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG</code></pre><p>3.setting设置日志实现<img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210922185902309.png" alt="image-20210922185902309"></p><p>4.实现</p><pre><code class="java">public class test &#123;    static Logger logger=Logger.getLogger(test.class);    @Test    public void select()&#123;        logger.info(&quot;info：进入selectUser方法&quot;);        logger.debug(&quot;debug：进入selectUser方法&quot;);        logger.error(&quot;error: 进入selectUser方法&quot;);        SqlSession session= MybatisUtil.getSqlSession();        List&lt;User&gt; list=session.getMapper(UserMapper.class).selectAll();        for(User u:list)&#123;            System.out.println(u);        &#125;        session.close();    &#125;&#125;</code></pre><h2><span id="分页">分页</span></h2><p>如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p><h3><span id="limit实现分页">limit实现分页</span></h3><pre><code class="java">#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  #如果只给定一个参数，它表示返回最大的记录行数目：   SELECT * FROM table LIMIT 5; //检索前 5 个记录行  #换句话说，LIMIT n 等价于 LIMIT 0,n。</code></pre><p><strong>步骤：</strong></p><p>1、修改Mapper文件</p><pre><code class="java">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;  select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;</code></pre><p>2、Mapper接口，参数为map</p><pre><code class="java">//选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);</code></pre><p>3、在测试类中传入参数测试</p><ul><li>推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li></ul><pre><code class="java">//分页查询 , 两个参数startIndex , pageSize@Testpublic void testSelectUser() &#123;   SqlSession session = MybatisUtils.getSession();   UserMapper mapper = session.getMapper(UserMapper.class);   int currentPage = 1;  //第几页   int pageSize = 2;  //每页显示几个   Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);   map.put(&quot;pageSize&quot;,pageSize);   List&lt;User&gt; users = mapper.selectUser(map);   for (User user: users)&#123;       System.out.println(user);  &#125;   session.close();&#125;</code></pre><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/Blog\source_posts\Mybatis入门\image-20210922195302374.png" alt="image-20210922195302374"></p><h2><span id="mybatis详细的执行流程">Mybatis详细的执行流程</span></h2><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/640" alt="图片"></p><h2><span id="使用注解开发">使用注解开发</span></h2><p>【注意点：增删改一定记得对事务的处理】</p><pre><code class="java"> //获取sqlsesion连接    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession(true);    &#125;//事务自动提交&#125;</code></pre><blockquote><p>#与$的区别</p></blockquote><ul><li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】可以防止sql注入</p><pre><code>INSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?);</code></pre></li><li><p>${} 的作用是直接进行字符串替换</p><pre><code>INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);</code></pre></li></ul><h2><span id="多对一处理">多对一处理</span></h2><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210923213727143.png" alt="image-20210923213727143"></p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210923213749558.png" alt="image-20210923213749558"></p><p>创建两张表：Student，Teacher</p><pre><code class="java">//获取所有学生及对应老师的信息    List&lt;Student&gt; getStudents();</code></pre><p>mapper.xml文件编写</p><p>按查询嵌套处理</p><pre><code class="sql">&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;        select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;com.zz.pojo.Student&quot;&gt;        &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;        &lt;association property=&quot;teacher&quot;  column=&quot;tid&quot; javaType=&quot;com.zz.pojo.Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;com.zz.pojo.Teacher&quot;&gt;        select * from teacher where id= #&#123;id&#125;&lt;/select&gt;</code></pre><p>按结果嵌套处理</p><pre><code class="sql"> &lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;        select s.id sid, s.name sname , t.name tname        from student s,teacher t        where s.tid = t.id    &lt;/select&gt;    &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;com.zz.pojo.Student&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;        &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;        &lt;association property=&quot;teacher&quot; javaType=&quot;com.zz.pojo.Teacher&quot;&gt;            &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><h2><span id="一对多处理">一对多处理</span></h2><p><strong>按结果嵌套处理</strong></p><p>Teacher</p><pre><code class="java">@Datapublic class Teacher &#123;    private int id;    private String name;    //一个老师多个学生    private List&lt;Student&gt; students;&#125;</code></pre><p>TeacherMapper.xml</p><pre><code class="sql">&lt;!--    思路:        1. 从学生表和老师表中查出学生id，学生姓名，老师姓名        2. 对查询出来的操作做结果集映射            1. 集合的话，使用collection！                JavaType和ofType都是用来指定对象类型的                JavaType是用来指定pojo中属性的类型                ofType指定的是映射到list集合属性中pojo的类型。    --&gt;    &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;        select s.id sid, s.name sname , t.name tname, t.id tid        from student s,teacher t        where s.tid = t.id and t.id=#&#123;id&#125;    &lt;/select&gt;    &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;        &lt;result  property=&quot;name&quot; column=&quot;tname&quot;/&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;            &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;            &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;            &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p><strong>按查询嵌套处理</strong></p><pre><code class="sql">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;        select * from teacher where id=#&#123;id&#125;    &lt;/select&gt;    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;    &lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;        &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;        select * from student where tid=#&#123;id&#125;    &lt;/select&gt;</code></pre><blockquote><p>小结</p></blockquote><p>1、关联-association</p><p>2、集合-collection</p><p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p><p>4、JavaType和ofType都是用来指定对象类型的</p><ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul><h2><span id="动态sql">动态SQL</span></h2><blockquote><p>if 语句</p></blockquote><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p><pre><code class="sql">&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;  select * from blog where   &lt;if test=&quot;title != null&quot;&gt;      title = #&#123;title&#125;   &lt;/if&gt;   &lt;if test=&quot;author != null&quot;&gt;      and author = #&#123;author&#125;   &lt;/if&gt;&lt;/select&gt;</code></pre><p>如果title为空的话，sql语句为错误语句，那就用到where</p><blockquote><p>Where</p></blockquote><p>修改上面的SQL语句；</p><pre><code class="sql">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;if test=&quot;title != null&quot;&gt;          title = #&#123;title&#125;       &lt;/if&gt;       &lt;if test=&quot;author != null&quot;&gt;          and author = #&#123;author&#125;       &lt;/if&gt;   &lt;/where&gt;&lt;/select&gt;</code></pre><p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><blockquote><p>Trim</p></blockquote><p>和where功能一样，还可以去除多余的逗号</p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20211011190142894.png" alt="image-20211011190142894"></p><p>如红框里的note为null，则sql语句错误</p><p>加了<trim>则会避免出错，会自动把role_name后面的逗号去掉，从而sql语句不会出错</trim></p><blockquote><p>Set</p></blockquote><p>1、编写接口方法</p><pre><code>int updateBlog(Map map);</code></pre><p>2、sql配置文件</p><pre><code class="sql">&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;  update blog     &lt;set&gt;         &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;,         &lt;/if&gt;         &lt;if test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;         &lt;/if&gt;     &lt;/set&gt;  where id = #&#123;id&#125;;&lt;/update&gt;</code></pre><blockquote><p>choose语句</p></blockquote><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题</p><p>1、编写接口方法</p><pre><code class="sql">List&lt;Blog&gt; queryBlogChoose(Map map);</code></pre><p>2、sql配置文件</p><pre><code class="sql">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;choose&gt;           &lt;when test=&quot;title != null&quot;&gt;                title = #&#123;title&#125;           &lt;/when&gt;           &lt;when test=&quot;author != null&quot;&gt;              and author = #&#123;author&#125;           &lt;/when&gt;           &lt;otherwise&gt;              and views = #&#123;views&#125;           &lt;/otherwise&gt;       &lt;/choose&gt;   &lt;/where&gt;&lt;/select&gt;</code></pre><p>3、测试类</p><pre><code class="sql">@Testpublic void testQueryBlogChoose()&#123;   SqlSession session = MybatisUtils.getSession();   BlogMapper mapper = session.getMapper(BlogMapper.class);   HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);   map.put(&quot;author&quot;,&quot;狂神说&quot;);   map.put(&quot;views&quot;,9999);   List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);   System.out.println(blogs);   session.close();&#125;</code></pre><p>如只查询阅览量为9999的书籍则改成<img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210924195725942.png" alt="image-20210924195725942"></p><blockquote><p>SQL片段</p></blockquote><p>可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，将这些代码抽取出来，然后使用时直接调用。</p><p><strong>提取SQL片段：</strong></p><pre><code class="sql">&lt;sql id=&quot;if-title-author&quot;&gt;   &lt;if test=&quot;title != null&quot;&gt;      title = #&#123;title&#125;   &lt;/if&gt;   &lt;if test=&quot;author != null&quot;&gt;      and author = #&#123;author&#125;   &lt;/if&gt;&lt;/sql&gt;</code></pre><p><strong>引用SQL片段：</strong></p><pre><code class="sql">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;       &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;   &lt;/where&gt;&lt;/select&gt;</code></pre><p>注意：</p><p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p><p>②、在 sql 片段中不要包括 where</p><h2><span id="缓存">缓存</span></h2><p>一级缓存：也叫本地缓存：</p><ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li></ul><p>例如：Sqlsession </p><p>体验：测试在一个session中查询两次相同记录，第二次直接从缓存访问，不去访问数据库</p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210924203651727.png" alt="image-20210924203651727"></p><p><img src="/2021/09/21/Mybatis%E5%85%A5%E9%97%A8/image-20210924203701534.png" alt="image-20210924203701534"></p><p>一级缓存失效的四种情况:</p><p>1、sqlSession不同</p><p>2、sqlSession相同，查询条件不同</p><p>3、sqlSession相同，两次查询之间执行了增删改操作！</p><p>4、sqlSession相同，手动清除一级缓存</p><pre><code class="java">session.clearCache();//手动清除缓存</code></pre><p><strong>一级缓存就是一个map</strong></p><blockquote><p>二级缓存</p></blockquote><ul><li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p></li><li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p></li><li><p>工作机制</p></li><li><ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li></ul></li></ul><p>简单地来说：二级缓存就是为了想从缓存中查询一级缓存中没有的东西（个人理解）</p><blockquote><p>使用步骤</p></blockquote><p>1、开启全局缓存 【mybatis-config.xml】</p><pre><code class="java">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></pre><p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p><pre><code class="java">&lt;cache/&gt;</code></pre><h2><span id="延迟加载">延迟加载</span></h2><p>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</p><p>答：</p><p>1）Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。 </p><p>2）它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理</p><p>总结：延迟加载就是<strong>按需加载</strong>，在需要查询的时候再去查询，使用延迟加载<strong>可以避免表连接查询</strong>，<strong>表连接查询比单表查询的效率低</strong>，<strong>但是它需要多次与数据库进行交互</strong>，所以延迟加载并不是万能的，使用需谨慎。</p><p>详细学习：<a href="https://blog.csdn.net/qq754772661/article/details/114931516">https://blog.csdn.net/qq754772661/article/details/114931516</a></p>]]></content>
      
      
      <categories>
          
          <category> About数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器与过滤器</title>
      <link href="/2021/09/18/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2021/09/18/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="拦截器与过滤器">拦截器与过滤器</span></h1><ul><li><p>过滤器还得配置静态资源过滤，拦截器只会拦截访问的控制器方法，如访问静态资源是不会拦截的</p></li><li><p>拦截器是AOP思想的具体运用，是springmvc框架自己的，使用了springmvc框架的工程才能使用b</p></li><li><p>继承拦截器不许重写，继承过滤器需要重写方法</p></li></ul><p>在web-INF下的所有页面只能通过controller或者servlet访问</p><h2><span id="实现拦截器">实现拦截器</span></h2><p>定义个性化拦截器</p><ol><li><p>实现拦截器接口</p><pre><code class="java">package com.zz.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoignIntercepter implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        HttpSession httpSession= request.getSession();        System.out.println(&quot;uri&quot;+request.getRequestURI());        //如跳转的是登录页面        if(request.getRequestURI().contains(&quot;login&quot;))&#123;            return true;        &#125;        if(httpSession.getAttribute(&quot;userlogininfo&quot;)!=null)&#123;            return true;        &#125;        //执行到这里说明用户没有登陆        // 用户没有登陆就跳转到登陆页面        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response);        return false;    &#125;&#125;</code></pre></li><li><p>在applicationcontext.xml里配置</p><pre><code class="java">&lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--包括这个请求下所有的请求--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;bean class=&quot;com.zz.config.MyInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;bean class=&quot;com.zz.config.LoignIntercepter&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拦截器与过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax总结</title>
      <link href="/2021/09/18/ajax%E6%80%BB%E7%BB%93/"/>
      <url>/2021/09/18/ajax%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="ajax">Ajax</span></h1><p>现在对Ajax的理解就是简简单单地优化用户体验</p><p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p><p>jQuery 提供多个与 AJAX 有关的方法。</p><p><strong>实现异步验证用户名</strong></p><p>新建一个maven项目，增加web支持，<strong>配置好tomcat服务器</strong>（就配置这破玩意二花了我两天！！！！！！！如有问题：首先新建一个项目，不要再原项目下新建一个modle；接下来就是配置好tomcat的deployment）</p><p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918194117558.png" alt="image-20210918194117558"></p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918194214940.png" alt="image-20210918194214940" style="zoom: 50%;"><p>如没有Artifact，点击加号把现项目以war包形式发布，点击🆗即可。</p><p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918194435095.png" alt="image-20210918194435095"></p><p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918194456928.png" alt="image-20210918194456928"></p><p>如项目部署成功访问controller显示500，原因可能是spring版本和tomcat版本不匹配，我的之前有问题的就是因为用的是tomcat6，换成tomcat9就好了。还有还有：：：：<strong>记得在project structure里面的artifacts项里配置lib目录</strong>。</p><h2><span id="言归正传">言归正传</span></h2><p>开始实现功能了🧨🧨🧨🎠🎠🎠🎊🎊🎊</p><p>实现效果简单的来说就是输入账号名和密码，当鼠标离开输入框也就是失去焦点，页面会自动显示正确或错误/<img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918195233626.png" alt="image-20210918195233626"></p><p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918195314836.png" alt="image-20210918195314836"></p><p>首先编写controller层（UserController）</p><ul><li>记得控制类前要加@Restcontroller注解，就会以json形式返回前台数据</li></ul><pre><code class="java">package com.zz.controller;import com.zz.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.web.HttpMediaTypeException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.security.auth.login.CredentialException;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;@RestControllerpublic class AjaxController &#123;       @RequestMapping(&quot;/a3&quot;)    public String ajax3(String name,String pwd)&#123;        String msg = &quot;&quot;;        //模拟数据库中存在数据        if (name!=null)&#123;            if (&quot;admin&quot;.equals(name))&#123;                msg = &quot;OK&quot;;            &#125;else &#123;                msg = &quot;用户名输入错误&quot;;            &#125;        &#125;        if (pwd!=null)&#123;            if (&quot;123456&quot;.equals(pwd))&#123;                msg = &quot;OK&quot;;            &#125;else &#123;                msg = &quot;密码输入有误&quot;;            &#125;        &#125;        return msg; //由于@RestController注解，将msg转成json格式返回    &#125;&#125;</code></pre><p>然后从网上下载jquery，放在项目的web包中，然后编写login.jsp页面</p><pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;ajax&lt;/title&gt;  &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    function a1()&#123;      $.post(&#123;        url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,        data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;,        success:function (data) &#123;          if (data.toString()==&#39;OK&#39;)&#123;            $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);          &#125;else &#123;            $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);          &#125;          $(&quot;#userInfo&quot;).html(data);        &#125;      &#125;);    &#125;    function a2()&#123;      $.post(&#123;        url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,        data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;,        success:function (data) &#123;          if (data.toString()==&#39;OK&#39;)&#123;            $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);          &#125;else &#123;            $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);          &#125;          $(&quot;#pwdInfo&quot;).html(data);        &#125;      &#125;);    &#125;  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;  用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;  &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;  &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>到现在启动服务器就可以看到啦，成功后在浏览器查看时每失去焦点时都会向后台发送请求，也是<strong>Ajax的独特之处，把主动权交给了前端。</strong></p><p>放一下项目结构图吧</p><p><img src="/2021/09/18/ajax%E6%80%BB%E7%BB%93/image-20210918200158409.png" alt="image-20210918200158409"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful详解</title>
      <link href="/2021/09/15/Restful%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/09/15/Restful%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2><span id="资源与uri">资源与URI</span></h2><p>REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。</p><p>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。</p><h3><span id="uri的设计技巧">URI的设计技巧</span></h3><ul><li>使用_或-来让URI可读性更好  <strong>例子</strong>：<a href="http://www.oschina.net/news/38119/oschina-translate-reward-plan">http://www.oschina.net/news/38119/oschina-translate-reward-plan</a></li><li>使用/来表示资源的层级关系  <strong>例子</strong>：/orders/2012/10可以用来表示2012年10月的订单记录。</li><li>使用?用来过滤资源  <strong>例子</strong>：很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。</li><li>,或;可以用来表示同级资源的关系 <strong>例子</strong>：例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以用；连接两个文件。</li></ul><h2><span id="统一资源接口">统一资源接口</span></h2><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p><p>如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。</p><h3><span id="资源的表述">资源的表述</span></h3><p>上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。</p><p>那么客户端如何知道服务端提供哪种表述形式呢?</p><p>答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p><p>以github为例，请求某组织资源的json格式的表述形式:</p><p><img src="/2021/09/15/Restful%E8%AF%A6%E8%A7%A3/291731048886033.jpg" alt="291731048886033"></p><p>假如github也能够支持xml格式的表述格式，那么结果就是这样的:</p><p><img src="/2021/09/15/Restful%E8%AF%A6%E8%A7%A3/291731045756062.jpg" alt="291731045756062"></p><h2><span id="springmvc实现restful服务">SpringMVC实现restful服务:</span></h2><p>SpringMVC原生态的支持了REST风格的架构设计</p><p>所涉及到的注解:</p><p>---@RequestMapping<br> ---@PathVariable<br> ---@ResponseBody</p><pre><code class="java">package cn.itcast.mybatis.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import cn.itcast.mybatis.pojo.User;import cn.itcast.mybatis.service.NewUserService;@RequestMapping(&quot;restful/user&quot;)@Controllerpublic class RestUserController &#123;@Autowiredprivate NewUserService newUserService;/** * 根据用户id查询用户数据 *  * @param id * @return */@RequestMapping(value = &quot;&#123;id&#125;&quot;, method = RequestMethod.GET)@ResponseBodypublic ResponseEntity&lt;User&gt; queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;    try &#123;        User user = this.newUserService.queryUserById(id);        if (null == user) &#123;            // 资源不存在，响应404            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);        &#125;        // 200        // return ResponseEntity.status(HttpStatus.OK).body(user);        return ResponseEntity.ok(user);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    // 500    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);&#125;/** * 新增用户 *  * @param user * @return */@RequestMapping(method = RequestMethod.POST)public ResponseEntity&lt;Void&gt; saveUser(User user) &#123;    try &#123;        this.newUserService.saveUser(user);        return ResponseEntity.status(HttpStatus.CREATED).build();    &#125; catch (Exception e) &#123;        // TODO Auto-generated catch block        e.printStackTrace();    &#125;    // 500    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);&#125;/** * 更新用户资源 *  * @param user * @return */@RequestMapping(method = RequestMethod.PUT)public ResponseEntity&lt;Void&gt; updateUser(User user) &#123;    try &#123;        this.newUserService.updateUser(user);        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    // 500    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);&#125;/** * 删除用户资源 *  * @param user * @return */@RequestMapping(method = RequestMethod.DELETE)public ResponseEntity&lt;Void&gt; deleteUser(@RequestParam(value = &quot;id&quot;, defaultValue = &quot;0&quot;) Long id) &#123;    try &#123;        if (id.intValue() == 0) &#123;            // 请求参数有误            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();        &#125;        this.newUserService.deleteUserById(id);        // 204        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    // 500    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);&#125;&#125;</code></pre><p>出自：<a href="https://www.jianshu.com/p/7893169a7c93">RESTful接口详解 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java四种线程池</title>
      <link href="/2021/09/13/java%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2021/09/13/java%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2><span id="普通创建线程new-thead弊端">普通创建线程(new Thead)弊端</span></h2><pre><code class="Java">new Thread(new Runnable() &#123; @Overridepublic void run() &#123;// TODO Auto-generated method stub&#125;&#125;).start();</code></pre><p>new Thread弊端如下：</p><p>Java提供的四种线程池好处如下：</p><table><thead><tr><th align="center">Java四种线程</th><th align="center">new Thread</th></tr></thead><tbody><tr><td align="center">重复利用存在的线程，减少对象创建，消亡的开销，性能佳</td><td align="center">每次new Thread新建对象性能差</td></tr><tr><td align="center">可有效控制最大并发线程数，提高系统资源的使用率</td><td align="center">线程缺乏统一管理，可能无限制创建新线程，相互之间争夺资源，导致死机</td></tr><tr><td align="center">提供定时执行、定期执行、单线程、并发数控制等功能。</td><td align="center">缺乏更多功能如：定时执行，定期执行，线程中断</td></tr></tbody></table><h2><span id="java线程池">Java线程池</span></h2><p>Java通过Executors提供四种线程池，分别为：</p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> newCachedThreadPool,newFixedThreadPool,newScheduledThreadPool,newSingleThreadExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子操作类</title>
      <link href="/2021/09/10/post%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"/>
      <url>/2021/09/10/post%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1><span id="原子操作类atomicinteger">原子操作类AtomicInteger</span></h1><p>在使用Java爬取网站图片时，遇到多线程下载图片，需显示下载到第几张图片问题，于是使用了原子操作类AtomicInteger，可以保证操作具有原子性</p><h2><span id="例一">例一</span></h2><p>创建两个线程，分别将全局变量i进行加1</p><p>每个线程执行5000次（次数少了正确率比较高🤣，5000都是重复执行好几次之后才出现不理想结果）</p><pre><code class="java">public class D &#123;    private static int m = 0;    public static void main(String[] args) throws InterruptedException &#123;//        CountDownLatch cdl = new CountDownLatch(2);        Thread t1 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                for (int j = 0; j &lt; 5000; j++) &#123;                    m++;                    System.out.println(&quot;1:&quot;+m);                &#125;                //cdl.countDown();            &#125;        &#125;);        Thread t2 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                for (int j = 0; j &lt; 5000; j++) &#123;                    m++;                    System.out.println(&quot;2:&quot;+m);                &#125;                //cdl.countDown();            &#125;        &#125;);        t1.start();        t2.start();        //cdl.await();        System.out.println(&quot;result=&quot; + m);    &#125;&#125;</code></pre><p><img src="/2021/09/10/post%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/image-20210910184257578.png" alt="image-20210910184257578"></p><p>由此可以看出m变量没有加锁(synchronized)，。但是synchronized过于沉重。于是我们可以考虑使用原子操作类<strong>AtomicInteger</strong>来实现。</p><h2><span id="例二">例二</span></h2><p>使用<strong>AtomicInteger</strong> 中的<strong>incrementAndGet</strong> 函数来进行自增操作，代替直接使用**i++**来进行自增，保证了操作的原子性。</p><pre><code class="java">import java.util.concurrent.atomic.AtomicInteger;public class D &#123;    private static int m = 0;    public static void main(String[] args) throws InterruptedException &#123;//        CountDownLatch cdl = new CountDownLatch(2);          AtomicInteger i=new AtomicInteger(0);        Thread t1 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                for (int j = 0; j &lt; 5000; j++) &#123;                    i.incrementAndGet();                    System.out.println(&quot;1:&quot;+i);                &#125;                //cdl.countDown();            &#125;        &#125;);        Thread t2 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                for (int j = 0; j &lt; 5000; j++) &#123;                    i.incrementAndGet();                    System.out.println(&quot;2:&quot;+i);                &#125;                //cdl.countDown();            &#125;        &#125;);        t1.start();        t2.start();        //cdl.await();            &#125;&#125;</code></pre><p><img src="/2021/09/10/post%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/image-20210910184723295.png" alt="image-20210910184723295"></p><p>现在无论执行多少次，结果永远是10000</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java原子操作类AtomicInteger应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WithWut</title>
      <link href="/2021/09/08/post-WithWut/"/>
      <url>/2021/09/08/post-WithWut/</url>
      
        <content type="html"><![CDATA[<h1><span id="png">png</span></h1><p>宝贝亲自挑选的哦：🎎🎏</p><p><img src="/2021/09/08/post-WithWut/QQ%E5%9B%BE%E7%89%8720210908223629.jpg" alt="QQ图片20210908223629"></p>]]></content>
      
      
      <categories>
          
          <category> 生活园地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> record sweetheart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式Study-2</title>
      <link href="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/"/>
      <url>/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/</url>
      
        <content type="html"><![CDATA[<h1><span id="strategy-pattern"><em><a href="javascript:;">strategy</a> <a href="javascript:;">pattern</a></em></span></h1><h1><span id="策略模式">策略模式</span></h1><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101215229119.png" alt="image-20211101215229119"></p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20210902154825052.png" alt="image-20210902154825052"></p><pre><code class="java">/** * 定义所有支持算法的接口 */abstract class Strategy &#123;    /**     * 算法方法     */    public abstract void algorithmInterface();&#125;</code></pre><pre><code class="java">/** * 封装具体的算法和行为，继承于Strategy */public class ConcreteStrategyA extends Strategy &#123;    @Override     public  void algorithmInterface()&#123;         System.out.println(&quot;执行算法A&quot;);     &#125;&#125;public class ConcreteStrategyB extends Strategy&#123;    @Override    public  void algorithmInterface()&#123;        System.out.println(&quot;执行算法B&quot;);    &#125;&#125;public class ConcreteStrategyC extends Strategy &#123;    @Override    public  void algorithmInterface()&#123;        System.out.println(&quot;执行算法C&quot;);    &#125;&#125;</code></pre><pre><code class="java">/** * @author zz * 上下文，维持一个strategy对象的引用 */public class Context &#123;    Strategy strategy;    /**     * 初始化时，传入具体的策略对象     * @param strategy 具体的策略对象     */    public Context(Strategy strategy)&#123;        this.strategy=strategy;    &#125;    /**     * 根据具体的策略对象，调用其算法     */    public void contextInterface()&#123;        this.strategy.algorithmInterface();    &#125;&#125;</code></pre><p><strong>客户端</strong></p><pre><code class="java">/** * 由于实例化不同的策略，所以最终调用context.contextInterface()时， * @author zz */public class Client &#123;    public static void main(String[] args) &#123;        Context context;        context=new Context(new ConcreteStrategyA());        context.contextInterface();        context=new Context(new ConcreteStrategyB());        context.contextInterface();        context=new Context(new ConcreteStrategyC());        context.contextInterface();    &#125;&#125;</code></pre><hr><h2><span id="实现">实现</span></h2><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20210915112133772.png" alt="image-20210915112133772"></p><h3><span id="第一版">第一版</span></h3><p>支持所有收费策略的接口：</p><pre><code class="java">public class CashContext &#123;    //声明一个CashSuper对象    private CashSuper cs;    public CashContext(CashSuper cashSuper)&#123;        this.cs=cashSuper;    &#125;    public Double GetResult(Double money)&#123;        return cs.acceptCash(money);    &#125;&#125;</code></pre><p>收费策略</p><pre><code class="java">/** * 正常收费子类 */public class CashNormal extends CashSuper&#123;    @Override    Double acceptCash(Double money) &#123;        return money;    &#125;&#125;/** * 打折收费子类 */public class CashRebate extends CashSuper &#123;    private Double moneyRebate;//打折率    public CashRebate(String moneyRebate) &#123;        this.moneyRebate = Double.parseDouble(moneyRebate);    &#125;    @Override    Double acceptCash(Double money) &#123;        return moneyRebate * money;    &#125;&#125;/** * 返利收费子类 */public class CashReturn extends CashSuper&#123;    public CashReturn(double monryCondition, double moneyValue) &#123;        this.moneyCondition = monryCondition;        this.moneyValue = moneyValue;    &#125;    //返利条件    private double moneyCondition;    //返利值    private double moneyValue;    @Override    Double acceptCash(Double money) &#123;        if (money&gt;=moneyCondition)&#123;            return (money-moneyValue);        &#125;else &#123;            return money;        &#125;    &#125;&#125;</code></pre><p>工厂类</p><pre><code class="Java">/** * 现金收费工厂类 */public class CashFactory &#123;    public static CashSuper createCash(String type)&#123;        CashSuper cs=null;        switch (type)&#123;            case &quot;正常收费&quot;:                cs=new CashNormal();                break;            case &quot;打八折&quot;:                cs=new CashRebate(&quot;0.8&quot;);                break;            case &quot;返利&quot;:                cs=new CashReturn(300,100);                break;        &#125;        return cs;    &#125;&#125;</code></pre><p>现金收费抽象类</p><pre><code class="Java">/** * 现金收费抽象类 */abstract class CashSuper &#123;    abstract Double acceptCash(Double money);&#125;</code></pre><p>客户端</p><pre><code class="java">package a.impl;import java.util.Scanner;public class Client &#123;    public static void main(String[] args) &#123;        CashContext cc;        Scanner sc=new Scanner(System.in);        System.out.println(&quot;请输入单价和数量：&quot;);        System.out.println(&quot;单价:&quot;);        int text=sc.nextInt();        System.out.println(&quot;数量:&quot;);        int num=sc.nextInt();        System.out.println(&quot;请选择收费策略&quot;);        String select=sc.next();        switch (select)&#123;            case &quot;正常收费&quot;:                cc=new CashContext(new CashNormal());                break;            case &quot;满300返100&quot;:                cc=new CashContext(new CashReturn(300,100));                break;            case &quot;打八折&quot;:                cc=new CashContext(new CashRebate(&quot;0.8&quot;));                break;            default:                throw new IllegalStateException(&quot;Unexpected value: &quot; + select);        &#125;        double totalPrices;        totalPrices=cc.GetResult(Double.parseDouble(String.valueOf(text*num)));        System.out.println(&quot;结果为：&quot;+totalPrices);    &#125;&#125;</code></pre><p>只是简单地实现了策略模式，选择算法还在客户端，应移走</p><h3><span id="第二版">第二版</span></h3><p>策略与简单工厂结合</p><p>CashContext</p><pre><code class="java">package a.impl;public class CashContext &#123;    //声明一个CashSuper对象    private CashSuper cs;    public CashContext(String type)&#123;        switch (type)&#123;            case &quot;正常收费&quot;:                cs=new CashNormal();                break;            case &quot;打八折&quot;:                cs=new CashRebate(&quot;0.8&quot;);                break;            case &quot;返利&quot;:                cs=new CashReturn(300,100);                break;        &#125;    &#125;    public Double GetResult(Double money)&#123;        return cs.acceptCash(money);    &#125;&#125;</code></pre><p>客户端</p><pre><code class="java">package a.impl;import java.util.Scanner;public class Client &#123;    public static void main(String[] args) &#123;        Scanner sc=new Scanner(System.in);        System.out.println(&quot;请输入单价和数量：&quot;);        System.out.println(&quot;单价:&quot;);        int text=sc.nextInt();        System.out.println(&quot;数量:&quot;);        int num=sc.nextInt();        System.out.println(&quot;请选择收费策略&quot;);        String select=sc.next();       CashContext cashContext=new CashContext(select);        double totalPrices;        totalPrices=cashContext.GetResult(Double.parseDouble(String.valueOf(text*num)));        System.out.println(&quot;结果为：&quot;+totalPrices);    &#125;</code></pre><p>观察简单工厂和策略模式与简单工厂模式相结合地情况下：简单工厂向用户暴露了两个类：CashSuper和CashFactory，而策略模式与简单工厂结合地用法，客户端就只需要认识一个类CashContext就可以，耦合性更低。</p><h3><span id="总结">总结</span></h3><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20210919200622568.png" alt="image-20210919200622568"></p><p>源码分析：<br><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101220338094.png" alt="image-20211101220338094"></p><p><strong>注意：</strong></p><p>多用组合或聚合，而不是继承</p><p>每添加一个策略就要增加一个类，当策略增多会导致类过多</p><h1><span id="命令模式">命令模式</span></h1><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030173749872.png" alt="image-20211030173749872"></p><ul><li><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030175139500.png" alt="image-20211030175139500"></li><li>StatementCallback 接口 ,类似命令接口(Command) -<br>class QueryStatementCallback implements StatementCallback<t>, SqlProvider , 匿名内 部类，实现了命令接口，同时也充当命令接收者</t></li><li>命令调用者是 JdbcTemplate , 其中execute(StatementCallback<t> action) 方法中，调 用action.doInStatement 方法. 不同的实现 StatementCallback 接口的对象，对应不同 的doInStatemnt 实现逻辑</t></li><li>另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback</li></ul><p><strong>注意：</strong></p><p>调用者发起请求，不需知道具体接收者对象是谁，命令对象起到了纽带桥梁的作用，起到了解耦的作用</p><p>容易设计一个命令队列，把命令对象放到队列里，就可以执行多线程的命令</p><p>不足：增加系统复杂度</p><h1><span id="访问者模式">访问者模式</span></h1><p><strong>访问者模式（Visitor Pattern）</strong>，封装一些作用于某种数据结构的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p><p>主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题 </p><p>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口，在源码中即为在man和women中提供一个accept接口</p><p>其中重要的概念：<strong>双分派</strong></p><p>双分派是指不管类怎么变化，我们都能找到期望的方法运行。 双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型</p><p>优缺点：</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030184755658.png" alt="image-20211030184755658"></p><h1><span id="迭代器模式">迭代器模式</span></h1><p>属于行为型模式，如果集合元素实现方式不同：有数组有集合，当客户端遍历这些元素时，需要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用<strong>迭代器模式</strong>解决。</p><p>会提供一个遍历集合元素的统一接口，用一致的方法遍历集合元素，不暴露内部结构</p><p>注意：</p><ol><li><p>提供了一个设计思想，就是一个类应该只有一个引起变化的原因（单一责任原则）。在此例中，我们把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象，如果遍历方式改变，只影响迭代器</p></li><li><p>每个聚合对象都需要自定义一个迭代器，不好管理。</p></li><li><p>源码分析</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030194842610.png" alt="image-20211030194842610"></p></li></ol><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030194815008.png" alt="image-20211030194815008"></p><h1><span id="观察者模式">观察者模式</span></h1><p>会以集合的形式来管理用户，可以注册，移除和更新</p><p>源码分析：</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030204459067.png" alt="image-20211030204459067"></p><p>Observable相当于观察者管理类</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211030204659806.png" alt="image-20211030204659806"></p><p>可以看出以上皆具有本角色的操作</p><h1><span id="中介者模式">中介者模式</span></h1><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101145044841.png" alt="image-20211101145044841"></p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101145135630.png" alt="image-20211101145135630"></p><h1><span id="备忘录模式">备忘录模式</span></h1><p>不破坏封装性的前提下。捕获一个对象的内部状态，并在备忘录管理类里保存，属于行为型模式</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101151124350.png" alt="image-20211101151124350"></p><p><strong>注意事项：</strong></p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101151352027.png" alt="image-20211101151352027"></p><h1><span id="解释器模式">解释器模式</span></h1><p>指定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101204142883.png" alt="image-20211101204142883"></p><h1><span id="状态模式">状态模式</span></h1><p>解决对象转换多种状态，并对外输出不同行为的问题，状态之间可以相互转化</p><p>实际项目：借贷平台</p><p>注意：</p><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211101212642704.png" alt="image-20211101212642704"></p><h1><span id="职责链模式">职责链模式</span></h1><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211102160326945.png" alt="image-20211102160326945"></p><p>源码分析：</p><pre><code class="Java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;         *   HandlerExecutionChain mappedHandler = null;          *   mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象         *    //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor         *    //调用了拦截器的  interceptor.preHandle         *   if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;                    return;                &#125;              //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用               //拦截器的  interceptor.postHandle(request, response, this.handler, mv);             mappedHandler.applyPostHandle(processedRequest, response, mv);         *  &#125;         *           *           *  说明：在  mappedHandler.applyPreHandle内部中，         *  还调用了  triggerAfterCompletion 方法，该方法中调用了           *  HandlerInterceptor interceptor = getInterceptors()[i];            try &#123;                interceptor.afterCompletion(request, response, this.handler, ex);            &#125;            catch (Throwable ex2) &#123;                logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);            &#125;</code></pre><p><img src="/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-2/image-20211102160747217.png" alt="image-20211102160747217"></p><p><strong>注意</strong></p><p>实现了解耦，简化了对象，使对象不需知道链的结构</p><p>但是性能会受到影响，因此需控制链中的最大节点个数。</p><p>最佳应用场景：如多级请求，审批流程。Javaweb中tomcat对Encoding的处理，拦截器。</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> 设计模式 </category>
          
          <category> 策略模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式Study-1</title>
      <link href="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/"/>
      <url>/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/</url>
      
        <content type="html"><![CDATA[<h1><span id="工厂设计模式">工厂设计模式</span></h1><p>✨✨✨源码示例：<a href="https://gitee.com/guozhuangzhuang1/design-pattern%F0%9F%A5%8B%F0%9F%A5%8B%F0%9F%A5%8B">https://gitee.com/guozhuangzhuang1/design-pattern🥋🥋🥋</a></p><h2><span id="简单工厂模式">简单工厂模式</span></h2><p><strong>UML类图</strong></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20210901101148383.png" alt="image-20210901101148383"></p><h4><span id="案例计算器">案例：计算器</span></h4><p>实现一个计算器功能：输入两个数和运算符号输出结果</p><h4><span id="第一版">第一版</span></h4><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20210901103229566.png" alt="image-20210901103229566"></p><p><strong>问题：</strong></p><p>命名不规范，浪费资源时间，没考虑意外情况</p><h4><span id="第二版">第二版</span></h4><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20210901103547596.png" alt="image-20210901103547596"></p><p><strong>问题：</strong></p><p>没有面向对象</p><h4><span id="第三版">第三版</span></h4><p>运算类</p><pre><code class="java">public class Operation extends Exception&#123;    public static double getresult(double numberA,double numberB,String operation)throws Exception    &#123;        double result=0d;        switch (operation)&#123;            case &quot;+&quot;:                result=numberA+numberB;                break;            case &quot;-&quot;:                result=numberA-numberB;                break;            case &quot;*&quot;:                result=numberA*numberB;                break;            case &quot;/&quot;:                if(numberB==0)&#123;                    throw new Exception(&quot;除数不可为0&quot;);                &#125;                result=numberA/numberB;                break;        &#125;        return result;    &#125;&#125;</code></pre><p><strong>客户端</strong></p><pre><code class="java">import java.util.Date;import java.util.Scanner;public class Client &#123;    public static void main(String[] args) &#123;        try&#123;            Scanner sc=new Scanner(System.in);            System.out.println(&quot;请输入数字A:&quot;);            Double strNumberA= sc.nextDouble();            System.out.println(&quot;请输入运算符号:&quot;);            String strOpreation = sc.next();            System.out.println(&quot;请输入数字B:&quot;);            Double strNumberB= sc.nextDouble();            System.out.println(&quot;结果是：&quot;+Operation.getresult(strNumberA,strNumberB,strOpreation));        &#125;catch (Exception e)&#123;            System.out.println(&quot;您的输入有误:&quot;+e.getMessage());        &#125;    &#125;&#125;</code></pre><p><strong>结果：</strong></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20210901105747617.png" alt="image-20210901105747617"></p><p>问题：面向对象三大特性只使用了一个，继承和多态没有使用</p><h4><span id="最终版">最终版</span></h4><p><strong>简单工厂模式</strong></p><p><strong>operation运算类</strong></p><pre><code class="java">public class Operation1 &#123;    public double _numberA=0;    public double _numberB=0;        public double getResult()throws Exception&#123;        double result=0;        return result;    &#125;&#125;</code></pre><p><strong>加减乘除子类</strong></p><pre><code class="java">public class OperationAdd extends Operation1&#123;    @Override    public double getResult()&#123;            double result=this._numberA+this._numberB;            return result;    &#125;&#125;public class OperationSub extends Operation1&#123;    @Override    public double getResult() throws Exception&#123;        double result=this._numberA-this._numberB;        return result;    &#125;&#125;public class OperationMul extends Operation1&#123;    @Override    public double getResult() throws Exception&#123;        double result=this._numberA*this._numberB;        return result;    &#125;&#125;public class OperationDiv extends Operation1&#123;    @Override    public double getResult() throws Exception &#123;        if (this._numberB==0)&#123;            throw new Exception(&quot;除数不能为0&quot;);        &#125;        double result=this._numberA/this._numberB;        return result;    &#125;&#125;</code></pre><p><strong>运算工厂类</strong></p><pre><code class="java">public class OperationFacotry &#123;    public static Operation1 createOperation(String operation)&#123;        Operation1 op=null;        switch (operation)&#123;            case &quot;+&quot;:                op=new OperationAdd();                break;            case &quot;-&quot;:                op=new OperationSub();                break;            case &quot;*&quot;:                op=new OperationMul();                break;            case &quot;/&quot;:                op=new OperationDiv();                break;        &#125;        return op;    &#125;&#125;</code></pre><p><strong>客户端</strong></p><pre><code class="java">public class ma1 &#123;    public static void main(String[] args) &#123;        try&#123;          Operation1 oper;          Scanner sc=new Scanner(System.in);          System.out.println(&quot;请输入运算符号:&quot;);          String strOpreation = sc.next();          oper=OperationFacotry.createOperation(strOpreation);          System.out.println(&quot;请输入数字A:&quot;);          Double strNumberA= sc.nextDouble();          oper._numberA=strNumberA;          System.out.println(&quot;请输入数字B:&quot;);          Double strNumberB= sc.nextDouble();          oper._numberB=strNumberB;          double result=oper.getResult();          System.out.println(&quot;结果为:&quot;+result);        &#125;catch (Exception e)&#123;            System.out.println(&quot;您的输入有误:&quot;+e.getMessage());        &#125;    &#125;&#125;</code></pre><p>这样的话只需输入运算符号，工厂就实例化出合适的对象，通过多态返回父类实现了计算器的结果。</p><h2><span id="工厂方法模式">工厂方法模式</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024194707957.png" alt="image-20211024194707957"></p><h2><span id="抽象工厂模式">抽象工厂模式</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/Blog\source_posts\设计模式Study-1\image-20211024200947475.png" alt="image-20211024200947475"></p><p>源码示例：<br><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024201731740.png"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024201809444.png" alt="image-20211024201809444"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024201839309.png" alt="image-20211024201839309"></p><p>工厂模式小结：<br><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024202149598.png" alt="image-20211024202149598"></p><h1><span id="单例模式"><strong>单例模式</strong></span></h1><p>某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）</p><p>源码实例: Hibernate的SessionFactory，充当数据存储源的代理，并负责创建Session对象，由于sessionFactory是一个重量级对象，通常情况下一个项目只需要一个，这就是单例模式。</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211023204614428.png" alt="image-20211023204614428"></p><h2><span id="饿汉式">饿汉式：</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211023204851504.png" alt="image-20211023204851504"></p><h2><span id="懒汉式线程不安全">懒汉式（线程不安全）</span></h2><p>在调用getInstance方法时才会创建单例对象，起到了懒加载效果，只不过线程不安全</p><h2><span id="懒汉式线程安全同步方法">懒汉式（线程安全，同步方法）</span></h2><p>保证了线程安全，但是效率太低，每一次调用都要实例化对象</p><pre><code class="java">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题//即懒汉式    public static synchronized Singleton getInstance() &#123;        if(instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;</code></pre><h2><span id="懒汉式线程安全同步代码块">懒汉式（线程安全，同步代码块）</span></h2><p>面试常问：</p><pre><code class="Java">//都不能保证线程安全问题public static synchronized Singleton getInstance() &#123;        if(instance == null) &#123;            synchronized (Singleton.class) &#123;                                    instance = new Singleton();                            &#125;        &#125;        return instance;    &#125;</code></pre><h2><span id="双重检查">双重检查</span></h2><pre><code class="java">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题，同时保证了效率, 推荐使用    public class LazyDoubleCheckSingleton &#123;    private volatile static LazyDoubleCheckSingleton instance=null;    private LazyDoubleCheckSingleton() &#123;    &#125;    public static LazyDoubleCheckSingleton getInstance()&#123;        if (null==instance) &#123;//第一个 if(instance==null)，其实是为了解决代码中的效率问题，只有instance为null的时候，才进入synchronized的代码段,大大减少了几率。            synchronized (LazyDoubleCheckSingleton.class) &#123;                if (null==instance) &#123;//第二个if(instance==null)，则是为了防止可能出现多个实例的情况。                    instance=new LazyDoubleCheckSingleton();                    /*                    * 1.分配内存给这对象                    * 2.初始化对象                    * 3.设置instance指向刚刚分配的内存空间（执行完这步 instance才是非 null了）                    * 其中2和3会指令重排序，执行顺序可能为123或132                    * */                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p>这种方式实例化代码只执行一次，效率大大提高！</p><h2><span id="静态内部类">静态内部类</span></h2><pre><code class="java">// 静态内部类完成， 推荐使用class Singleton &#123;        private static volatile Singleton instance;    //构造器私有化        private Singleton() &#123;&#125;    //写一个静态内部类,该类中有一个静态属性 Singleton        private static class SingletonInstance &#123;                private static final Singleton INSTANCE = new Singleton();            //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE        public static synchronized Singleton getInstance() &#123;                return SingletonInstance.INSTANCE;        &#125;&#125;</code></pre><p>实现了懒加载，采用了类装载的机制来保证初始化实例时只有一个线程；在创建instance对象时，jvm底层机制保证了线程安全，在类进行<strong>初始化</strong>时，其他线程是<strong>无法进入</strong>的。</p><h2><span id="枚举">枚举</span></h2><pre><code class="Java">enum Singleton&#123;    INSTANCE;//属性    public void sayOK()&#123;        System.out.println(&quot;hello ,zzzzz&quot;);    &#125;&#125;</code></pre><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024160546802.png" alt="image-20211024160546802"></p><h2><span id="单例模式实际应用">单例模式实际应用</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024161002863.png" alt="image-20211024161002863"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211024161411068.png" alt="image-20211024161411068"></p><h1><span id="原型模式">原型模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026205237675.png" alt="image-20211026205237675"></p><p>在spring源码中的应用</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026205329079.png" alt="image-20211026205329079"></p><p>在xml文件中配置bean的属性时，可以为prototype，可以为singleton，prototype就为原型模式，多次创建的是不同的对象。</p><h2><span id="浅拷贝">浅拷贝</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026205809360.png" alt="image-20211026205809360"></p><p>总结：如果为引用型变量就是复制地址，指向的就是同一个对象。</p><h2><span id="深拷贝">深拷贝</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026211322440.png" alt="image-20211026211322440"></p><p>总结：为引用类型重新开辟存储空间</p><p>深拷贝推荐方式2，通过对象的序列化反序列化来实现，因为类中的引用类型变量有可能很多。</p><h3><span id="注意">注意：</span></h3><p>重复创建对象利用原型模式可以提高效率，可以动态获得对象的状态</p><p>缺点，在已有的类配备克隆方法时，违背了ocp原则</p><h1><span id="建造者模式">建造者模式</span></h1><p>又叫做生成器模式。可以将复杂对象的建造过程抽象出来，使这个抽象工程的不同实现方法可以构造出不同表现的对象，</p><p>用户只指定复杂对象的类型和内容即可构建，不需知道内部的具体构建细节。</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026215505690.png" alt="image-20211026215505690"></p><p>jdk源码应用：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026220142842.png"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211026220527322.png" alt="image-20211026220527322"></p><p><strong>注意：</strong></p><p>1.客户不必知道产品内部细节，将产品本身与创建过程解耦，使得相同的创建工程可以创建不同的产品</p><p>2.用户使用不同的建造者可以的得到不同的产品对象。</p><p>3.增加新的具体建造者无需修改原有代码，符合ocp原则</p><h1><span id="适配器模式">适配器模式</span></h1><p>原理：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211027142225568.png" alt="image-20211027142225568"></p><h2><span id="类适配器">类适配器</span></h2><p>由于Java的单继承机制，所以类适配器继承被适配类算是一个缺点，由于这个就要求dst必须为接口，有局限性。</p><h2><span id="对象适配器">对象适配器</span></h2><p>思路和类适配器相同，只修改适配器类，用关联关系替代继承关系，<strong>常用</strong>。</p><pre><code class="java">private Voltage220V voltage220V; // 关联关系-聚合    //通过构造器，传入一个 Voltage220V 实例    public VoltageAdapter(Voltage220V voltage220v) &#123;        this.voltage220V = voltage220v;    &#125;</code></pre><h2><span id="接口适配器">接口适配器</span></h2><p>适用于一些接口不想全部实现其中的方法</p><p>因为实现类接口必须实现所有方法，但是继承一个抽象类不需全部实现</p><p>所以就选一个抽象类实现接口，然后再继承抽象类，<strong>想实现哪个方法，进行覆盖就可以</strong></p><p>这个抽象类就充当适配器角色。</p><h3><span id="在springmvc中适配器的应用最好配合代码理解">在springmvc中适配器的应用(最好配合代码理解)</span></h3><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211027144457122.png" alt="image-20211027144457122"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211027144516988.png" alt="image-20211027144516988"></p><p>注意：<br>三种方式是根据src是以怎样的形式给到适配器来决定的，实际开发中不只三种。</p><h1><span id></span></h1><h1><span id="桥接模式">桥接模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211027151335799.png" alt="image-20211027151335799"></p><p>在JDBC中的源码剖析</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211027152310272.png" alt="image-20211027152310272"></p><p>DirverManager即为桥接者。</p><p>注意：<br>实现了抽象和实现的分离：有助于系统进行分层设计</p><p>应用场景：不希望使用继承或因为多继承导致类个数太多，适用桥接模式</p><h1><span id></span></h1><h1><span id="装饰器模式">装饰器模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028143352415.png" alt="image-20211028143352415"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028144000021.png" alt="image-20211028144000021"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028143852225.png" alt="image-20211028143852225"></p><p>装饰器：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028144439323.png" alt="image-20211028144439323"></p><p>源码应用：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028145237384.png" alt="image-20211028145237384"></p><h1><span id="组合模式">组合模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028151204492.png" alt="image-20211028151204492"></p><p>源码分析：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/Blog\source_posts\设计模式Study-1\image-20211028151951391.png" alt="image-20211028151951391"></p><p>注意：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028152138761.png" alt="image-20211028152138761"></p><h1><span id="外观模式">外观模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028153417778.png" alt="image-20211028153417778"></p><p>源码分析</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028154116000.png" alt="image-20211028154116000"></p><p>注意：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028154240407.png" alt="image-20211028154240407"></p><h1><span id="享元模式">享元模式</span></h1><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028160230143.png" alt="image-20211028160230143"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028160207840.png" alt="image-20211028160207840"></p><p>webSiteFactory是一个享元工厂类，里面构建一个池容器，这个模式和数据库连接池原理差不多。</p><p>源码分析</p><pre><code>//小结://1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回//2. valueOf 方法，就使用到享元模式//3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快</code></pre><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028160918448.png" alt="image-20211028160918448"></p><p>注意：</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211028161124872.png" alt="image-20211028161124872"></p><h1><span id></span></h1><h1><span id="代理模式">代理模式</span></h1><h2><span id="静态代理">静态代理</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211029232924526.png" alt="image-20211029232924526"></p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211029233014699.png" alt="image-20211029233014699"></p><p>因为目标对象与代理对象都继承了相同的这个接口</p><h2><span id="动态代理">动态代理</span></h2><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211029235600571.png" alt="image-20211029235600571"></p><h2><span id="cglib代理">Cglib代理</span></h2><p>目标对象不需要实现接口</p><h1><span id="模板方法模式">模板方法模式</span></h1><p>在一个抽象类公开定义模板，子类按需重写需要的方法实现。</p><p><strong>钩子方法</strong></p><p>在父类中定义一个方法，默认不做任何事，子类看情况要不要覆盖。称为钩子。</p><p>源码分析</p><p><img src="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FStudy-1/image-20211030003918207.png" alt="image-20211030003918207"></p><p>AbstractApplicationContext继承ConfigurableApplicationContext会实现抽象方法和几个钩子。</p><ul><li><p>注意：</p></li><li><p>算法只存在于父类中，需要修改时修改父类即可。</p></li><li><p>实现了代码最大化复用。</p></li><li><p>统一了算法也有很大的灵活性。</p></li><li><p>不足就是每一个不同的实现都需要一个子类，导致类的个数增加。</p></li><li><p>防止子类重写就加一个final</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals和==</title>
      <link href="/2021/08/31/equals%E5%92%8C/"/>
      <url>/2021/08/31/equals%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1><span id="equals和">equals和==</span></h1><p><strong>很简单：</strong></p><p>​             equals在比较字符串常量时比较的是内容，对于非字符串对象是比较指向对象所否相同；</p><p>​             ==比较的是内存首地址，因为在String中对equals方法进行了重写，而在object中没有，equals和==所比较的都是所在内存的首地址</p><p><strong>注意：</strong>比较基本类型只可用==，比较基本类型的包装类型时可以用equals，比较的是内容</p>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> equlas和== </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和栈(壹)</title>
      <link href="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/"/>
      <url>/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/</url>
      
        <content type="html"><![CDATA[<h1><span id="堆和栈的区别">堆和栈的区别😍</span></h1><p><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html">在自学开发的老司机</a></p><p>看过上面的博文自己来总结一下：</p><p><strong>什么是局部变量：</strong>定义在函数中的变量、定义在函数中的参数上的变量、定义在for循环内部的变量</p><table><thead><tr><th align="center"></th><th align="center">栈</th><th align="center">堆</th></tr></thead><tbody><tr><td align="center">存放</td><td align="center">函数中定义的基本类型变量，局部变量，对象的引用变量</td><td align="center">new创建的对象和数组</td></tr><tr><td align="center">垃圾回收</td><td align="center">数数据一执行完毕，变量会立即释放，节约内存空间</td><td align="center">堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除（Java的优点）</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">其中所有实体都有内存地址值，实体用来封装数据，都有默认初始值</td></tr></tbody></table><h2><span id="使用6个例子来加深理解">使用6个例子来加深理解：</span></h2><h3><span id="壹">壹：</span></h3><pre><code class="java">main()　　int x=1;show ()　　int x=2</code></pre><p>main函数和show函数内都定义了x变量，jvm在栈内分配空间，两者互不影响</p><p><strong>详细过程</strong>：</p><p>1—主函数为入口jvm先执行，在栈内存开辟空间，存放int类型变量x,同时赋值1；</p><p>2—接下来执行show函数，在栈内存中开辟新空间，存放int类型变量x，同时赋值2；</p><p>3—show()执行完毕，变量X立即释放，空间消失。但是main函数空间依然存在，不收影响。</p><p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831104241503.png"></p><hr><h3><span id="贰">贰：</span></h3><pre><code class="java">main()    int[] x=new int[3];    x[0]=20;  </code></pre><p><strong>详细过程</strong>:</p><p>1—老样子，main为入口，jvm在栈内存中开辟一个空间存放x变量（局部变量）   同时在堆内存中也开辟一个空间，用来x指向的int数组。此时所有元素均为赋值但是都有默认初始值；</p><p>2—-执行x[0]=20</p><p>​       即将在堆内存中将20赋给第一个数组元素，到现在为止，数组的三个元素分别为20，0，0；</p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831105527840.png" alt="image-20210831105527840"><hr><h3><span id="叁">叁：</span></h3><pre><code class="Java">main()　　int[] x=new int[3];　　x[0]=20　　x=null;</code></pre><p><strong>详细过程</strong>:</p><p>1-2与上相同</p><p>3—执行x=null</p><p>​      null表示空值，即X的引用数组内存地址0x0045被删除了，在栈内引用不了了。同时，由于堆中的数组不再被X使用，被jvm视为垃圾，启动垃圾回收机制，不定时自定删除。</p><p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831110142264.png" alt="image-20210831110142264"></p><hr><h3><span id="肆">肆：</span></h3><pre><code class="Java">main()　　int[] x=new int[3];　　int[] y=x;　　y[1]=100　　x=null</code></pre><p><strong>详细过程</strong>:</p><p> 1—与贰的第一步相同</p><p> 2—执行int [] y=x;</p><p>​      在栈内新开内存存放y变量，同时将0x0045赋给y，所以y也指向了堆内存中的同一个数组</p><p> 3—执行y[1]=100</p><p>​       即在堆中将100赋给[1]这个数组元素，现在数组中的元素值为0，100，0；</p><p> 4—执行x=null</p><p>​       则变量x不再指向栈内存中的数组。但是y仍然指向数组，所以数组不消失</p><p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831141750764.png" alt="image-20210831141750764"></p><hr><h3><span id="伍">伍：</span></h3><pre><code class="java">Car c=new Car;c.color=&quot;bule&quot;;Car c1=new Car;c1.num=5</code></pre><p>都引用new Car,但两个不同的对象会产生两个不同的实体</p><p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831142206084.png" alt="image-20210831142206084"></p><hr><h3><span id="陆">陆：</span></h3><pre><code class="java">Car c=new Car;c.color=&quot;green&quot;;Car c1=c;c1.num=5</code></pre><p>c1=c，相当于复制一份对象，两个对象在堆中的内存地址一样，指向同一个实体，修改一个两个对象的属性都修改。</p><p><img src="/2021/08/31/%E5%A0%86%E5%92%8C%E6%A0%88-%E5%A3%B9/image-20210831111340998.png" alt="image-20210831111340998"></p><p>想宝贝的第好几天👩‍❤️‍💋‍👩👯‍♂️👩🏼‍🤝‍👩🏻</p>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆和栈的区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/2021/08/29/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/08/29/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="lambda">lambda</span></h1><h2><span id="语法">语法</span></h2><p>lambda 表达式的语法格式如下：</p><p><strong>(parameters) -&gt; expression</strong> 或 <strong>(parameters) -&gt;{ statements; }</strong></p><p>以下是lambda表达式的重要特征:</p><ul><li><p><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</p></li><li><p><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</p></li><li><p><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</p></li><li><p><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值</p><p><strong>实例：</strong></p></li></ul><pre><code class="java">package com.zz.se;public class Java8Tester &#123;    public static void main(String args[])&#123;        Java8Tester tester = new Java8Tester();        // 类型声明        MathOperation addition = (int a, int b) -&gt; a + b;        // 不用类型声明        MathOperation subtraction = (a, b) -&gt; a - b;        // 大括号中的返回语句        MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;        // 没有大括号及返回语句        MathOperation division = (int a, int b) -&gt; a / b;        System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));        System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));        System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));        System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));        // 不用括号        GreetingService greetService1 = message -&gt;                System.out.println(&quot;Hello &quot; + message);        // 用括号        GreetingService greetService2 = (message) -&gt;                System.out.println(&quot;Hello &quot; + message);        greetService1.sayMessage(&quot;Runoob&quot;);        greetService2.sayMessage(&quot;Google&quot;);    &#125;    interface MathOperation &#123;        int operation(int a, int b);    &#125;    interface GreetingService &#123;        void sayMessage(String message);    &#125;    private int operate(int a, int b, MathOperation mathOperation)&#123;        return mathOperation.operation(a, b);    &#125;&#125;</code></pre><p>运行结果：<img src="/2021/08/29/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210829202936515.png" alt="image-20210829202936515">y</p><p><strong>可以看出：</strong></p><ul><li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul><h3><span id="省略规则">省略规则</span></h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><h2><span id="变量作用域">变量作用域</span></h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误</p><pre><code class="java">package com.zz.se;public class Demo2 &#123;    final static String salutation = &quot;Hello! &quot;;    public static void main(String args[])&#123;        ZzService greetService1 = message -&gt;                System.out.println(salutation + message);        greetService1.sayMessage(&quot;Gzz&quot;);    &#125;    interface ZzService&#123;       void sayMessage(String message);    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="/2021/08/29/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210829203729657.png" alt="image-20210829203729657"></p><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><pre><code class="java">public class Demo3 &#123;    public static void main(String[] args) &#123;        final int num=1;        Converter s=(Pram)-&gt; System.out.println(Pram+num);        s.con(10);//结果为11    &#125;    public interface Converter&#123;        void con(int i);    &#125;&#125;</code></pre><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><p><img src="/2021/08/29/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20210829211116649.png" alt="image-20210829211116649"></p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataJPA之提供接口种类(二)</title>
      <link href="/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/"/>
      <url>/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2><span id="crudreposiroty">CrudReposiroty</span></h2><p>继承了Repository</p><p><img src="/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/1445322-20190113001524301-1212575806.png" alt="1445322-20190113001524301-1212575806"></p><p>Crud主要是添加了对数据的增删改查的方法</p><h2><span id="pagingandsortingrepositor">PagingAndSortingRepositor</span></h2><p> 继承了CrudRepository</p><pre><code class="java">/** * 继承了Repository,缺点只能对所有的数据进行排序或者分页 */@Repositorypublic interface UserPagingAndSortingReposiroty extends PagingAndSortingRepository&lt;User, Integer&gt; &#123;&#125;</code></pre><h2><span id="jparepository">JPARepository</span></h2><p>继承了PagingAndSortingRepository接口</p><p>在开发中常用JPARepository</p><p>优点: 对继承父接口中方法的返回值进行了适配,因为在父类接口中通常都返回迭代器，需要我们自己进行强制类型转化。而在JpaRepository中，直接返回了List</p><h2><span id="jpaspecificationexecutor">JpaSpecificationExecutor</span></h2><p>接口内部如图所示：</p><p><img src="/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/Snipaste_2021-08-27_09-24-59.png" alt="Snipaste_2021-08-27_09-24-59"></p><p>提供了多条件查询的支持，并且可以在查询中添加分页和排序，因为这个接口单独存在，所以要配合以上接口配合使用。</p><pre><code class="Java">/** * JpaSpecificationExecutor是单独存在的，需要配合这JpaRepository一起使用 */@Repositorypublic interface UserJpaSpecificationExecutor extends JpaSpecificationExecutor&lt;User&gt;, JpaRepository&lt;User, Integer&gt; &#123;&#125;</code></pre><pre><code class="java">public interface JpaSpecificationExecutor&lt;T&gt; &#123;   //根据 Specification 条件查询单个对象，注意的是，如果条件能查出来多个会报错   T findOne(@Nullable Specification&lt;T&gt; spec);   //根据 Specification 条件查询 List 结果   List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec);   //根据 Specification 条件，分页查询   Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable);   //根据 Specification 条件，带排序的查询结果   List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort);   //根据 Specification 条件，查询数量   long count(@Nullable Specification&lt;T&gt; spec);&#125;</code></pre><p>可以根据传入参数看出<strong>JpaSpecificationExecutor</strong>接口基本是围绕<strong>Specification</strong>接口定义的。而<strong>Specification</strong>接口最常用的就是以下方法：</p><pre><code class="java">Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);</code></pre><p>可以看出JpaSpecificationExecutor对criteria进行了Predicate格式的封装，使我们操作criteria更加遍利</p><p><strong>Criteria介绍：</strong></p><p>（1）<strong>Root<t>root</t></strong>代表了可以查询和操作的实体对象的根。通俗讲就是对象的属性。通过里面的**Path<y>get(String attributeName)**来获得我们操作的字段。</y></p><p>（2）<strong>CriteriaQuery&lt;?&gt;query：</strong>代表一个特殊的顶层查询对象，它包含着查询的各个部分，比如：select、from、where、groupby、order by等。CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用，简单理解，它提供了查询ROOT的方法。常用的方法有：</p><pre><code class="java">package javax.persistence.criteria;import java.util.List;import java.util.Set;public interface CriteriaQuery&lt;T&gt; extends AbstractQuery&lt;T&gt; &#123;    CriteriaQuery&lt;T&gt; select(Selection&lt;? extends T&gt; var1);    CriteriaQuery&lt;T&gt; multiselect(Selection&lt;?&gt;... var1);    CriteriaQuery&lt;T&gt; multiselect(List&lt;Selection&lt;?&gt;&gt; var1);    CriteriaQuery&lt;T&gt; where(Expression&lt;Boolean&gt; var1);    CriteriaQuery&lt;T&gt; where(Predicate... var1);    CriteriaQuery&lt;T&gt; groupBy(Expression&lt;?&gt;... var1);    CriteriaQuery&lt;T&gt; groupBy(List&lt;Expression&lt;?&gt;&gt; var1);    CriteriaQuery&lt;T&gt; having(Expression&lt;Boolean&gt; var1);    CriteriaQuery&lt;T&gt; having(Predicate... var1);    CriteriaQuery&lt;T&gt; orderBy(Order... var1);    CriteriaQuery&lt;T&gt; orderBy(List&lt;Order&gt; var1);    CriteriaQuery&lt;T&gt; distinct(boolean var1);    List&lt;Order&gt; getOrderList();    Set&lt;ParameterExpression&lt;?&gt;&gt; getParameters();&#125; </code></pre><p>（3）CriteriaBuilder cb：用来构建<strong>CritiaQuery</strong>的构建器对象，其实就相当于条件或者是条件组合，即以Predicate的形式返回。构建简单的Predicate示例：</p><p><strong>JpaSpecificationExecutor接口下结构如图：</strong>!<img src="/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/1445322-20190113140545272-914950979.png" alt="1445322-20190113140545272-914950979"></p><p><strong>JpaSpecificationExecutor实现原理</strong></p><p><img src="/2021/08/27/SpringDataJPA%E4%B9%8B%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%A7%8D%E7%B1%BB-%E4%BA%8C/Snipaste_2021-08-29_21-38-01.png" alt="Snipaste_2021-08-29_21-38-01"></p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> spring boot学习 </category>
          
          <category> JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jpa JpaSpecificationExecutor使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP和IOC问题</title>
      <link href="/2021/08/26/Spring-AOP%E5%92%8CIOC%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/26/Spring-AOP%E5%92%8CIOC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3><span id="ioc">IOC</span></h3><h4><span id="first">First</span></h4><p>IOC(<strong>Inversion of Control</strong>) 即控制反转，<strong>注意</strong>：不是技术，而是一种设计思想🎆🎆🎆🎆🎆</p><p><strong>Ioc意味着将你设计好的对象交给容器控制</strong></p><p><strong>容器</strong>：IoC 容器控制了对象；</p><p><strong>控制什么</strong>：主要控制了外部资源获取（不只是对象包括比如文件等），不用自己new了</p><p><strong>正转</strong>：自己直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象</p><p><strong>反转</strong>：则是由容器来帮忙创建及注入依赖对象</p><p><strong>控制什么反转了</strong>：依赖对象的获取</p><p>传统程序设计如图：是主动创建对象然后再组合</p><p><img src="/2021/08/26/Spring-AOP%E5%92%8CIOC%E9%97%AE%E9%A2%98/261421378318292.jpg" alt="261421378318292"></p><p>有了IOC/DI容器后：客户端就不用去主动创建对象</p><p><img src="/2021/08/26/Spring-AOP%E5%92%8CIOC%E9%97%AE%E9%A2%98/%E4%B8%8B%E8%BD%BD.png" alt="下载"></p><p>其实从另一层面来说 IOC也达到的松耦合的效果</p><p>🎞 <strong>面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你</strong></p><p><strong>DI</strong>（Dependency Injection）依赖注入 ：由容器将某个依赖关系（example：用户类依赖用户信息类）动态地注入到组件中，目的并非为组件增加什么功能，而是提升组件重用地频率，并为系统搭建一个灵活可拓展的平台，有了依赖注入机制，我们只需进行简单的配置即可。</p><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”</p><ul><li>谁依赖谁：应用程序依赖IOC容器</li><li>为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源</li><li>谁注入谁：IOC注入应用程序某个对象，应用程序依赖的某个对象</li><li>注入了什么：注入某个对象需要的外部资源（包括对象，资源，常量数据）</li></ul><h5><span id="ioc和di的关系">IOC和DI的关系</span></h5><p><strong>是同一个概念的不同角度描述</strong></p><p>相对IoC 而言，依赖注入明确描述了<strong>被注入对象依赖IoC容器配置依赖对象</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swaager传入参数问题</title>
      <link href="/2021/08/26/Swaager%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/26/Swaager%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3><span id="swaager配置时">Swaager配置时</span></h3><p>要注意<strong>RequestMapping</strong>属性 （comsumes）本次传入参数点击<strong>excute</strong>报红却不可执行 改变了datatype也不行</p><p>看了响应头原来是 <strong>content-type: application/json</strong> 在<strong>RequestMapping</strong>中配置<strong>consumes</strong>指定数据请求的格式为<strong>application/json</strong>格式，把<strong>consumes</strong>属性去掉就好</p><p><img src="/2021/08/26/Swaager%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/image-20210826103240523.png" alt="image-20210826103240523"></p><h5><span id="request-mapping属性">Request Mapping属性</span></h5><pre><code class="java">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) // 可以在方法和类的声明中使用@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123;    String name() default &quot;&quot;;// 指定映射的名称    @AliasFor(&quot;path&quot;)    String[] value() default &#123;&#125;; // 指定请求路径的地址    @AliasFor(&quot;value&quot;)    String[] path() default &#123;&#125;; // 指定请求路径的地址    // 指定请求的方式，是一个RequsetMethod数组，可以配置多个方法    RequestMethod[] method() default &#123;&#125;;        // 指定参数的类型    String[] params() default &#123;&#125;;        // 指定请求头内容    String[] headers() default &#123;&#125;;        // 指定数据请求的格式    String[] consumes() default &#123;&#125;;        // 指定返回的内容类型    String[] produces() default &#123;&#125;;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Swaager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JPA</title>
      <link href="/2021/08/24/%E5%88%9D%E8%AF%86JPA/"/>
      <url>/2021/08/24/%E5%88%9D%E8%AF%86JPA/</url>
      
        <content type="html"><![CDATA[<h1><span id="springdatajpa">SpringDataJPA</span></h1><p>[TOC]</p><p>是springdata项目下的一个模块</p><p>使用：定义接口并集成spring Data JPA中所提供的接口即可</p><hr><h3><span id="接口继承结构">接口继承结构👀</span></h3><p><img src="/2021/08/24/%E5%88%9D%E8%AF%86JPA/jpa1.png" alt="jpa1"></p><h3><span id="入门案例">入门案例</span></h3><p> 通过jpaRepoistry接口实现一个简单操作</p><h4><span id="1创建maven项目">1.创建maven项目</span></h4><h4><span id="2添加相关依赖">2.添加相关依赖</span></h4><p>​     基础依赖+额外依赖（hibernate JPA+SpringDataJPA）</p><pre><code class="java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;4.3.21.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.6.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.mchange&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.5.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;        &lt;version&gt;5.0.7.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;4.3.21.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;4.3.21.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;        &lt;version&gt;5.0.7.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;        &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4><span id="3添加配置文件">3.添加配置文件</span></h4><p>  数据库配置文件+spring配置文件（application.xml）( •̀ ω •́ )✧</p><pre><code class="java">jdbc.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8jdbc.driver.class=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=123456</code></pre><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd    http://www.springframework.org/schema/data/jpa    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd    http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;        &lt;!-- 配置读取properties文件的工具类 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;        &lt;!-- 配置c3p0数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver.class&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Spring 整合 JPA 配置 EntityManagerFactory--&gt;    &lt;bean id=&quot;entityManagerFactory&quot;          class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;                &lt;!-- hibernate 相关的属性的注入 --&gt;                &lt;!-- 配置数据库类型 --&gt;                &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;                &lt;!-- 正向工程 自动创建表 --&gt;                &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;                &lt;!-- 显示执行的 SQL --&gt;                &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;!-- 扫描实体的包 --&gt;        &lt;property name=&quot;packagesToScan&quot;&gt;            &lt;list&gt;                &lt;value&gt;com.dpb.pojo&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置 Hibernate 的事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;          class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;        &lt;property name=&quot;entityManagerFactory&quot;                  ref=&quot;entityManagerFactory&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 配置开启注解事务处理 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;        &lt;!-- 配置springIOC的注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.dpb&quot;/&gt;    &lt;!-- Spring Data JPA 的配置 --&gt;    &lt;!-- base-package：扫描 dao 接口所在的包 --&gt;    &lt;jpa:repositories base-package=&quot;com.dpb.dao&quot;/&gt;&lt;/beans&gt;</code></pre><h4><span id="4创建pojo类user和dao接口">4.创建pojo类User和Dao接口</span></h4><h6><span id="开发中modelentity和pojo的区别"></span></h6><pre><code class="java">package com.zz.pojo;import javax.persistence.*;import java.io.Serializable;/** * @program: spring-hibernate-jpa * @description: Users的Pojo对象 * @author: zz * @create: 2021-08-24 */@Entity@Table(name=&quot;users&quot;)public class Users implements Serializable &#123;    @Id    @GeneratedValue(strategy= GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长    @Column(name=&quot;userid&quot;)    private Integer userid;    @Column(name=&quot;username&quot;)    private String username;    @Column(name=&quot;userage&quot;)    private Integer userage;    public Integer getUserid() &#123;        return userid;    &#125;    public void setUserid(Integer userid) &#123;        this.userid = userid;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Integer getUserage() &#123;        return userage;    &#125;    public void setUserage(Integer userage) &#123;        this.userage = userage;    &#125;    @Override    public String toString() &#123;        return &quot;Users [userid=&quot; + userid + &quot;, username=&quot; + username + &quot;, userage=&quot; + userage + &quot;]&quot;;    &#125;&#125;</code></pre><pre><code class="java">/** * SpringDataJPA 实现JpaRepository * 泛型 第一个参数是对应的Pojo类型 *      第二个参数是注解的包装类型(将实体类型和实体类的id类型作为类型参数) */public interface UserDao extends JpaRepository&lt;Users,Integer&gt; &#123;&#125;</code></pre><h4><span id="5测试">5.测试</span></h4><pre><code class="java">/** * @program: spring-data-jpa * @description: 测试 * @author: zz * @create: 2021-08-24 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)//取当前项目路径中的主配置文件public class TestDemo &#123;    @Autowired    private UserDao usersDao;    /**     * 添加用户     */    @Test    @Transactional// 在测试类对于事务提交方式默认的是回滚。    @Rollback(false)//取消自动回滚    public void testInsertUsers()&#123;        Users users = new Users();        users.setUserage(20);        users.setUsername(&quot;张三-jpa&quot;);        this.usersDao.save(users);    &#125;&#125;</code></pre><h4><span id="运行结果">运行结果：</span></h4><p><img src="/2021/08/24/%E5%88%9D%E8%AF%86JPA/image-20210824172908751.png" alt="image-20210824172908751"></p><h5><span id="注意要先创建ssm数据库在idea中完成对数据库的连接"><strong>注意:<strong>💥💥💥💥💥：</strong>要先创建ssm数据库，在idea中完成对数据库的连接</strong>💢💢💢💢💢</span></h5><hr>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> spring boot学习 </category>
          
          <category> JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> jpa 使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataJPA之提供的接口</title>
      <link href="/2021/08/23/springboot-study/"/>
      <url>/2021/08/23/springboot-study/</url>
      
        <content type="html"><![CDATA[<h1><span id="springdatajpa之提供接口种类">SpringDataJPA之提供接口种类</span></h1><hr><p>1.<strong>Repository</strong>: 最顶层接口，目的：统一所有Repositry的类型，且能让组件扫描的时候自动识别</p><p>2.<strong>CrudRepository</strong> ：Repository的子接口，提供CRUD的功能</p><p>3<strong>PagingAndSortingRepository</strong>：CrudRepository的子接口，添加分页和排序的功能</p><p>4.<strong>JpaRepository</strong>：继承了PagingAndSortingRepository接口，增加了一些实用的功能，比如：批量操作等，优点：对继承父接口（PagingAndSortingRepository）方法中的返回值进行了适配，因为在父接口中通常返回形式为迭代器形式，需要自己强转类型，而在这里直接返回List</p><p>5.<strong>JpaSpecificationExecutor</strong>：单独存在，无继承接口，提供了多条件查询，因为单独存在所以要配合以上的接口使用（一般为JPARepository）</p><p>6：<strong>Specification</strong>：是Spring Data JPA提供的一个查询规范，要做复杂的查询，只需围绕这个规范来设置查询条件</p><h2><span id="repository">Repository:</span></h2><p>查询方式：</p><p>​     1.<strong>基于方法名称命名规则进行查询</strong>：findBy(关键字)+属性名称(属性名称的首字母大写)+查询条件(首字母大写)</p><table><thead><tr><th align="center">关键字</th><th align="center">方法命名</th><th align="center">sql where子句</th></tr></thead><tbody><tr><td align="center">And</td><td align="center">findByNameAndPwd</td><td align="center">where name=? and pwd=?</td></tr><tr><td align="center">Or</td><td align="center">findByNameOrSex</td><td align="center">where name=? and sex=?</td></tr><tr><td align="center">Is,Equal</td><td align="center">findById,findByIdEquals</td><td align="center">where id= ?</td></tr><tr><td align="center">Between</td><td align="center">findByIdBetween</td><td align="center">where id between ? and ?</td></tr><tr><td align="center">LessThan</td><td align="center">findByIdLessThan</td><td align="center">where id &lt; ?</td></tr><tr><td align="center">LessThanEqual</td><td align="center">findByIdLessThanEquals</td><td align="center">whrere id &lt;=?</td></tr><tr><td align="center">GreaterThan</td><td align="center">findByIdGreaterThan</td><td align="center">whrere id &gt; ?</td></tr><tr><td align="center">GreaterThanEqual</td><td align="center">findByIdGreaterThanEquals</td><td align="center">whrere id &gt;= ?</td></tr><tr><td align="center">After</td><td align="center">findByIdAfter</td><td align="center">where id &gt; ?</td></tr><tr><td align="center">Before</td><td align="center">findByIdBefore</td><td align="center">where id &lt; ?</td></tr><tr><td align="center">IsNull</td><td align="center">findByNameIsNull</td><td align="center">where name is null</td></tr><tr><td align="center">isNotNull,Not</td><td align="center">findByNameNotNull</td><td align="center">where name is not null</td></tr><tr><td align="center">Like</td><td align="center">findByNameLike</td><td align="center">where name like ?</td></tr><tr><td align="center">NotLike</td><td align="center">findByNameNotLike</td><td align="center">where name not like ?</td></tr><tr><td align="center">StartingWith</td><td align="center">findByNameStartingWith</td><td align="center">where name like ‘?%’</td></tr><tr><td align="center">EndingWith</td><td align="center">findByNameEndingWith</td><td align="center">where name like ‘%?’</td></tr><tr><td align="center">Containing</td><td align="center">findByNameContaining</td><td align="center">where name like ‘%?%’</td></tr><tr><td align="center">OrderBy</td><td align="center">findByIdOrderByXDesc</td><td align="center">where id=? order by x desc</td></tr><tr><td align="center">Not</td><td align="center">findByNameNot</td><td align="center">where name &lt;&gt; ?</td></tr><tr><td align="center">In</td><td align="center">findByIdIn(Collection&lt;?&gt; c)</td><td align="center">where id in (?)</td></tr><tr><td align="center">NotIn</td><td align="center">findByNameNot</td><td align="center">where name &lt;&gt; ?</td></tr><tr><td align="center">True</td><td align="center">findBySexTrue</td><td align="center">where Sex = true</td></tr><tr><td align="center">False</td><td align="center">findBySexFalse</td><td align="center">where Sex = false</td></tr><tr><td align="center">IgnoreCase</td><td align="center">findByNameIgnoreCase</td><td align="center">where UPPER(name)=UPPER(?)</td></tr><tr><td align="center">Top</td><td align="center">findTop100</td><td align="center">top 10/where ROWNUM &lt;=10</td></tr></tbody></table><h3><span id="dao层的userdao接口">Dao层的UserDao接口：</span></h3><pre><code class="Java">package com.zz.dao;import com.zz.pojo.Users;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;public interface UsersDao extends JpaRepository&lt;Users,Integer&gt; &#123;    List&lt;Users&gt; findByUsernameIs(String string);    List&lt;Users&gt; findByUsernameLike(String string);    List&lt;Users&gt; findByUsernameAndUserageGreaterThanEqual(String name, Integer age);&#125;</code></pre><h4><span id="pojo层下的users">pojo层下的Users</span></h4><pre><code class="java">package com.zz.pojo;import lombok.Data;import javax.persistence.*;import java.io.Serializable;/** * @program: spring-hibernate-jpa * @description: Users的Pojo对象 * @author: zz * @create: 2019-05-18 09:37 */@Entity@Data@Table(name=&quot;users&quot;)public class Users implements Serializable &#123;    @Id    @GeneratedValue(strategy= GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长    @Column(name=&quot;userid&quot;)    private Integer userid;    @Column(name=&quot;username&quot;)    private String username;    @Column(name=&quot;userage&quot;)    private Integer userage;    public Integer getUserid() &#123;        return userid;    &#125;    public void setUserid(Integer userid) &#123;        this.userid = userid;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Integer getUserage() &#123;        return userage;    &#125;    public void setUserage(Integer userage) &#123;        this.userage = userage;    &#125;    @Override    public String toString() &#123;        return &quot;Users [userid=&quot; + userid + &quot;, username=&quot; + username + &quot;, userage=&quot; + userage + &quot;]&quot;;    &#125;&#125;</code></pre><h4><span id="test测试类">Test测试类</span></h4><pre><code class="java">import com.zz.dao.UsersDao;import com.zz.pojo.Users;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * @program: spring-data-jpa * @description: 单元测试 * @author: 波波烤鸭 * @create: 2019-05-18 09:48 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class TestDemo &#123;    @Autowired    private UsersDao usersDao;    /**     * 添加用户 如继承接口为jpaRespository,可直接用save方法     */    @Test    @Transactional// 在测试类对于事务提交方式默认的是回滚。    @Rollback(false)//取消自动回滚    public void testInsertUsers()&#123;        Users users = new Users();        users.setUserage(20);        users.setUsername(&quot;moyi&quot;);        this.usersDao.save(users);    &#125;    /**     * 需求：使用用户名作为查询条件     */    @Test    public void test1() &#123;    /**     * 判断相等的条件，三种表达方式     * 1.无，默认相等判断     * 2.Is     * 3.equal     */        List&lt;Users&gt; list = this.usersDao.findByUsernameIs(&quot;moyi&quot;);        for (Users users0 : list) &#123;            System.out.println(users0);            &#125;    &#125;    /**     * 需求：根据用户姓名做Like处理     * Like:条件关键字     */    @Test    public void test2() &#123;        List&lt;Users&gt; list = this.usersDao.findByUsernameLike(&quot;mo%&quot;);        for (Users users : list) &#123;            System.out.println(&quot;根据用户姓名做Like处理&quot;+users);        &#125;    &#125;    /**     * 需求：查询名称为moyi，且年龄大于18     */    @Test    public void test3() &#123;        List&lt;Users&gt; list = this.usersDao.findByUsernameAndUserageGreaterThanEqual(&quot;moyi&quot;, 18);        for (Users users : list) &#123;            System.out.println(&quot;查询名称为moyi，且年龄大于18&quot;+users);        &#125;    &#125;   &#125;</code></pre><h4><span id="配置文件">配置文件</span></h4><h6><span id="applicationcontextxml">applicationContext.xml</span></h6><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd    http://www.springframework.org/schema/data/jpa    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd    http://www.springframework.org/schema/tx    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 配置读取properties文件的工具类 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- 配置c3p0数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver.class&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Spring 整合 JPA 配置 EntityManagerFactory--&gt;    &lt;bean id=&quot;entityManagerFactory&quot;          class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;                &lt;!-- hibernate 相关的属性的注入 --&gt;                &lt;!-- 配置数据库类型 --&gt;                &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;                &lt;!-- 正向工程 自动创建表 --&gt;                &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;                &lt;!-- 显示执行的 SQL --&gt;                &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;!-- 扫描实体的包 --&gt;        &lt;property name=&quot;packagesToScan&quot;&gt;            &lt;list&gt;                &lt;value&gt;com.zz.pojo&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置 Hibernate 的事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;          class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;        &lt;property name=&quot;entityManagerFactory&quot;                  ref=&quot;entityManagerFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置开启注解事务处理 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 配置springIOC的注解扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.zz&quot;/&gt;    &lt;!-- Spring Data JPA 的配置 --&gt;    &lt;!-- base-package：扫描 dao 接口所在的包 --&gt;    &lt;jpa:repositories base-package=&quot;com.zz.dao&quot;/&gt;&lt;/beans&gt;</code></pre><h6><span id="jdbcproperties">jdbc.properties</span></h6><pre><code class="java">jdbc.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8jdbc.driver.class=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=root</code></pre><p>几个测试结果如图：</p><p><img src="/2021/08/23/springboot-study/Snipaste_2021-08-26_15-26-40.png" alt="Snipaste_2021-08-26_15-26-40"></p><p><img src="/2021/08/23/springboot-study/Snipaste_2021-08-26_16-06-47.png" alt="Snipaste_2021-08-26_16-06-47"></p><p><img src="/2021/08/23/springboot-study/Snipaste_2021-08-26_15-25-59.png" alt="Snipaste_2021-08-26_15-25-59"></p><p>🧨🧨🧨🧨🧨<strong>还是记得连接ssm数据库,自己没有要添加</strong>🎋🎋🎋🎋🎋🎋</p>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> spring boot学习 </category>
          
          <category> JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> JPA 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>threadlocal study</title>
      <link href="/2021/08/23/threadlocal-study/"/>
      <url>/2021/08/23/threadlocal-study/</url>
      
        <content type="html"><![CDATA[<h2><span id="深度解析">深度解析</span></h2><h2><span id="threadlocal代码">ThreadLocal代码</span></h2><pre><code class="java">public class ThreadLocalTest &#123;    private List&lt;String&gt; messages = Lists.newArrayList();    public static final ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::new);    public static void add(String message) &#123;        holder.get().messages.add(message);    &#125;    public static List&lt;String&gt; clear() &#123;        List&lt;String&gt; messages = holder.get().messages;        holder.remove();        System.out.println(&quot;size: &quot; + holder.get().messages.size());        return messages;    &#125;    public static void main(String[] args) &#123;        ThreadLocalTest.add(&quot;红豆沙面包&quot;);        System.out.println(holder.get().messages);        ThreadLocalTest.clear();    &#125;&#125;</code></pre><p>RESULT:</p><pre><code class="java">[红豆沙面包]size: 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java进阶 </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程(原创：一枝花算不算浪漫) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/20/hello-world/"/>
      <url>/2021/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
