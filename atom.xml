<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>香饽饽</title>
  
  <subtitle>欢迎观察一只Java小白的成长之路！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-03T02:57:55.803Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Gzz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动配置</title>
    <link href="http://example.com/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-03T02:26:21.000Z</published>
    <updated>2022-04-03T02:57:55.803Z</updated>
    
    <content type="html"><![CDATA[<ol><li><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648952872902.png" alt="1648952872902"></li></ol><p><strong>@SpringBootApplication SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动springBoot的应用</strong></p><p>2.<img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648952954673.png" alt="1648952954673"></p><p>核心注解为@EnableAutoConfiguration，开启自动配置功能</p><p>3.@EnableAutoConfiguration中有两个核心注解：</p><hr><p><strong>@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)</strong></p><p>@AutoConfigurationPackage自动扫包的配置</p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953049026.png" alt="1648953049026"></p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953122408.png" alt="1648953122408"></p><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953155312.png" alt="1648953155312"></p><p>扫描范围默认为当前文件所在包及其子包</p><p>4.@Import(AutoConfigurationImportSelector.class)</p><pre><code class="dart">//扫描具有META-INF/spring.factories文件的jar包任何一个springboot应用，都会引入spring-boot-autoconfigure，而spring.factories文件就在该包下面</code></pre><p><img src="/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648953793994.png" alt="1648953793994"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;img src=&quot;/2022/04/03/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/1648952872902.png&quot; alt=&quot;1648952872902&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;@SpringBoo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bean</title>
    <link href="http://example.com/2022/04/01/Bean/"/>
    <id>http://example.com/2022/04/01/Bean/</id>
    <published>2022-04-01T13:31:30.000Z</published>
    <updated>2022-04-01T13:43:20.646Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="循环依赖">循环依赖</span></h2><p>谈到循环依赖要先了解spring bean的生命周期</p><h3><span id="一-加载数据">一. 加载数据</span></h3><p>普通Java对象：以class作为模板创建出具体的实例</p><p>Spring Bean：除了用Class对象外，还用了BeanDefinition实例来描述对象信息</p><p>Spring在启动时需要扫描使用了 <strong>xml</strong>  <strong>注解</strong>  **javaconfig **中需要被Spring管理的Bean信息，随后把信息封装为BeanDefinition，最后把信息放在beanDefinitionMap中，key为beanName，value为BeanDefinition。</p><p>接着遍历beanDefinitionMap，执行BeanFactoryPostProcesser工厂后置处理器的处理逻辑。这里如果想获取bean的数据进行修改的话，通过自定义BeanFactoryPostProcesser来实现</p><h3><span id="二-实例化">二.  实例化</span></h3><h3><span id="三-属性填充">三. 属性填充</span></h3><h3><span id="四-初始化">四. 初始化</span></h3><p>判断该Bean是否实现了Aware相关的接口，如果存在则填充相关的资源</p><p>到了BeanPostProcessor后置处理器（是AOP实现的关键）</p><p>执行BeanPostProcessor相关子类的before方法</p><p>执行init方法，执行顺序为@PostConstruct，实现了initializingbean接口，是否自己定义了init-method方法。</p><h3><span id="五-使用">五.  使用</span></h3><h3><span id="六-销毁">六. 销毁</span></h3><p>看是否实现了diposableBean接口，执行destory方法，或者自己定义了destory-method属性</p><h3><span id="注解xmljavaconfig">注解，xml，javaconfig</span></h3><table><thead><tr><th></th><th>xml</th><th>注解</th><th>config</th></tr></thead><tbody><tr><td>便利性</td><td>不便利</td><td>便利</td><td>不便利</td></tr><tr><td>修改之后是否需要重编译</td><td>不</td><td>需要</td><td>需要</td></tr><tr><td>自由度</td><td>低</td><td>低</td><td>高</td></tr><tr><td>是否可以注入不是自己维护的类</td><td>可以</td><td>不可以</td><td>可以</td></tr></tbody></table><p>现在通常使用注解加config</p><p>只有当需要注入代码不是自己维护的第三方jar包中的类时，或者需要更为灵活地注入，比如说需要调用某个接口，查询数据，然后把这个数据赋值给要注入的对象，那么这时候就需要用到Java Config（面向接口开发）。</p><h2><span id="循环依赖">循环依赖</span></h2><p>A包含B，B包含A</p><p>使用三级缓存</p><p>singletonObjects：一级：正式对象</p><p>earlySingletonObjects：二级：半成品（考虑性能）</p><p>sinletonFactories：三级：工厂（为了代理，可以直接从里面拿代理对象，放在二级缓存）</p><p>创建A时：实例化后，把自己扔在三级缓存，key时beanName，value是ObjectFactory。</p><p>注入属性时发现B还没创建，然后实例化B，B属性注入A，A放在二级缓存中，然后B完成创建，自然A也就可以完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;循环依赖&quot;&gt;循环依赖&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;谈到循环依赖要先了解spring bean的生命周期&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;一-加载数据&quot;&gt;一. 加载数据&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;普通Java对象：以class作为模板创建出具体的实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>select，poll，epoll</title>
    <link href="http://example.com/2022/03/14/select%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
    <id>http://example.com/2022/03/14/select%EF%BC%8Cpoll%EF%BC%8Cepoll/</id>
    <published>2022-03-14T07:46:06.000Z</published>
    <updated>2022-03-21T08:22:49.282Z</updated>
    
    <content type="html"><![CDATA[<p><strong>select、poll、epoll 区别总结：</strong></p><h2><span id="底层实现">底层实现</span></h2><p><strong>select/poll</strong></p><p>他俩没多大本质区别，都是用线性结构存储进程关注的socket集合，因此都需要遍历文件描述符集合来判断是否可以读写，时间复杂度为O（n），而且也需要在用户态和内核态之间拷贝文件描述符集合，消耗性能。</p><p><strong>epoll</strong></p><p>通过两个手段解决了上面的不足</p><ol><li>在内核中使用了红黑树来跟踪进程所有的待检测文件描述符，减少了内核和用户空间大量的数据拷贝和内存分配</li><li>使用了时间驱动的机制，内核里维护了一个链表来记录就绪事件。不需要轮询检测了</li></ol><h4><span id="1-支持一个进程所能打开的最大连接数">1、支持一个进程所能打开的最大连接数</span></h4><p><strong>select</strong></p><p>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><p><strong>poll</strong></p><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><p><strong>epoll</strong></p><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><h4><span id="2-fd剧增后带来的io效率问题">2、FD剧增后带来的IO效率问题</span></h4><p>select</p><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p><p><strong>poll</strong></p><p>同上</p><p><strong>epoll</strong></p><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><h4><span id="3-消息传递方式">3、 消息传递方式</span></h4><p><strong>select</strong></p><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><p><strong>poll</strong></p><p>同上</p><p><strong>epoll</strong></p><p>epoll通过内核和用户空间共享一块内存来实现的。（错的）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;select、poll、epoll 区别总结：&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;底层实现&quot;&gt;底层实现&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;select/poll&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他俩没多大本质区别，都是用线性结构</summary>
      
    
    
    
    
    <category term="IO" scheme="http://example.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>“索引的树结构”</title>
    <link href="http://example.com/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/"/>
    <id>http://example.com/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/</id>
    <published>2022-03-13T06:58:51.000Z</published>
    <updated>2022-03-23T13:39:09.390Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="查找结构的进化">查找结构的进化</span></h3><p>二分查找</p><p>二叉树</p><p>二叉平衡树</p><p>B-TREE ：二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小</p><p>缺点：业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及 CPU 高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。</p><p>B+TREE：非叶子节点只保存索引数据，叶子节点保存索引数据与<strong>业务数据所在的地址</strong></p><h4><span id></span></h4><ol><li><p>B+数据量相同的情况下，非叶子节点可以存放更多的数据，B+树会更加矮胖，io次数会更少</p></li><li><p>B+树有大量的冗余节点（非叶子结点），会让B+树在插入删除时的效率更高</p></li><li><p>B+树的叶子结点用双向链表连了起来，有益于范围查询，而B树只能遍历。</p></li></ol><p><strong>聚簇索引和非聚簇索引</strong></p><p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p><p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」</p><h3><span id="查询数据的过程">查询数据的过程</span></h3><p><strong>在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</strong></p><p>磁盘IO</p><p><strong>磁盘处理太慢太慢了</strong></p><ul><li>尽量减少 I/O 次数，比如可以使用缓存；</li><li>每次 I/O 尽量获取更多的数据；</li><li>每次 I/O 尽量获取有用的数据，当然相应的也间接减少总 I/O 次数</li></ul><p>总结：</p><ul><li>数据存储在磁盘（ SSD 跟 CPU 性能也不在一个量级），而磁盘处理数据很慢；</li><li>提高磁盘性能主要通过减少 I/O 次数，以及单次 I/O 有效数据量；</li><li>索引通过多阶（一个节点保存多个数据，指向多个子节点）使树的结构更矮胖，从而减少 I/O 次数；</li><li>索引通过 B+ 树，把业务数据与索引数据分离，来提高单次 I/O 有效数据量，从而减少 I/O 次数；</li><li>索引通过树数据的有序和「二分查找」（多阶树可以假设为多分查找），大大缩小查询范围；</li><li>索引针对的是单个字段或部分字段，数据量本身比一条记录的数据量要少的多，这样即使通过扫描的方式查询索引也比扫描数据库表本身快的多；</li></ul><h2><span id="事务">事务</span></h2><ul><li>持久性是通过 redo log （重做日志）来保证的；是物理日志，记录做了什么修改</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>一致性是binlog保证的 ，逻辑日志（有三种格式）statement，row包含操作的具体数据，mixed</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； </li></ul><h2><span id="死锁问题">死锁问题</span></h2><p>处理订单业务时，需要用到select…for update用来避免并发导致的幻读问题，但是这样的话就容易出现死锁</p><p>处理方法是破坏形成死锁的条件：<strong>打破循环等待条件</strong></p><ul><li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li></ul><ul><li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><h2><span id="关于count">关于count</span></h2><p><img src="/2022/03/13/%E2%80%9C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E2%80%9D/image-20220314151059566.png" alt="image-20220314151059566"></p><p>*<em>count(1)、 count(</em>)、 count(主键字段)**在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段)  来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p><h3><span id="优化count">优化count</span></h3><p>如果数据量很大，因为要全表扫描，所以也要花费不短的时间</p><p>1.使用explain 出现的rows 字段值就是  explain 命令对表 t_order 记录的估算值。</p><p>2.额外表保存记录值</p><h2><span id></span></h2><h2><span id="索引失效的情况"><strong>索引失效的情况</strong></span></h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;查找结构的进化&quot;&gt;查找结构的进化&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;二分查找&lt;/p&gt;
&lt;p&gt;二叉树&lt;/p&gt;
&lt;p&gt;二叉平衡树&lt;/p&gt;
&lt;p&gt;B-TREE ：二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小&lt;/p&gt;
&lt;p&gt;缺点</summary>
      
    
    
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>innoDB对MVCC的实现</title>
    <link href="http://example.com/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-02-27T13:25:19.000Z</published>
    <updated>2022-03-13T13:49:43.689Z</updated>
    
    <content type="html"><![CDATA[<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见</p><p>这里用到了隐藏字段</p><p><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。</p><p><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</p><p>若聚簇索引记录DB_TRX_ID小于事务id则可见，如果不可见，则根据DB_ROLL_PTR取出快照记录的DB_TRX_ID再进行循环判断。</p><p><img src="/2022/02/27/innoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20220227212834866.png" alt="image-20220227212834866"></p><p>实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <strong>Next-key Lock</strong> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h3><span id="对于读已提交和重复读">对于读已提交和重复读</span></h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li></ul><p>然后根据数据可见性算法，导致RC的问题为不可重复读，RR解决了不可重复读</p><p>详细实现：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496769&idx=1&sn=30990d141185303fd0c7ecf63c125b30&chksm=f98db0ebcefa39fda085edb2596398c046541851d9650a7a8328874476984e4caac1055c4c68&scene=178&cur_album_id=1955634887135199237#rd">消失的 100 万，炸了！ (qq.com)</a></p><p>–参考JavaGuide</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;存储引擎在 RR 级别下通过 &lt;code&gt;MVCC&lt;/code&gt;和 &lt;code&gt;Next-key Lock&lt;/code&gt; 来解决幻读问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、执行普通 &lt;code&gt;select&lt;/code&gt;，此时会以 &lt;</summary>
      
    
    
    
    
    <category term="MySql" scheme="http://example.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>time_wait和close_wait</title>
    <link href="http://example.com/2022/02/27/time-wait%E5%92%8Cclose-wait/"/>
    <id>http://example.com/2022/02/27/time-wait%E5%92%8Cclose-wait/</id>
    <published>2022-02-27T11:13:12.000Z</published>
    <updated>2022-02-27T11:35:20.424Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/27/time-wait%E5%92%8Cclose-wait/image-20220227192546623.png" alt="image-20220227192546623"></p><p>客户端和服务器并不固定，看谁主动断开连接</p><h2><span id="time_wait">time_wait</span></h2><p>HTTP的交互跟上面画的那个图是不一样的，关闭连接的不是客户端，而是服务器，所以web服务器也是会出现大量的TIME_WAIT的情况的。</p><p>HTTP协议1.1版规定default行为是Keep-Alive，也就是会重用TCP连接传输多个 request/response，一个主要原因就是发现了这个问题</p><p>解决思路很简单，就是让服务器能够快速回收和重用那些TIME_WAIT的资源</p><p>对/etc/sysctl.conf文件进行修改</p><p>net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。</p><p>net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。</p><p>net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。</p><h2><span id="close_wait">close_wait</span></h2><p>从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p><p>将大量CLOSE_WAIT的解决办法总结为一句话那就是：查代码。因为问题出在服务器程序里头</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/02/27/time-wait%E5%92%8Cclose-wait/image-20220227192546623.png&quot; alt=&quot;image-20220227192546623&quot;&gt;&lt;/p&gt;
&lt;p&gt;客户端和服务器并不固定，看谁主动断开连</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring知识点整理</title>
    <link href="http://example.com/2022/02/27/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2022/02/27/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-02-27T09:02:14.000Z</published>
    <updated>2022-02-27T12:23:58.426Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="spring-ioc-amp-aop">Spring IOC &amp; AOP</span></h2><p><strong>IoC（Inverse of Control:控制反转）</strong> </p><p>是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p><p>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p><strong>AOP</strong>（面相切面编程）</p><p>基于动态代理的，根据要代理的对象是否实现接口来判断是使用JDK代理还是CGlib代理</p><h2><span id="bean的线程问题">Bean的线程问题</span></h2><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。    </p><p>解决办法：</p><ol><li>​    避免在bean中定义可变的成员变量</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中</li></ol><h2><span id="bean的生命周期">Bean的生命周期</span></h2><p>Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期</p><p>由两组回调（call back）方法组成。</p><p>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：</p><p> InitializingBean 和 DisposableBean 回调接口</p><p> 针对特殊行为的其他 Aware 接口</p><p> Bean 配置文件中的 Custom init()方法和 destroy()方法</p><p> @PostConstruct 和@PreDestroy 注解方式</p><h2><span id="springbean的自动装配">SpringBean的自动装配</span></h2><p>Spring 容器可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系</p><h3><span id="如何开启基于注解的自动装配"><strong>如何开启基于注解的自动装配？</strong></span></h3><p>两种方式</p><p>1、引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a></bean></p><pre><code class="java">&lt;beans&gt;  &lt;context:annotation-config /&gt; &lt;/beans&gt; </code></pre><p>2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor</p><pre><code class="java">&lt;beans&gt;  &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt; &lt;/beans&gt;</code></pre><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件中</p><h3><span id="autowired">@Autowired</span></h3><p>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。</p><h3><span id="qualifier">@Qualifier</span></h3><pre><code>&lt;bean id=&quot;customer&quot; class=&quot;com.somnus.common.Customer&quot; /&gt;  &lt;bean id=&quot;personA&quot; class=&quot;com.somnus.common.Person&quot; &gt;  &lt;property name=&quot;name&quot; value=&quot;lokesh&quot; /&gt; &lt;/bean&gt;  &lt;bean id=&quot;personB&quot; class=&quot;com.somnus.common.Person&quot; &gt;  &lt;property name=&quot;name&quot; value=&quot;alex&quot; /&gt; &lt;/bean&gt; </code></pre><pre><code>public class Customer&#123;  @Autowired  @Qualifier(&quot;personA&quot;)  private Person person; &#125; </code></pre><p>给Spring指定自动装配哪个bean</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;spring-ioc-amp-aop&quot;&gt;Spring IOC &amp;amp; AOP&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;IoC（Inverse of Control:控制反转）&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;是一种设计思想，而不是一个具体的技</summary>
      
    
    
    
    <category term="Java进阶" scheme="http://example.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="spring boot学习" scheme="http://example.com/categories/Java%E8%BF%9B%E9%98%B6/spring-boot%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList扩容机制</title>
    <link href="http://example.com/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
    <published>2022-02-09T04:55:59.000Z</published>
    <updated>2022-02-09T05:10:28.217Z</updated>
    
    <content type="html"><![CDATA[<p>源码解析：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb</a></p><h1><span id="1构造函数">1.构造函数</span></h1><p>有三种</p><p><img src="/2022/02/09/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/image-20220209130002676.png" alt="image-20220209130002676"></p><p>说第一种无参构造，默认初始容量为10</p><h1><span id="2add函数">2.add函数</span></h1><pre><code class="java">    /**     * 将指定的元素追加到此列表的末尾。     */    public boolean add(E e) &#123;   //添加元素之前，先调用ensureCapacityInternal方法        ensureCapacityInternal(size + 1);  // Increments modCount!!        //这里看到ArrayList添加元素的实质就相当于为数组赋值        elementData[size++] = e;        return true;    &#125;</code></pre><p>进入add方法后调用<strong>ensureCapacityInternal</strong> 方法，进入<strong>ensureCapacityInternal</strong>方法后初始化容量，然后调用<strong>ensureExplicitCapacity</strong>判断是否需要扩容，</p><p>，<strong>grow</strong>方法是实现扩容的方法，需要扩容则扩大1.5位，使用位运算。然后调用<strong>Arrays.copyOf</strong>方法将<strong>elementData</strong>数组指向新的内存空间<strong>newCapacity</strong>的连续空间<br>从此方法中我们可以清晰的看出其实<strong>ArrayList</strong>扩容的本质就是计算出新的扩容数组的<strong>size</strong>后实例化，并将原有数组内容复制到新数组中去。</p><pre><code class="java">  //得到最小扩容量    private void ensureCapacityInternal(int minCapacity) &#123;        //第二次调用ensureCapacityInternal方法后if判断后为假，因为不是空数组了        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;              // 获取默认的容量和传入参数的较大值            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);        &#125;        ensureExplicitCapacity(minCapacity);    &#125;  //判断是否需要扩容    private void ensureExplicitCapacity(int minCapacity) &#123;        modCount++;        // overflow-conscious code        if (minCapacity - elementData.length &gt; 0)            //调用grow方法进行扩容，调用此方法代表已经开始扩容了            grow(minCapacity);    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码解析：&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba</summary>
      
    
    
    
    <category term="javase" scheme="http://example.com/categories/javase/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2022/01/28/JVM/"/>
    <id>http://example.com/2022/01/28/JVM/</id>
    <published>2022-01-28T04:05:46.000Z</published>
    <updated>2022-02-12T09:00:06.829Z</updated>
    
    <content type="html"><![CDATA[<hr><h1><span id="jvm">JVM</span></h1><h2><span id="一-什么是jvm">一、什么是JVM</span></h2><h3><span id="定义">定义</span></h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3><span id="好处">好处</span></h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3><span id="比较">比较</span></h3><p>JVM JRE JDK的区别</p><p><img src="/2022/01/28/JVM/image-20220128120907409.png" alt="image-20220128120907409"></p><h2><span id="二-内存结构">二、内存结构</span></h2><h3><span id="整体架构"><strong>整体架构</strong></span></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p><h3><span id="1-程序计数器">1、程序计数器</span></h3><h4><span id="作用">作用</span></h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4><span id="特点">特点</span></h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3><span id="2-虚拟机栈">2、虚拟机栈</span></h3><h4><span id="定义">定义</span></h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>（栈顶部的第一个方法）</li></ul><h4><span id="演示">演示</span></h4><p>代码</p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        method1();    &#125;    private static void method1() &#123;        method2(1, 2);    &#125;    private static int method2(int a, int b) &#123;        int c = a + b;        return c;    &#125;&#125;Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4><span id="问题辨析">问题辨析</span></h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>看变量是被线程私有还是共享，共享则不安全</li><li>看变量的作用范围</li><li><img src="/2022/01/28/JVM/image-20220202214904660.png" alt="image-20220202214904660"></li></ul></li></ul><h4><span id="内存溢出">内存溢出</span></h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4><span id="线程运行诊断">线程运行诊断</span></h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3><span id="3-本地方法栈">3、本地方法栈</span></h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3><span id="4-堆">4、堆</span></h3><h4><span id="定义">定义</span></h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4><span id="特点">特点</span></h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4><span id="堆内存溢出">堆内存溢出</span></h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4><span id="堆内存诊断">堆内存诊断</span></h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3><span id="5-方法区">5、方法区</span></h3><h4><span id="结构">结构</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p><h4><span id="内存溢出">内存溢出</span></h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4><span id="常量池">常量池</span></h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre><code>F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.javaCopy</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre><code>javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="/2022/01/28/JVM/image-20220203213504873.png" alt="image-20220203213504873"></p></li><li><p>常量池</p><p><img src="/2022/01/28/JVM/image-20220203213602701.png" alt="image-20220203213602701"></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><img src="/2022/01/28/JVM/image-20220203213712499.png" alt="image-20220203213712499"></p></li></ul></li></ul><h4><span id="运行时常量池">运行时常量池</span></h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4><span id="常量池与串池的关系">常量池与串池的关系</span></h4><h5><span id="串池stringtable"><strong>串池</strong>StringTable</span></h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><pre><code class="java">public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;         String b = &quot;b&quot;;        String ab = &quot;ab&quot;;    &#125;&#125;Copy</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="java">0: ldc           #2                  // String a2: astore_13: ldc           #3                  // String b5: astore_26: ldc           #4                  // String ab8: astore_39: returnCopy</code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code>public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;        String b = &quot;b&quot;;        String ab = &quot;ab&quot;;        //拼接字符串对象来创建新的字符串        String ab2 = a+b;     &#125;&#125;Copy</code></pre><p>反编译后的结果</p><pre><code class="java">     Code:      stack=2, locals=5, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        29: returnCopy</code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="java">String ab = &quot;ab&quot;;String ab2 = a+b;//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中System.out.println(ab == ab2);Copy</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="java">public class StringTableStudy &#123;    public static void main(String[] args) &#123;        String a = &quot;a&quot;;        String b = &quot;b&quot;;        String ab = &quot;ab&quot;;        String ab2 = a+b;        //使用拼接字符串的方法创建字符串        String ab3 = &quot;a&quot; + &quot;b&quot;;    &#125;&#125;Copy</code></pre><p>反编译后的结果</p><pre><code class="java">       Code:      stack=2, locals=6, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        //ab3初始化时直接从串池中获取字符串        29: ldc           #4                  // String ab        31: astore        5        33: returnCopy</code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5><span id="intern方法-18">intern方法 1.8</span></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);        //调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象        String st2 = str.intern();        //给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回        String str3 = &quot;ab&quot;;        //因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true        System.out.println(str == st2);        System.out.println(str == str3);    &#125;&#125;Copy</code></pre><p><strong>例2</strong></p><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        //此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中        String str3 = &quot;ab&quot;;        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);        //此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;        String str2 = str.intern();        //false        System.out.println(str == str2);        //false        System.out.println(str == str3);        //true        System.out.println(str2 == str3);    &#125;&#125;Copy</code></pre><h5><span id="intern方法-16">intern方法 1.6</span></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4><span id="stringtable-垃圾回收">StringTable 垃圾回收</span></h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4><span id="stringtable调优">StringTable调优</span></h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><pre><code>-XX:StringTableSize=xxxxCopy</code></pre></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3><span id="6-直接内存">6、直接内存</span></h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4><span id="文件读写流程">文件读写流程</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4><span id="释放原理">释放原理</span></h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code>//通过ByteBuffer申请1M的直接内存ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);Copy</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><pre><code>public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;Copy</code></pre><p>DirectByteBuffer类</p><pre><code>DirectByteBuffer(int cap) &#123;   // package-private       super(-1, 0, cap, cap);    boolean pa = VM.isDirectMemoryPageAligned();    int ps = Bits.pageSize();    long size = Math.max(1L, (long)cap + (pa ? ps : 0));    Bits.reserveMemory(size, cap);    long base = 0;    try &#123;        base = unsafe.allocateMemory(size); //申请内存    &#125; catch (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        throw x;    &#125;    unsafe.setMemory(base, size, (byte) 0);    if (pa &amp;&amp; (base % ps != 0)) &#123;        // Round up to page boundary        address = base + ps - (base &amp; (ps - 1));    &#125; else &#123;        address = base;    &#125;    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象    att = null;&#125;Copy</code></pre><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><pre><code>public void clean() &#123;       if (remove(this)) &#123;           try &#123;               this.thunk.run(); //调用run方法           &#125; catch (final Throwable var2) &#123;               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                   public Void run() &#123;                       if (System.err != null) &#123;                           (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();                       &#125;                       System.exit(1);                       return null;                   &#125;               &#125;);           &#125;Copy</code></pre><p>对应对象的run方法</p><pre><code>public void run() &#123;    if (address == 0) &#123;        // Paranoia        return;    &#125;    unsafe.freeMemory(address); //释放直接内存中占用的内存    address = 0;    Bits.unreserveMemory(size, capacity);&#125;Copy</code></pre><h5><span id="直接内存的回收机制总结">直接内存的回收机制总结</span></h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2><span id="三-垃圾回收">三、垃圾回收</span></h2><h3><span id="1-如何判断对象可以回收">1、如何判断对象可以回收</span></h3><h4><span id="引用计数法">引用计数法</span></h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p><h4><span id="可达性分析算法">可达性分析算法</span></h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4><span id="五种引用">五种引用</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p><h5><span id="强引用">强引用</span></h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5><span id="软引用">软引用</span></h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6><span id="软引用的使用">软引用的使用</span></h6><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        final int _4M = 4*1024*1024;        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);    &#125;&#125;Copy</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        final int _4M = 4*1024*1024;        //使用引用队列，用于移除引用为空的软引用对象        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);        //遍历引用队列，如果有元素，则移除        Reference&lt;? extends byte[]&gt; poll = queue.poll();        while(poll != null) &#123;            //引用队列不为空，则从集合中移除该元素            list.remove(poll);            //移动到引用队列中的下一个元素            poll = queue.poll();        &#125;    &#125;&#125;Copy</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5><span id="弱引用">弱引用</span></h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5><span id="虚引用"><strong>虚引用</strong></span></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5><span id="终结器引用">终结器引用</span></h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5><span id="引用队列">引用队列</span></h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3><span id="2-垃圾回收算法">2、垃圾回收算法</span></h3><h4><span id="标记-清除">标记-清除</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4><span id="标记-整理">标记-整理</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4><span id="复制">复制</span></h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3><span id="3-分代回收">3、分代回收</span></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p><h4><span id="回收流程">回收流程</span></h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4><span id="gc-分析">GC 分析</span></h4><h5><span id="大对象处理策略">大对象处理策略</span></h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5><span id="线程内存溢出">线程内存溢出</span></h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3><span id="4-垃圾回收器">4、垃圾回收器</span></h3><h4><span id="相关概念">相关概念</span></h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4><span id="串行">串行</span></h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5><span id="serial-收集器">Serial 收集器</span></h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5><span id="parnew-收集器">ParNew 收集器</span></h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5><span id="serial-old-收集器">Serial Old 收集器</span></h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4><span id="吞吐量优先">吞吐量优先</span></h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p><h5><span id="parallel-scavenge-收集器">Parallel Scavenge 收集器</span></h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5><span id="parallel-old-收集器"><strong>Parallel Old 收集器</strong></span></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4><span id="响应时间优先">响应时间优先</span></h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p><h5><span id="cms-收集器">CMS 收集器</span></h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4><span id="g1">G1</span></h4><h5><span id="定义"><strong>定义</strong>：</span></h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p><h5><span id="适用场景">适用场景</span></h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p><h5><span id="g1垃圾回收阶段">G1垃圾回收阶段</span></h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5><span id="young-collection">Young Collection</span></h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p><h5><span id="young-collection-cm">Young Collection + CM</span></h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p><h5><span id="mixed-collection">Mixed Collection</span></h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p><h5><span id="full-gc">Full GC</span></h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5><span id="young-collection-跨代引用">Young Collection 跨代引用</span></h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p><h5><span id="remark">Remark</span></h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p><h5><span id="jdk-8u20-字符串去重">JDK 8u20 字符串去重</span></h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5><span id="jdk-8u40-并发标记类卸载">JDK 8u40 并发标记类卸载</span></h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5><span id="jdk-8u60-回收巨型对象">JDK 8u60 回收巨型对象</span></h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p><h3><span id="5-gc-调优">5、GC 调优</span></h3><p>查看虚拟机参数命令</p><pre><code>&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;Copy</code></pre><p>可以根据参数去查询具体的信息</p><h4><span id="调优领域">调优领域</span></h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4><span id="确定目标">确定目标</span></h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4><span id="最快的gc是不发生gc">最快的GC是不发生GC</span></h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4><span id="新生代调优">新生代调优</span></h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4><span id="幸存区调优">幸存区调优</span></h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4><span id="老年代调优">老年代调优</span></h4><h2><span id="四-类加载与字节码技术">四、类加载与字节码技术</span></h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p><h3><span id="1-类文件结构">1、类文件结构</span></h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><pre><code>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 640000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14Copy</code></pre><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><pre><code>u4              magicu2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-1];    u2             access_flags;    u2             this_class;    u2             super_class;   u2             interfaces_count;    u2             interfaces[interfaces_count];   u2             fields_count;    field_info     fields[fields_count];   u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];Copy</code></pre><h4><span id="魔数">魔数</span></h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4><span id="版本">版本</span></h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4><span id="常量池">常量池</span></h4><p>见资料文件</p><p>…略</p><h3><span id="2-字节码指令">2、字节码指令</span></h3><p>可参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4><span id="javap工具">javap工具</span></h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code>javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopyF:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified 2020-6-6; size 434 bytes  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from &quot;Demo1.java&quot;public class com.nyima.JVM.day5.Demo1  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #18            // hello world   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #21            // com/nyima/JVM/day5/Demo1   #6 = Class              #22            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               ([Ljava/lang/String;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #16 = Class              #23            // java/lang/System  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;  #18 = Utf8               hello world  #19 = Class              #26            // java/io/PrintStream  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/String;)V&#123;  public com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #3                  // String hello world         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 9: 0        line 10: 8&#125;Copy</code></pre><h4><span id="图解方法执行流程">图解方法执行流程</span></h4><p>代码</p><pre><code>public class Demo3_1 &#123;        public static void main(String[] args) &#123;                int a = 10;                int b = Short.MAX_VALUE + 1;                int c = a + b;                System.out.println(c);       &#125; &#125;Copy</code></pre><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><pre><code>a = 10Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4><span id="通过字节码指令来分析问题">通过字节码指令来分析问题</span></h4><p>代码</p><pre><code>public class Demo2 &#123;    public static void main(String[] args) &#123;        int i=0;        int x=0;        while(i&lt;10) &#123;            x = x++;            i++;        &#125;        System.out.println(x); //接过为0    &#125;&#125;Copy</code></pre><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><pre><code>Code:     stack=2, locals=3, args_size=1    //操作数栈分配2个空间，局部变量表分配3个空间        0: iconst_0    //准备一个常数0        1: istore_1    //将常数0放入局部变量表的1号槽位 i=0        2: iconst_0    //准备一个常数0        3: istore_2    //将常数0放入局部变量的2号槽位 x=0            4: iload_1        //将局部变量表1号槽位的数放入操作数栈中        5: bipush        10    //将数字10放入操作数栈中，此时操作数栈中有2个数        7: if_icmpge     21    //比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空       10: iload_2        //将局部变量2号槽位的数放入操作数栈中，放入的值是0       11: iinc          2, 1    //将局部变量2号槽位的数加1，自增后，槽位中的值为1       14: istore_2    //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0       15: iinc          1, 1 //1号槽位的值自增1       18: goto          4 //跳转到第4条指令       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       24: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       28: returnCopy</code></pre><h4><span id="构造方法">构造方法</span></h4><h5><span id="cinitv">cinit()V</span></h5><pre><code>public class Demo3 &#123;    static int i = 10;    static &#123;        i = 20;    &#125;    static &#123;        i = 30;    &#125;    public static void main(String[] args) &#123;        System.out.println(i); //结果为30    &#125;&#125;Copy</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><pre><code>stack=1, locals=0, args_size=0         0: bipush        10         2: putstatic     #3                  // Field i:I         5: bipush        20         7: putstatic     #3                  // Field i:I        10: bipush        30        12: putstatic     #3                  // Field i:I        15: returnCopy</code></pre><h5><span id="initv">init()V</span></h5><pre><code>public class Demo4 &#123;    private String a = &quot;s1&quot;;    &#123;        b = 20;    &#125;    private int b = 10;    &#123;        a = &quot;s2&quot;;    &#125;    public Demo4(String a, int b) &#123;        this.a = a;        this.b = b;    &#125;    public static void main(String[] args) &#123;        Demo4 d = new Demo4(&quot;s3&quot;, 30);        System.out.println(d.a);        System.out.println(d.b);    &#125;&#125;Copy</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><pre><code>Code:     stack=2, locals=3, args_size=3        0: aload_0        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V        4: aload_0        5: ldc           #2                  // String s1        7: putfield      #3                  // Field a:Ljava/lang/String;       10: aload_0       11: bipush        20       13: putfield      #4                  // Field b:I       16: aload_0       17: bipush        10       19: putfield      #4                  // Field b:I       22: aload_0       23: ldc           #5                  // String s2       25: putfield      #3                  // Field a:Ljava/lang/String;       //原始构造方法在最后执行       28: aload_0       29: aload_1       30: putfield      #3                  // Field a:Ljava/lang/String;       33: aload_0       34: iload_2       35: putfield      #4                  // Field b:I       38: returnCopy</code></pre><h4><span id="方法调用">方法调用</span></h4><pre><code>public class Demo5 &#123;    public Demo5() &#123;    &#125;    private void test1() &#123;    &#125;    private final void test2() &#123;    &#125;    public void test3() &#123;    &#125;    public static void test4() &#123;    &#125;    public static void main(String[] args) &#123;        Demo5 demo5 = new Demo5();        demo5.test1();        demo5.test2();        demo5.test3();        Demo5.test4();    &#125;&#125;Copy</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><pre><code>Code:      stack=2, locals=2, args_size=1         0: new           #2                  // class com/nyima/JVM/day5/Demo5          3: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: aload_1         9: invokespecial #4                  // Method test1:()V        12: aload_1        13: invokespecial #5                  // Method test2:()V        16: aload_1        17: invokevirtual #6                  // Method test3:()V        20: invokestatic  #7                  // Method test4:()V        23: returnCopy</code></pre><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4><span id="多态原理">多态原理</span></h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4><span id="异常处理">异常处理</span></h4><h5><span id="try-catch">try-catch</span></h5><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125;catch (Exception e) &#123;            i = 20;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码指令</p><pre><code>Code:     stack=1, locals=3, args_size=1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          12        8: astore_2        9: bipush        20       11: istore_1       12: return     //多出来一个异常表     Exception table:        from    to  target type            2     5     8   Class java/lang/ExceptionCopy</code></pre><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5><span id="多个single-catch">多个single-catch</span></h5><pre><code>public class Demo1 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125;catch (ArithmeticException e) &#123;            i = 20;        &#125;catch (Exception e) &#123;            i = 30;        &#125;    &#125;&#125;Copy</code></pre><p>对应的字节码</p><pre><code>Code:     stack=1, locals=3, args_size=1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          19        8: astore_2        9: bipush        20       11: istore_1       12: goto          19       15: astore_2       16: bipush        30       18: istore_1       19: return     Exception table:        from    to  target type            2     5     8   Class java/lang/ArithmeticException            2     5    15   Class java/lang/ExceptionCopy</code></pre><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5><span id="finally">finally</span></h5><pre><code>public class Demo2 &#123;    public static void main(String[] args) &#123;        int i = 0;        try &#123;            i = 10;        &#125; catch (Exception e) &#123;            i = 20;        &#125; finally &#123;            i = 30;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=4, args_size=1        0: iconst_0        1: istore_1        //try块        2: bipush        10        4: istore_1        //try块执行完后，会执行finally            5: bipush        30        7: istore_1        8: goto          27       //catch块            11: astore_2 //异常信息放入局部变量表的2号槽位       12: bipush        20       14: istore_1       //catch块执行完后，会执行finally               15: bipush        30       17: istore_1       18: goto          27       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码          21: astore_3       22: bipush        30       24: istore_1       25: aload_3       26: athrow  //抛出异常       27: return     Exception table:        from    to  target type            2     5    11   Class java/lang/Exception            2     5    21   any           11    15    21   anyCopy</code></pre><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5><span id="finally中的return">finally中的return</span></h5><pre><code>public class Demo3 &#123;    public static void main(String[] args) &#123;        int i = Demo3.test();        //结果为20        System.out.println(i);    &#125;    public static int test() &#123;        int i;        try &#123;            i = 10;            return i;        &#125; finally &#123;            i = 20;            return i;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=3, args_size=0        0: bipush        10        2: istore_0        3: iload_0        4: istore_1  //暂存返回值        5: bipush        20        7: istore_0        8: iload_0        9: ireturn    //ireturn会返回操作数栈顶的整型值20       //如果出现异常，还是会执行finally块中的内容，没有抛出异常       10: astore_2       11: bipush        20       13: istore_0       14: iload_0       15: ireturn    //这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！     Exception table:        from    to  target type            0     5    10   anyCopy</code></pre><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5><span id="被吞掉的异常">被吞掉的异常</span></h5><pre><code>public class Demo3 &#123;   public static void main(String[] args) &#123;      int i = Demo3.test();      //最终结果为20      System.out.println(i);   &#125;   public static int test() &#123;      int i;      try &#123;         i = 10;         //这里应该会抛出异常         i = i/0;         return i;      &#125; finally &#123;         i = 20;         return i;      &#125;   &#125;&#125;Copy</code></pre><p>会发现打印结果为20，并未抛出异常</p><h5><span id="finally不带return">finally不带return</span></h5><pre><code>public class Demo4 &#123;    public static void main(String[] args) &#123;        int i = Demo4.test();        System.out.println(i);    &#125;    public static int test() &#123;        int i = 10;        try &#123;            return i;        &#125; finally &#123;            i = 20;        &#125;    &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=1, locals=3, args_size=0        0: bipush        10        2: istore_0 //赋值给i 10        3: iload_0    //加载到操作数栈顶        4: istore_1 //加载到局部变量表的1号位置        5: bipush        20        7: istore_0 //赋值给i 20        8: iload_1 //加载局部变量表1号位置的数10到操作数栈        9: ireturn //返回操作数栈顶元素 10       10: astore_2       11: bipush        20       13: istore_0       14: aload_2 //加载异常       15: athrow //抛出异常     Exception table:        from    to  target type            3     5    10   anyCopy</code></pre><h4><span id="synchronized">Synchronized</span></h4><pre><code>public class Demo5 &#123;    public static void main(String[] args) &#123;        int i = 10;        Lock lock = new Lock();        synchronized (lock) &#123;            System.out.println(i);        &#125;    &#125;&#125;class Lock&#123;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:     stack=2, locals=5, args_size=1        0: bipush        10        2: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V       10: astore_2 //剩下的一份放到局部变量表的2号位置       11: aload_2 //加载到操作数栈       12: dup //复制一份，放到操作数栈，用于加锁时消耗       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用       14: monitorenter //加锁       //锁住后代码块中的操作           15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       18: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       //加载局部变量表中三号槽位对象的引用，用于解锁           22: aload_3           23: monitorexit //解锁       24: goto          34       //异常操作           27: astore        4       29: aload_3       30: monitorexit //解锁       31: aload         4       33: athrow       34: return     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。           Exception table:        from    to  target type           15    24    27   any           27    31    27   anyCopy</code></pre><h3><span id="3-编译期处理">3、编译期处理</span></h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4><span id="默认构造函数">默认构造函数</span></h4><pre><code>public class Candy1 &#123;&#125;Copy</code></pre><p>经过编译期优化后</p><pre><code>public class Candy1 &#123;   //这个无参构造器是java编译器帮我们加上的   public Candy1() &#123;      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V      super();   &#125;&#125;Copy</code></pre><h4><span id="自动拆装箱">自动拆装箱</span></h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><pre><code>public class Demo2 &#123;   public static void main(String[] args) &#123;      Integer x = 1;      int y = x;   &#125;&#125;Copy</code></pre><p>转换过程如下</p><pre><code>public class Demo2 &#123;   public static void main(String[] args) &#123;      //基本类型赋值给包装类型，称为装箱      Integer x = Integer.valueOf(1);      //包装类型赋值给基本类型，称谓拆箱      int y = x.intValue();   &#125;&#125;Copy</code></pre><h4><span id="泛型集合取值">泛型集合取值</span></h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><pre><code>public class Demo3 &#123;   public static void main(String[] args) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      list.add(10);      Integer x = list.get(0);   &#125;&#125;Copy</code></pre><p>对应字节码</p><pre><code>Code:    stack=2, locals=3, args_size=1       0: new           #2                  // class java/util/ArrayList       3: dup       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V       7: astore_1       8: aload_1       9: bipush        10      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      //这里进行了泛型擦除，实际调用的是add(Objcet o)      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      19: pop      20: aload_1      21: iconst_0      //这里也进行了泛型擦除，实际调用的是get(Object o)         22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;//这里进行了类型转换，将Object转换成了Integer      27: checkcast     #7                  // class java/lang/Integer      30: astore_2      31: returnCopy</code></pre><p>所以调用get函数取值时，有一个类型转换的操作</p><pre><code>Integer x = (Integer) list.get(0);Copy</code></pre><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><pre><code>int x = (Integer) list.get(0).intValue();Copy</code></pre><h4><span id="可变参数">可变参数</span></h4><pre><code>public class Demo4 &#123;   public static void foo(String... args) &#123;      //将args赋值给arr，可以看出String...实际就是String[]       String[] arr = args;      System.out.println(arr.length);   &#125;   public static void main(String[] args) &#123;      foo(&quot;hello&quot;, &quot;world&quot;);   &#125;&#125;Copy</code></pre><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><pre><code>public class Demo4 &#123;   public Demo4 &#123;&#125;       public static void foo(String[] args) &#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   public static void main(String[] args) &#123;      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);   &#125;&#125;Copy</code></pre><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4><span id="foreach">foreach</span></h4><pre><code>public class Demo5 &#123;    public static void main(String[] args) &#123;        //数组赋初值的简化写法也是一种语法糖。        int[] arr = &#123;1, 2, 3, 4, 5&#125;;        for(int x : arr) &#123;            System.out.println(x);        &#125;    &#125;&#125;Copy</code></pre><p>编译器会帮我们转换为</p><pre><code>public class Demo5 &#123;    public Demo5 &#123;&#125;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;        for(int i=0; i&lt;arr.length; ++i) &#123;            int x = arr[i];            System.out.println(x);        &#125;    &#125;&#125;Copy</code></pre><p><strong>如果是集合使用foreach</strong></p><pre><code>public class Demo5 &#123;   public static void main(String[] args) &#123;      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);      for (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;Copy</code></pre><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><pre><code>public class Demo5 &#123;    public Demo5 &#123;&#125;       public static void main(String[] args) &#123;      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);      //获得该集合的迭代器      Iterator&lt;Integer&gt; iterator = list.iterator();      while(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;Copy</code></pre><h4><span id="switch字符串">switch字符串</span></h4><pre><code>public class Demo6 &#123;   public static void main(String[] args) &#123;      String str = &quot;hello&quot;;      switch (str) &#123;         case &quot;hello&quot; :            System.out.println(&quot;h&quot;);            break;         case &quot;world&quot; :            System.out.println(&quot;w&quot;);            break;         default:            break;      &#125;   &#125;&#125;Copy</code></pre><p>在编译器中执行的操作</p><pre><code>public class Demo6 &#123;   public Demo6() &#123;         &#125;   public static void main(String[] args) &#123;      String str = &quot;hello&quot;;      int x = -1;      //通过字符串的hashCode+value来判断是否匹配      switch (str.hashCode()) &#123;         //hello的hashCode         case 99162322 :            //再次比较，因为字符串的hashCode有可能相等            if(str.equals(&quot;hello&quot;)) &#123;               x = 0;            &#125;            break;         //world的hashCode         case 11331880 :            if(str.equals(&quot;world&quot;)) &#123;               x = 1;            &#125;            break;         default:            break;      &#125;      //用第二个switch在进行输出判断      switch (x) &#123;         case 0:            System.out.println(&quot;h&quot;);            break;         case 1:            System.out.println(&quot;w&quot;);            break;         default:            break;      &#125;   &#125;&#125;Copy</code></pre><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4><span id="switch枚举">switch枚举</span></h4><pre><code>public class Demo7 &#123;   public static void main(String[] args) &#123;      SEX sex = SEX.MALE;      switch (sex) &#123;         case MALE:            System.out.println(&quot;man&quot;);            break;         case FEMALE:            System.out.println(&quot;woman&quot;);            break;         default:            break;      &#125;   &#125;&#125;enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><p>编译器中执行的代码如下</p><pre><code>public class Demo7 &#123;   /**         * 定义一个合成类（仅 jvm 使用，对我们不可见）         * 用来映射枚举的 ordinal 与数组元素的关系         * 枚举的 ordinal 表示枚举对象的序号，从 0 开始         * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1         */    static class $MAP &#123;      //数组大小即为枚举元素个数，里面存放了case用于比较的数字      static int[] map = new int[2];      static &#123;         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1         map[SEX.MALE.ordinal()] = 1;         map[SEX.FEMALE.ordinal()] = 2;      &#125;   &#125;   public static void main(String[] args) &#123;      SEX sex = SEX.MALE;      //将对应位置枚举元素的值赋给x，用于case操作      int x = $MAP.map[sex.ordinal()];      switch (x) &#123;         case 1:            System.out.println(&quot;man&quot;);            break;         case 2:            System.out.println(&quot;woman&quot;);            break;         default:            break;      &#125;   &#125;&#125;enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><h4><span id="枚举类">枚举类</span></h4><pre><code>enum SEX &#123;   MALE, FEMALE;&#125;Copy</code></pre><p>转换后的代码</p><pre><code>public final class Sex extends Enum&lt;Sex&gt; &#123;      //对应枚举类中的元素   public static final Sex MALE;       public static final Sex FEMALE;       private static final Sex[] $VALUES;       static &#123;               //调用构造函数，传入枚举元素的值及ordinal        MALE = new Sex(&quot;MALE&quot;, 0);            FEMALE = new Sex(&quot;FEMALE&quot;, 1);           $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;    &#125;        //调用父类中的方法    private Sex(String name, int ordinal) &#123;             super(name, ordinal);        &#125;       public static Sex[] values() &#123;          return $VALUES.clone();      &#125;    public static Sex valueOf(String name) &#123;         return Enum.valueOf(Sex.class, name);      &#125;    &#125;Copy</code></pre><h4><span id="匿名内部类">匿名内部类</span></h4><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(&quot;running...&quot;);         &#125;      &#125;;   &#125;&#125;Copy</code></pre><p>转换后的代码</p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      //用额外创建的类来创建匿名内部类对象      Runnable runnable = new Demo8$1();   &#125;&#125;//创建了一个额外的类，实现了Runnable接口final class Demo8$1 implements Runnable &#123;   public Demo8$1() &#123;&#125;   @Override   public void run() &#123;      System.out.println(&quot;running...&quot;);   &#125;&#125;Copy</code></pre><p>如果匿名内部类中引用了<strong>局部变量</strong></p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      int x = 1;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;Copy</code></pre><p>转化后代码</p><pre><code>public class Demo8 &#123;   public static void main(String[] args) &#123;      int x = 1;      Runnable runnable = new Runnable() &#123;         @Override         public void run() &#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;final class Demo8$1 implements Runnable &#123;   //多创建了一个变量   int val$x;   //变为了有参构造器   public Demo8$1(int x) &#123;      this.val$x = x;   &#125;   @Override   public void run() &#123;      System.out.println(val$x);   &#125;&#125;Copy</code></pre><h3><span id="4-类加载阶段">4、类加载阶段</span></h3><h4><span id="加载">加载</span></h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4><span id="链接">链接</span></h4><h5><span id="验证">验证</span></h5><p>验证类是否符合 JVM规范，安全性检查</p><h5><span id="准备">准备</span></h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5><span id="解析">解析</span></h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><pre><code>jpsCopy</code></pre><ul><li>打开HSDB</li></ul><pre><code>java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDBCopy</code></pre><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><pre><code>public class Demo1 &#123;   public static void main(String[] args) throws IOException, ClassNotFoundException &#123;      ClassLoader loader = Demo1.class.getClassLoader();      //只加载不解析      Class&lt;?&gt; c = loader.loadClass(&quot;com.nyima.JVM.day8.C&quot;);      //用于阻塞主线程      System.in.read();   &#125;&#125;class C &#123;   D d = new D();&#125;class D &#123;&#125;Copy</code></pre><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p><h4><span id="初始化">初始化</span></h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5><span id="发生时机">发生时机</span></h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3><span id="5-类加载器">5、类加载器</span></h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4><span id="类与类加载器">类与类加载器</span></h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4><span id="启动类加载器">启动类加载器</span></h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4><span id="拓展类加载器">拓展类加载器</span></h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4><span id="双亲委派模式">双亲委派模式</span></h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException&#123;    synchronized (getClassLoadingLock(name)) &#123;        // 首先查找该类是否已经被该类加载器加载过了        Class&lt;?&gt; c = findLoadedClass(name);        //如果没有被加载过        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null                if (parent != null) &#123;                    c = parent.loadClass(name, false);                &#125; else &#123;                    //看是否被启动类加载器加载过                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader                //捕获异常，但不做任何处理            &#125;            if (c == null) &#123;                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常                //然后让应用类加载器去找classpath下找该类                long t1 = System.nanoTime();                c = findClass(name);                // 记录时间                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;Copy</code></pre><h4><span id="自定义类加载器">自定义类加载器</span></h4><h5><span id="使用场景">使用场景</span></h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5><span id="步骤">步骤</span></h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4><span id="破坏双亲委派模式">破坏双亲委派模式</span></h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3><span id="6-运行期优化">6、运行期优化</span></h3><h4><span id="分层编译">分层编译</span></h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5><span id="即时编译器jit与解释器的区别">即时编译器（JIT）与解释器的区别</span></h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5><span id="逃逸分析">逃逸分析</span></h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4><span id="方法内联">方法内联</span></h4><h5><span id="内联函数"><strong>内联函数</strong></span></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5><span id="jvm内联函数"><strong>JVM内联函数</strong></span></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><pre><code>public final void doSomething() &#123;          // to do something  &#125;Copy</code></pre><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><pre><code>private int add4(int x1, int x2, int x3, int x4) &#123;         //这里调用了add2方法        return add2(x1, x2) + add2(x3, x4);      &#125;      private int add2(int x1, int x2) &#123;          return x1 + x2;      &#125;Copy</code></pre><p>方法调用被替换后</p><pre><code>private int add4(int x1, int x2, int x3, int x4) &#123;          //被替换为了方法本身        return x1 + x2 + x3 + x4;      &#125;Copy</code></pre><h4><span id="反射优化">反射优化</span></h4><pre><code>public class Reflect1 &#123;   public static void foo() &#123;      System.out.println(&quot;foo...&quot;);   &#125;   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;      Method foo = Demo3.class.getMethod(&quot;foo&quot;);      for(int i = 0; i&lt;=16; i++) &#123;         foo.invoke(null);      &#125;   &#125;&#125;Copy</code></pre><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><pre><code>@CallerSensitivepublic Object invoke(Object obj, Object... args)    throws IllegalAccessException, IllegalArgumentException,       InvocationTargetException&#123;    if (!override) &#123;        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类    MethodAccessor ma = methodAccessor;             // read volatile    if (ma == null) &#123;        ma = acquireMethodAccessor();    &#125;    return ma.invoke(obj, args);&#125;Copy</code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><pre><code>class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;    private final Method method;    private DelegatingMethodAccessorImpl parent;    private int numInvocations;    NativeMethodAccessorImpl(Method var1) &#123;        this.method = var1;    &#125;        //每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一    //如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());            this.parent.setDelegate(var3);        &#125;        return invoke0(this.method, var1, var2);    &#125;    void setParent(DelegatingMethodAccessorImpl var1) &#123;        this.parent = var1;    &#125;    private static native Object invoke0(Method var0, Object var1, Object[] var2);&#125;Copy//ReflectionFactory.inflationThreshold()方法的返回值private static int inflationThreshold = 15;Copy</code></pre><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;&lt;span id=&quot;jvm&quot;&gt;JVM&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;一-什么是jvm&quot;&gt;一、什么是JVM&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;定义&quot;&gt;定义&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Java Virtual Machine，J</summary>
      
    
    
    
    <category term="Java进阶" scheme="http://example.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Stream流</title>
    <link href="http://example.com/2022/01/21/Stream%E6%B5%81/"/>
    <id>http://example.com/2022/01/21/Stream%E6%B5%81/</id>
    <published>2022-01-21T12:32:33.000Z</published>
    <updated>2022-01-23T04:28:06.851Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="stream流">Stream流</span></h1><p><strong>自我感觉是一流的形式传递操作，上一个操作返回的结果放到下一个</strong></p><p><strong>可以被用来对集合或数组进行链状流式的操作</strong></p><p>可以先写出匿名内部类的形式，然后再快捷转换为lambda表达式</p><p><strong>eg:</strong></p><pre><code class="java">// 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 getAuthors()         .stream()         .distinct()         .filter(author -&gt; author.getAge()&lt;18)         .forEach(author -&gt; System.out.println(author.getName()));</code></pre><h2><span id="操作种类">操作种类</span></h2><h3><span id="创建流">创建流</span></h3><pre><code class="java">//创建流,有两种方式public static void test01()&#123;    Integer[] list=&#123;1,2,3,4,5&#125;;    Stream&lt;Integer&gt; stream=Arrays.stream(list);    Stream&lt;Integer&gt; stream1 = Stream.of(list);    stream.distinct().filter(integer -&gt; integer&lt;3).forEach(integer -&gt; System.out.println(integer));    stream1.distinct().filter(integer -&gt; integer&lt;3).forEach(integer -&gt; System.out.println(integer));&#125;</code></pre><h3><span id="中间操作">中间操作</span></h3><h5><span id="filter">filter</span></h5><p>​    可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。</p><h5><span id="map">map</span></h5><p>​    可以把对流中的元素进行计算或转换。</p><pre><code class="java">public static void test03()&#123;    //输出作者的描述    getAuthors()            .stream()            .map(Author::getIntro)            .forEach(author-&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121213239914.png" alt="image-20220121213239914"></p><h5><span id="distinct">distinct</span></h5><p>​    可以去除流中的重复元素。</p><h5><span id="sorted">sorted</span></h5><p>​    可以对流中的元素进行排序，排序规则可自定义。</p><pre><code class="java">public static void test04()&#123;    //按年龄升序的顺序排列    getAuthors()            .stream()            .distinct()            .sorted(new Comparator&lt;Author&gt;() &#123;                @Override                public int compare(Author o1, Author o2) &#123;                    return o1.getAge()- o2.getAge();                &#125;            &#125;)            .forEach(author -&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121213640079.png" alt="image-20220121213640079"></p><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p><h5><span id="limit">limit</span></h5><p>​    可以设置流的最大长度，超出的部分将被抛弃。</p><pre><code class="java">//实现输出年龄最小的两个人public static void test05()&#123;    getAuthors()            .stream()            .distinct()            .sorted()//这里实体类实现了Comparable接口            .limit(2)            .forEach(author -&gt; System.out.println(author));&#125;</code></pre><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121214448565.png" alt="image-20220121214448565"></p><h5><span id="skip">skip</span></h5><p>​    跳过流中的前n个元素，返回剩下的元素</p><p>跳过年龄最小的</p><p><img src="/2022/01/21/Stream%E6%B5%81/image-20220121214634846.png" alt="image-20220121214634846"></p><h5><span id="flatmap">flatMap</span></h5><p>​    map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p><h3><span id="终结操作">终结操作</span></h3><h5><span id="foreach">forEach</span></h5><p>​    对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><h5><span id="count">count</span></h5><p>​    可以用来获取当前流中元素的个数。</p><p>例子：</p><p>​    打印这些作家的所出书籍的数目，注意删除重复元素。</p><pre><code class="java">//        打印这些作家的所出书籍的数目，注意删除重复元素。        List&lt;Author&gt; authors = getAuthors();        long count = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .distinct()                .count();        System.out.println(count);</code></pre><h5><span id="maxampmin">max&amp;min</span></h5><p>​    可以用来获取流中的最值。</p><p>例子：</p><p>​    分别获取这些作家的所出书籍的最高分和最低分并打印。</p><pre><code class="java">        public static void test09()&#123;        //    分别获取这些作家的所出书籍的最高分和最低分并打印。        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Integer&gt; max = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())                .max(new Comparator&lt;Integer&gt;() &#123;                    @Override                    public int compare(Integer o1, Integer o2) &#123;                        return o1-o2;                    &#125;                &#125;);        Optional&lt;Integer&gt; min = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())                .min((score1, score2) -&gt; score1 - score2);        System.out.println(max.get());        System.out.println(min.get());    &#125;</code></pre><h5><span id="collect">collect</span></h5><p>​    把当前流转换成一个集合。</p><p>例子：</p><p>​    获取一个存放所有作者名字的List集合。</p><pre><code class="java">public static void test10()&#123;        //        获取一个存放所有作者名字的List集合。        List&lt;Author&gt; authors=getAuthors();        List&lt;String&gt; names=authors.stream()                .distinct()                .map(author -&gt; author.getName())                .collect(Collectors.toList());        System.out.println(names);    &#125;</code></pre><p>​    获取一个所有书名的Set集合。</p><p><img src="/2022/01/21/Stream%E6%B5%81/Stream%E6%B5%81image-20220123122758892.png" alt="image-20220123122758892"></p><p>​    获取一个Map集合，map的key为作者名，value为List<book></book></p><pre><code class="java">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;        List&lt;Author&gt; authors = getAuthors();        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()                .distinct()                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));        System.out.println(map);</code></pre><h5><span id="查找与匹配">查找与匹配</span></h5><h6><span id="anymatch">anyMatch</span></h6><p>​    可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><p>例子：</p><p>​    判断是否有年龄在29以上的作家</p><pre><code class="java">//        判断是否有年龄在29以上的作家        List&lt;Author&gt; authors = getAuthors();        boolean flag = authors.stream()                .anyMatch(author -&gt; author.getAge() &gt; 29);        System.out.println(flag);</code></pre><h6><span id="allmatch">allMatch</span></h6><p>​    可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><p>例子：</p><p>​    判断是否所有的作家都是成年人</p><pre><code class="java">//        判断是否所有的作家都是成年人        List&lt;Author&gt; authors = getAuthors();        boolean flag = authors.stream()                .allMatch(author -&gt; author.getAge() &gt;= 18);        System.out.println(flag);</code></pre><h6><span id="nonematch">noneMatch</span></h6><p>​    可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p><p>例子：</p><p>​    判断作家是否都没有超过100岁的。</p><pre><code class="java">//        判断作家是否都没有超过100岁的。        List&lt;Author&gt; authors = getAuthors();        boolean b = authors.stream()                .noneMatch(author -&gt; author.getAge() &gt; 100);        System.out.println(b);</code></pre><h6><span id="findany">findAny</span></h6><p>​    获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​    获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><pre><code class="java">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; optionalAuthor = authors.stream()                .filter(author -&gt; author.getAge()&gt;18)                .findAny();        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre><h6><span id="findfirst">findFirst</span></h6><p>​    获取流中的第一个元素。</p><p>例子：</p><p>​    获取一个年龄最小的作家，并输出他的姓名。</p><pre><code class="java">//        获取一个年龄最小的作家，并输出他的姓名。        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; first = authors.stream()                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())                .findFirst();        first.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre><h5><span id="reduce归并">reduce归并</span></h5><p>​    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​    reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>​    reduce两个参数的重载形式内部的计算方式如下：</p><pre><code class="java">T result = identity;for (T element : this stream)    result = accumulator.apply(result, element)return result;</code></pre><p>​    其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p><p>例子：</p><p>​    使用reduce求所有作者年龄的和</p><pre><code class="java">//        使用reduce求所有作者年龄的和        List&lt;Author&gt; authors = getAuthors();        Integer sum = authors.stream()                .distinct()                .map(author -&gt; author.getAge())                .reduce(0, (result, element) -&gt; result + element);        System.out.println(sum);</code></pre><p>​    使用reduce求所有作者中年龄的最大值</p><pre><code class="java">//        使用reduce求所有作者中年龄的最大值        List&lt;Author&gt; authors = getAuthors();        Integer max = authors.stream()                .map(author -&gt; author.getAge())                .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);        System.out.println(max);</code></pre><p>​    使用reduce求所有作者中年龄的最小值</p><pre><code class="java">//        使用reduce求所有作者中年龄的最小值        List&lt;Author&gt; authors = getAuthors();        Integer min = authors.stream()                .map(author -&gt; author.getAge())                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);        System.out.println(min);</code></pre><p>​    reduce一个参数的重载形式内部的计算</p><pre><code class="java">      boolean foundAny = false;     T result = null;     for (T element : this stream) &#123;         if (!foundAny) &#123;             foundAny = true;             result = element;         &#125;         else             result = accumulator.apply(result, element);     &#125;     return foundAny ? Optional.of(result) : Optional.empty();</code></pre><p>​    如果用一个参数的重载方法去求最小值代码如下：</p><pre><code class="java">        //        使用reduce求所有作者中年龄的最小值        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Integer&gt; minOptional = authors.stream()                .map(author -&gt; author.getAge())                .reduce((result, element) -&gt; result &gt; element ? element : result);        minOptional.ifPresent(age-&gt; System.out.println(age));</code></pre><h3><span id="35-注意事项">3.5 注意事项</span></h3><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;stream流&quot;&gt;Stream流&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;自我感觉是一流的形式传递操作，上一个操作返回的结果放到下一个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以被用来对集合或数组进行链状流式的操作&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="Java进阶" scheme="http://example.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Stream" scheme="http://example.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://example.com/2022/01/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/01/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-20T02:06:23.000Z</published>
    <updated>2022-01-20T02:19:03.623Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1lambda表达式">1.Lambda表达式</span></h2><h3><span id="11核心原则">1.1核心原则</span></h3><blockquote><p>可推导可省略</p></blockquote><h3><span id="12基本格式">1.2基本格式</span></h3><pre><code>(参数列表)-&gt;&#123;d&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;1lambda表达式&quot;&gt;1.Lambda表达式&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;11核心原则&quot;&gt;1.1核心原则&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;可推导可省略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span</summary>
      
    
    
    
    
    <category term="java8" scheme="http://example.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>JAVASE</title>
    <link href="http://example.com/2022/01/20/JAVASE/"/>
    <id>http://example.com/2022/01/20/JAVASE/</id>
    <published>2022-01-20T01:59:25.000Z</published>
    <updated>2022-01-20T01:59:25.895Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="http://example.com/2022/01/17/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/01/17/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2022-01-17T03:04:24.000Z</published>
    <updated>2022-02-07T14:21:42.758Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220117114857930.png" alt="image-20220117114857930"></p><p>显示字符集编码</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220117121933893.png" alt="image-20220117121933893"></p><h1><span id="mysql架构">mysql架构</span></h1><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173346275.png" alt="image-20220125173346275"></p><h2><span id="逻辑架构">逻辑架构</span></h2><p><img src="https://img-blog.csdnimg.cn/20190311133729340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzQ1MTAy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>Client :</strong><br>提供连接MySQL服务器功能的常用工具集</li><li><strong>Server :</strong><br>MySQL实例，真正提供数据存储和数据处理功能的MySQL服务器进程</li><li><strong>mysqld:</strong><br>MySQL服务器守护程序，在后台运行。它管理着客户端请求。mysqld是一个多线程的进程，允许多个会话连接，端口监听连接，管理MySQL实例</li><li><strong>MySQL memory allocation:</strong><br>MySQL的要求的内存空间是动态的，比如 <code>innodb_buffer_pool_size (from 5.7.5), key_buffer_size</code>。每个会话都有独一无二的执行计划，我们只能共享同一会话域内的数据集。</li><li><strong>SESSION</strong><br>为每个客户端连接分配一个会话，动态分配和回收。用于查询处理，每个会话同时具备一个缓冲区。每个会话是作为一个线程执行的</li><li><strong>Parser</strong><br>检测SQL语句语法，为每条SQL语句生成<code>SQL_ID</code>，用户认证也发生在这个阶段</li><li><strong>Optimizer</strong><br>创造一个有效率的执行计划（根据具体的存储引擎）。它将会重写查询语句。比如：InnoDB有共享缓冲区，所以，优化器会首先从预先缓存的数据中提取。使用 table statistics optimizer将会为SQL查询生成一个执行计划。用户权限检查也发生在这个阶段。</li><li><strong>Metadata cache</strong><br>缓存对象元信息和统计信息</li><li><strong>Query cache</strong><br>共享在内存中的完全一样的查询语句。如果完全相同的查询在缓存命中，MySQL服务器会直接从缓存中去检索结果。缓存是会话间共享的，所以为一个客户生成的结果集也能为另一个客户所用。查询缓存基于<code>SQL_ID</code>。将SELECT语句写入视图就是查询缓存最好的例子。</li><li><strong>key cache</strong><br>缓存表索引。<code>MySQL keys</code>是索引。如果索引数据量小，它将缓存索引结构和叶子节点（存储索引数据）。如果索引很大，它只会缓存索引结构，通常供<strong>MyISAM存储引擎</strong>使用</li></ul><h2><span id="数据库引擎">数据库引擎：</span></h2><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173524623.png" alt="image-20220125173524623"></p><p>引擎对比：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125173746074.png" alt="image-20220125173746074"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220125174645385.png" alt="image-20220125174645385"></p><h2><span id="sql性能下降的原因">SQL性能下降的原因</span></h2><ul><li>查询语句写的差。</li><li>索引失效：索引建了，但是没有用上。</li><li>关联 查询太多<code>join</code>（设计缺陷或者不得已的需求）。</li><li>服务器调优以及各个参数的设置（缓冲、线程数等）。</li></ul><h2><span id="机读顺序">机读顺序</span></h2><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126104245756.png" alt="image-20220126104245756"></p><h2><span id="七种join理论">七种JOIN理论</span></h2><p><a href="https://camo.githubusercontent.com/86ddd9cb519bf327ca485e638dd17d8ec15e10778a6b1d85b7c6dfa54d553df1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313231323031313535392e6a70673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/86ddd9cb519bf327ca485e638dd17d8ec15e10778a6b1d85b7c6dfa54d553df1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313231323031313535392e6a70673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="七种JOIN理论"></a></p><pre><code class="sql">/* 1 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;/* 2 */SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;/* 3 */SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;/* 4 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;/* 5 */SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;/* 6 */SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.KeyUNIONSELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;/* 7 */SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;UNIONSELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</code></pre><p>训练：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112014110.png" alt="image-20220126112014110"></p><p>笛卡尔积</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112141713.png" alt="image-20220126112141713"></p><p>inner join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112509976.png" alt="image-20220126112509976"></p><p>left join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112649545.png" alt="image-20220126112649545"></p><p>right join</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126112731024.png" alt="image-20220126112731024"></p><p>返回所有记录</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220126113400563.png" alt="image-20220126113400563"></p><h2><span id></span></h2><h1><span id="索引">索引</span></h1><p>索引的本质：<strong>索引是排好序的快速查找数据结构。</strong></p><p><strong>重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！</strong></p><p><strong>除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</strong></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p><pre><code>Linux下查看磁盘空间命令 df -h </code></pre><pre><code class="shell">[root@VM-16-3-centos ~]# df -hFilesystem      Size  Used Avail Use% Mounted ondevtmpfs        908M     0  908M   0% /devtmpfs           919M   32K  919M   1% /dev/shmtmpfs           919M  624K  919M   1% /runtmpfs           919M     0  919M   0% /sys/fs/cgroup/dev/vda1        59G  7.4G   50G  14% /tmpfs           184M     0  184M   0% /run/user/0</code></pre><p>我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</p><blockquote><p>索引的优势和劣势</p></blockquote><p>优势：</p><ul><li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p>劣势：</p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li><li>虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。</li></ul><h2><span id="mysql索引分类">MySQL索引分类</span></h2><p>索引分类：</p><ul><li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引。</li><li>唯一索引：索引列的值必须唯一，但是允许空值。</li><li>复合索引：一个索引包含多个字段。</li></ul><p><strong>建议：一张表建的索引最好不要超过5个！</strong></p><pre><code class="sql">/* 基本语法 *//* 1、创建索引 [UNIQUE]可以省略*//* 如果只写一个字段就是单值索引，写多个字段就是复合索引 */CREATE [UNIQUE] INDEX indexName ON tabName(columnName(length));/* 2、删除索引 */DROP INDEX [indexName] ON tabName;/* 3、查看索引 *//* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 */SHOW INDEX FROM tabName \G;</code></pre><p>使用<code>ALTER</code>命令来为数据表添加索引</p><pre><code class="sql">/* 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL */ALTER TABLE tabName ADD PRIMARY KEY(column_list);/* 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次) */ALTER TABLE tabName ADD UNIQUE indexName(column_list);/* 3、该语句创建普通索引，索引值可以出现多次 */ALTER TABLE tabName ADD INDEX indexName(column_list);/* 4、该语句指定了索引为FULLTEXT，用于全文检索 */ALTER TABLE tabName ADD FULLTEXT indexName(column_list);</code></pre><h2><span id="mysql索引数据结构">MySQL索引数据结构</span></h2><p>索引数据结构：</p><ul><li><code>BTree</code>索引。</li><li><code>Hash</code>索引。</li><li><code>Full-text</code>全文索引。</li><li><code>R-Tree</code>索引。</li></ul><p><code>BTree</code>索引检索原理：</p><p><a href="https://camo.githubusercontent.com/585e16bba5e6911f7d81728ab9731894fd6631963a028f79d6f327d50109b42d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313233333133343933312e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/585e16bba5e6911f7d81728ab9731894fd6631963a028f79d6f327d50109b42d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830313233333133343933312e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c314a796157356e6231383d2c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="BTree"></a></p><h2><span id="哪些情况不要建索引">哪些情况不要建索引</span></h2><ul><li>记录太少的表。</li><li>经常增删改的表。</li><li>频繁更新的字段不适合创建索引。</li><li>Where条件里用不到的字段不创建索引。</li><li>假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</li></ul><h1><span id="性能分析">性能分析</span></h1><h2><span id="explain简介">EXPLAIN简介</span></h2><blockquote><p>EXPLAIN是什么？</p></blockquote><p>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</p><blockquote><p>EXPLAIN怎么使用？</p></blockquote><p>语法：<code>explain</code> + <code>SQL</code>。</p><pre><code class="sql">mysql&gt; explain select * from tbl_emp\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tbl_emp         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 8        Extra: NULL1 row in set (0.00 sec)ERROR: No query specified</code></pre><blockquote><p>EXPLAIN能干嘛？</p></blockquote><p>可以查看以下信息：</p><ul><li><code>id</code>：表的读取顺序。</li><li><code>select_type</code>：数据读取操作的操作类型。</li><li><code>possible_keys</code>：哪些索引可以使用。</li><li><code>key</code>：哪些索引被实际使用。</li><li><code>ref</code>：表之间的引用。</li><li><code>rows</code>：每张表有多少行被优化器查询。</li></ul><h2><span id="explain字段">EXPLAIN字段</span></h2><blockquote><p>id</p></blockquote><p><code>id</code>：表的读取和加载顺序。</p><p>值有以下三种情况：</p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>有相同有不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul><blockquote><p>select_type</p></blockquote><p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p><ul><li><p><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION </code>。</p></li><li><p><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p></li><li><p><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</p></li><li><p><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</p></li><li><p><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</p></li><li><p><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</p><p><strong>eg:</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129211613525.png" alt="image-20220129211613525"></p></li></ul><blockquote><p>type</p></blockquote><p><code>type</code>：访问类型排列。</p><p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了<code>ALL</code>没有用到索引，其他级别都用到索引了。</p><p>一般来说，得保证查询至少达到<code>range</code>级别，最好达到<code>ref</code>。</p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略不计。</li><li><code>const</code>：表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转化为一个常量。</li><li><code>eq_ref</code>：唯一性索引扫描，读取本表中和关联表表中的每行组合成的一行，查出来只有一条记录。除 了 <code>system</code> 和<code> const</code> 类型之外, 这是最好的联接类型。</li><li><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</li><li><code>range</code>：只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然<code>ALL</code>和<code>index</code>都是读全表，但是<code>index</code>是从索引中读的，<code>ALL</code>是从磁盘中读取的。</strong></li><li><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</li></ul><blockquote><p>possible_keys 和 key</p></blockquote><p><code>possible_keys</code>：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p><p><code>key</code>：实际使用的索引。如果为<code>NULL</code>，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅仅出现在<code>key</code>列表中。</p><blockquote><p>key_len</p></blockquote><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p><p><code>key_len</code>计算规则：<strong><a href="https://blog.csdn.net/qq_34930488/article/details/102931490">https://blog.csdn.net/qq_34930488/article/details/102931490</a></strong></p><pre><code class="sql">mysql&gt; desc category;+---------------+------------+------+-----+---------+----------------+| Field         | Type       | Null | Key | Default | Extra          |+---------------+------------+------+-----+---------+----------------+| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment || name          | char(50)   | YES  |     | NULL    |                || parent_cid    | bigint(20) | YES  |     | NULL    |                || cat_level     | int(11)    | YES  |     | NULL    |                || show_status   | tinyint(4) | YES  |     | NULL    |                || sort          | int(11)    | YES  |     | NULL    |                || icon          | char(255)  | YES  |     | NULL    |                || product_unit  | char(50)   | YES  |     | NULL    |                || product_count | int(11)    | YES  |     | NULL    |                |+---------------+------------+------+-----+---------+----------------+9 rows in set (0.00 sec)mysql&gt; explain select cat_id from category where cat_id between 10 and 20 \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: rangepossible_keys: PRIMARY          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！          ref: NULL         rows: 11     filtered: 100.00        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><blockquote><p>ref</p></blockquote><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><blockquote><p>rows</p></blockquote><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p><blockquote><p>Extra</p></blockquote><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL中无法利用索引完成的排序操作成为”文件内排序”。</strong></li></ul><pre><code class="sql"># 排序没有使用索引mysql&gt; explain select name from category where name=&#39;Tangs&#39; order by cat_level \G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: refpossible_keys: idx_name_parentCid_catLevel          key: idx_name_parentCid_catLevel      key_len: 201          ref: const         rows: 1     filtered: 100.00        Extra: Using where; Using index; Using filesort1 row in set, 1 warning (0.00 sec)#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~# 排序使用到了索引mysql&gt; explain select name from category where name=&#39;zz&#39; order by parent_cid,cat_level\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: refpossible_keys: idx_name_parentCid_catLevel          key: idx_name_parentCid_catLevel      key_len: 201          ref: const         rows: 1     filtered: 100.00        Extra: Using where; Using index1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>Using temporary</code>：使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></li><li><code>Using index</code>：表示相应的<code>SELECT</code>操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现<code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作。</li></ul><pre><code class="sql"># 覆盖索引# 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。# 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。mysql&gt; explain select cat_id from category \G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: category   partitions: NULL         type: indexpossible_keys: NULL                 key: PRIMARY      key_len: 8          ref: NULL         rows: 1425     filtered: 100.00        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   1 row in set, 1 warning (0.00 sec)</code></pre><ul><li><code>Using where</code>：表明使用了<code>WHERE</code>过滤。</li><li><code>Using join buffer</code>：使用了连接缓存。</li><li><code>impossible where</code>：<code>WHERE</code>子句的值总是false，不能用来获取任何元组。</li></ul><pre><code class="sql">mysql&gt; explain select name from staffs where name = &#39;zz&#39; and name = &#39;cc&#39;\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: NULL   partitions: NULL         type: NULLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: NULL     filtered: NULL        Extra: Impossible WHERE   # 不可能字段同时查到两个名字1 row in set, 1 warning (0.00 sec)</code></pre><h2><span id="mysql中explain的extra字段值using-index和using-whereusing-index和using-where以及using-index-condition的区别">MySQL中Explain的Extra字段值Using index和Using where；Using index和Using where以及Using index condition的区别</span></h2><p> 在分别介绍以上四个值之前，我们需要知道，MySQL的架构分成了server层和存储引擎层（storage engine），server层通过调用存储引擎层来返回数据。       </p><p>其中Using index表示查询的列被索引覆盖，因而无需再回表（如果你不知道啥叫回表，请参见第3篇博客）查询，因而效率较高。例如：select id from test where id = 5;其中id为主键。</p><p>​    Using where;Using index表示查询的列被索引覆盖，且where筛选条件是索引列前导列的一个范围，或者是索引列的非前导列，例如：select id from test where id &gt; 5;。很明显，效率也很高。</p><p>​    Using where表示查询的列未被索引覆盖，且where筛选条件是索引列前导列的一个范围，或者是索引列的非前导列，或者是非索引列，例如：select * from test where id &gt; 30; 。因为未被索引覆盖，所以需要回表，因而性能比前两者差。</p><p>​    Extra为null表示查询的列未被索引覆盖，且where筛选条件是索引的前导列，这意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，因而性能也比前两者差。</p><p>​    Using index condition是MySQL 5.6中引入的一种新特性，叫做Index Condition Pushdown(ICP)，是一种在存储引擎层使用索引过滤数据的一种优化方式。这里的“下推” 是指将原来在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。使用ICP可以减少存储引擎层返回需要被index filter过滤掉的行记录，省去了存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。Using index condition仅适用于二级索引，原因是ICP的目的是减少全行读取的次数，从而减少IO操作。而对于innodb聚集索引，完整的记录已被读入到innodb缓冲区，在这种情况下，ICP不会减少io，所以ICP只适用于二级索引，一般发生在查询字段无法被二级索引覆盖的场景，该场景下往往需要回表。通过ICP，可以减少存储引擎返回的行记录，从而减少了IO操作</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129210757192.png" alt="image-20220129210757192"></p><h1><span id="索引分析">索引分析</span></h1><h2><span id="单表索引分析">单表索引分析</span></h2><blockquote><p>数据准备</p></blockquote><pre><code></code></pre><blockquote><p>案例：查询<code>category_id</code>为1且<code>comments</code>大于1的情况下，<code>views</code>最多的<code>article_id</code>。</p></blockquote><pre><code class="sql"># 1、sql语句SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;# 2、sql执行计划mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: article   partitions: NULL         type: ALL  #最坏的情况possible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 5     filtered: 20.00        Extra: Using where; Using filesort  # 产生了文件内排序，需要优化SQL1 row in set, 1 warning (0.00 sec)</code></pre><p>2、创建索引<code>idx_article_ccv</code>。</p><pre><code class="sql">CREATE INDEX idx_article_ccv ON article(category_id,comments,views);</code></pre><p>3、查看当前索引。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129213500083.png" alt="image-20220129213500083"></p><p>4、查看现在SQL语句的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129213519241.png" alt="image-20220129213519241"></p><p>发现创建符合索引<code>idx_article_ccv</code>之后，虽然解决了全表扫描的问题，但是在<code>order by</code>排序的时候没有用到索引，MySQL居然还是用的**<code>Using filesort</code>**</p><p>5、我们试试把SQL修改为<code>SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;</code>看看SQL的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214319416.png" alt="image-20220129214319416"></p><p>推论：当<code>comments &gt; 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就用不上，但是当<code>comments = 1</code>的时候<code>order by</code>排序<code>views</code>字段索引就可以用上！！！</p><p><strong>所以，范围值使索引失效。</strong></p><p>6、我们现在知道<strong>范围之后的索引会失效</strong>，原来的索引<code>idx_article_ccv</code>最后一个字段<code>views</code>会失效，那么我们如果删除这个索引，创建<code>idx_article_cv</code>索引呢？？？？</p><pre><code class="sql">/* 创建索引 idx_article_cv */CREATE INDEX idx_article_cv ON article(category_id,views);</code></pre><p>查看当前的索引</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214725701.png" alt="image-20220129214725701"></p><p>7、当前索引是<code>idx_article_cv</code>，来看一下SQL执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129214743296.png" alt="image-20220129214743296"></p><p>成功了</p><h2><span id="两表索引分析">两表索引分析</span></h2><blockquote><p>数据准备</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215115964.png" alt="image-20220129215115964"></p></blockquote><pre><code></code></pre><blockquote><p>两表连接查询的SQL执行计划</p></blockquote><p>1、不创建索引的情况下，SQL的执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215318710.png" alt="image-20220129215318710"></p><p><code>book</code>和<code>class</code>两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在<code>book</code>表还是创建在<code>class</code>表</p><p>2、左表(<code>book</code>表)创建索引。</p><p>创建索引<code>idx_book_card</code></p><pre><code class="sql">/* 在book表创建索引 */CREATE INDEX idx_book_card ON book(card);</code></pre><p>在<code>book</code>表中有<code>idx_book_card</code>索引的情况下，查看SQL执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215436042.png" alt="image-20220129215436042"></p><p>3、删除<code>book</code>表的索引，右表(<code>class</code>表)创建索引。</p><p>创建索引<code>idx_class_card</code></p><pre><code class="sql">/* 在class表创建索引 */CREATE INDEX idx_class_card ON class(card);</code></pre><p>在<code>class</code>表中有<code>idx_class_card</code>索引的情况下，查看SQL执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220129215703969.png" alt="image-20220129215703969"></p><p><strong>由此可见，左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。</strong></p><h2><span id="三张表索引分析">三张表索引分析</span></h2><blockquote><p>数据准备</p></blockquote><pre><code class="sql">DROP TABLE IF EXISTS `phone`;CREATE TABLE IF NOT EXISTS `phone`(`phone_id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#39;主键&#39;,`card` INT(10) UNSIGNED NOT NULL COMMENT &#39;分类&#39; ) COMMENT &#39;手机&#39;;</code></pre><blockquote><p>三表连接查询SQL优化</p></blockquote><p>1、不加任何索引，查看SQL执行计划。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130195042549.png" alt="image-20220130195042549"></p><p>2、根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在<code>book</code>表和<code>phone</code>表上添加索引。</p><pre><code class="sql">/* 在book表创建索引 */CREATE INDEX idx_book_card ON book(card);/* 在phone表上创建索引 */CREATE INDEX idx_phone_card ON phone(card);</code></pre><p>再次执行SQL的执行计划</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130195317676.png" alt="image-20220130195317676"></p><h2><span id="结论">结论</span></h2><p><code>JOIN</code>语句的优化：</p><ul><li>尽可能减少<code>JOIN</code>语句中的<code>NestedLoop</code>（嵌套循环）的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li><li>优先优化<code>NestedLoop</code>的内层循环。</li><li>保证<code>JOIN</code>语句中被驱动表上<code>JOIN</code>条件字段已经被索引。</li><li>当无法保证被驱动表的<code>JOIN</code>条件字段被索引且内存资源充足的前提下，不要太吝惜<code>Join Buffer</code> 的设置。</li></ul><h1><span id="索引失效">索引失效</span></h1><p>建表：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130202619301.png" alt="image-20220130202619301"></p><p>建立索引 </p><pre><code class="sql">ALTER TABLE staffs ADD INDEX index_staffs_nameAgePos(`name`,`age`,`pos`);</code></pre><p>查看效果</p><p>三条查询语句</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203429755.png" alt="image-20220130203429755"></p><p>只有长度在变化，其他都是好的</p><h2><span id="索引失效应该避免"><strong>索引失效（应该避免）</strong></span></h2><h3><span id="从左开始且不跳列才不会失效"><strong>从左开始且不跳列才不会失效</strong></span></h3><ul><li>最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过复合索引中间列</strong>。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203719338.png" alt="image-20220130203719338"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203842786.png" alt="image-20220130203842786"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130203749391.png" alt="image-20220130203749391"></p><p>key_len不对，索引失效，不符合最佳左前缀</p><h3><span id="索引列上不做额外操作才不会失效">索引列上不做额外操作才不会失效</span></h3><p>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130205238614.png" alt="image-20220130205238614"></p><h3><span id="少用gtltbetweenand等结构">少用&gt;，&lt;，between…and等结构</span></h3><ul><li>存储引擎不能使用索引中<code>范围条件右边的列</code>。（就是&gt;，&lt;，between…and）</li><li>范围条件右边的索引失效</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130222810515.png" alt="image-20220130222810515"></p><h3><span id="减少select">减少select *</span></h3><ul><li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致））<br>区别在于extra，索引的不同，速度不一样</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130223926414.png" alt="image-20220130223926414"></p><h3><span id="不用-is-null-is-not-null">不用 is null, is not null</span></h3><ul><li>is null, is not null 也无法使用索引。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224127150.png" alt="image-20220130224127150"></p><h3><span id="模糊查询">模糊查询</span></h3><ul><li>like以通配符开头（’%abc…’），mysql索引失效会变成全表扫描的操作。</li><li><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224520085.png" alt="image-20220130224520085"></li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224447994.png" alt="image-20220130224447994"></p><p>只有xx%前缀查询才不会失效</p><p>解决方法：</p><p>把*替换为索引的字段值（id可以不加索引）</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130224928257.png" alt="image-20220130224928257"></p><h3><span id="类型要正确">类型要正确</span></h3><p>即使类型不正确也可以查询，但是底层会帮你转换类型，在判断，但会浪费时间，索引直接失效，变成了全表查询</p><ul><li><p>字符串不加单引号索引失效。</p></li><li><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225213417.png" alt="image-20220130225213417"></p><p>把*替换为字段值会好些</p></li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225125971.png" alt="image-20220130225125971"></p><h3><span id="不用or关键字就不会失效">不用or关键字就不会失效</span></h3><ul><li>少用or，用它来连接时会索引失效。</li></ul><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220130225352233.png" alt="image-20220130225352233"></p><h1><span id="面试常考">面试常考</span></h1><p><strong>建表</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190057941.png" alt="image-20220201190057941"></p><p><strong>建立索引</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190132165.png" alt="image-20220201190132165"></p><p><strong>explain</strong></p><p><strong>正常顺序</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190200564.png" alt="image-20220201190200564"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190228297.png" alt="image-20220201190228297"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190243309.png" alt="image-20220201190243309"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190317209.png" alt="image-20220201190317209"></p><p><strong>乱序</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201190613078.png" alt="image-20220201190613078"></p><p>打乱顺序mysql的最左前缀原则仍符合，因为mysql有优化器会帮你查询是否匹配</p><p><strong>范围</strong></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201195817005.png" alt="image-20220201195817005"></p><p>如果开始限定范围<br>第一条会用到3个索引，前两个用来查找，c3用来排序<br>第二条用到了4个索引，前3个用来查找，c4用来排序</p><p>因为mysql引擎会优化第二个sql语句在底层已经变成</p><p><strong>explain select * from test03 where c1=’a1’ and c2=’a2’ and c3=’a3’ and c4&gt;’a4’;</strong></p><p><strong>使用order by</strong><br>下面那个例子都是一样的<br>前两个都是在查找，第三个只是在排序，到了这里就已经断了，所以c4可有可无</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220201200304494.png" alt="image-20220201200304494"></p><p>如果使用c4排序，会出现Using filesort。，因为优化器会给你文件排序（因为中间跳了一个）</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204121522497.png" alt="image-20220204121522497"></p><p>这个也会出现Using filesort，因为顺序颠倒了</p><pre><code class="sql"> explain select * from test03 where c1=&#39;a1&#39; and c5=&#39;a5&#39; order by c3,c2;</code></pre><p>这个就不会出现filesort，因为c2的值已经确认了</p><p> <img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204122519176.png" alt="image-20220204122519176"></p><p>groupby之前必排序，规则和orderby差不多</p><p>模糊查询</p><p>%在左边会导致索引失效，在右边可以不失效</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204123846471.png" alt="image-20220204123846471"></p><h2><span id="总结">总结</span></h2><p>对于单键索引，尽量选择针对当前query过滤性更好的索引。<br>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。<br>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引。<br>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</p><p>口诀：</p><p><strong>全值匹配我最爱， 最左前缀要遵守；</strong></p><p><strong>带头大哥不能死， 中间兄弟不能断；</strong></p><p><strong>索引列上少计算， 范围之后全失效；</strong></p><p><strong>LIKE 百分写最右， 覆盖索引不写 <code>\*</code>；</strong></p><p><strong>不等空值还有 OR， 索引影响要注意；</strong></p><p><strong>VAR 引号不可丢， SQL 优化有诀窍。</strong></p><h1><span id="查询截取分析">查询截取分析</span></h1><h2><span id="sql调优过程">SQL调优过程：</span></h2><p>观察，至少跑1天，看看生产的慢SQL情况。<br>开启慢查询日志，设置阙值，比如超过5秒钟的就是慢SQL，并将它抓取出来。<br>explain + 慢SQL分析。<br>show profile。<br>运维经理 or DBA，进行SQL数据库服务器的参数调优。</p><h2><span id="总结">总结：</span></h2><p>慢查询的开启并捕获<br>explain + 慢SQL分析<br>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况<br>SQL数据库服务器的参数调优。</p><h2><span id="in和exists的区别">in和exists的区别</span></h2><h3><span id="小表驱动大表">小表驱动大表</span></h3><p>RBO原理：</p><p>当B表的数据集必须小于A表的数据集时，用in优于exists。</p><p> <strong>select * from A where id in (select id from B)</strong><br> 等价于:<br> <strong>for select id from B</strong><br> <strong>for select * from A where A.id = B.id</strong><br> 当A表的数据集系小于B表的数据集时，用exists优于in</p><p> <strong>select * from A where exists (select 1 from B where B.id = A.id)</strong><br> 等价于：<br> <strong>for select * from A</strong><br> <strong>for select * from B where B.id = A.id</strong></p><h3><span id="关于exists的关键字">关于exists的关键字</span></h3><p>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。</p><p>提示</p><p>EXSTS(subquey)只返回TRUE或FALSE，因此子查询中的SELECT * 也可以是 SELECT 1 或select ‘X’，官方说法是实际执行时会忽略SELECT清单，因此没有区别。<br>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。<br>EXISTS子查询往往也可以用条件表达式，其他子查询或者JOIN来替代，何种最优需要具体问题具体分析<br>3.2 OrderBy优化<br>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p><p>建立一张表以及一个索引</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204195232493.png" alt="image-20220204195232493"></p><p>如果索引的时候也是按照顺序，两种情况都是一样的</p><p>但是索引的时候不按顺序<br>就会出现这样的情况</p><h2><span id="mysql支持二种方式的排序filesort和lindex">MySQL支持二种方式的排序：FileSort和lIndex</span></h2><p>Index效率高，它指MySQL扫描索引本身完成排序，FileSort方式效率较低。</p><h4><span id="order-by满足两情况会使用index方式排序">ORDER BY满足两情况，会使用Index方式排序：</span></h4><p><strong>1.ORDER BY语句使用索引最左前列。</strong><br><strong>2</strong>.<strong>使用where子句与Order BY子句条件列组合满足索引最左前列。</strong><br>如果不在索引列上，mysql的filesort有两种算法：<strong>双路排序、单路排序</strong></p><blockquote><p>双路排序：MySQL4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和OrderBy列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读对应的数据输出。<br>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p></blockquote><blockquote><p>单路排序：从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序压的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。<br>但是用单路有问题</p></blockquote><p>在sort_buffer中，单路排序比双路排序要多占用很多空间，因为单路排序是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并)，排完再取取sort_buffer容量大小，再排……从而多次I/O。<br>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><h4><span id="优化策略">优化策略</span></h4><p>1.增大sort_buffer_size参数的设置<br>2.增大max_length_for_sort_data参数的设置<br>3.为什么设置sort_buffer_size、max_length_for_sort_data参数能优化排序？</p><p>主要是因为可以提高Order By的速度</p><h4><span id="具体原因如下">具体原因如下：</span></h4><p>Order by时select * 是一个Query需要的字段，这点非常重要。在这里的影响是;</p><p>当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。<br>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer__size。<br>尝试提高sort_buffer_size，不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。<br>尝试提高max_length_for_sort_data，提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。</p><pre><code></code></pre><h3><span id="小结">小结</span></h3><p>为排序使用索引</p><p>MySql两种排序方式∶文件排序 或 扫描有序索引排序</p><p>MySql能为 排序 与 查询 使用相同的索引</p><p>创建复合索引 a_b_c (a, b, c)</p><p>order by能使用索引最左前缀</p><pre><code class="sql">ORDER BY aORDER BY a, bORDER BY a, b, cORDER BY a DESC, b DESC, c DESC</code></pre><p>如果WHERE使用素引的最左前缀定义为常量，则order by能使用索引</p><pre><code class="sql">WHERE a = const ORDER BY b,cWHERE a = const AND b = const ORDER BY cWHERE a = const ORDER BY b, cWHERE a = const AND b &gt; const ORDER BY b, c</code></pre><p>不能使用索引进行排序的情况</p><pre><code class="sql">ORDER BY a ASC, b DESC, c DESC //排序不—致WHERE g = const ORDER BY b, c //产丢失a索引WHERE a = const ORDER BY c //产丢失b索引WHERE a = const ORDER BY a, d //d不是素引的一部分WHERE a in (…) ORDER BY b, c //对于排序来说,多个相等条件也是范围查询</code></pre><h2><span id="groupby优化">GroupBy优化</span></h2><p>GroupBy优化（和order by差不多）</p><p>group by实质是先排序后进行分组，遵照索引建的最佳左前缀。<br>当无法使用索引列，增大max_length_for_sort_data参数的设置 + 增大sort_buffer_size参数的设置。<br>where高于having，能写在where限定的条件就不要去having限定了。</p><h2><span id="慢查询日志">慢查询日志</span></h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。<br>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析<br>默认情况下，MySQL数据库没有开启慢查询日速，需要我们手动来设置这个参数。</p><p>一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><p>通过如下命令进行操作</p><p>查看日志是否开启</p><pre><code class="sql">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220204210832085.png" alt="image-20220204210832085"></p><p>开启 set global slow_query_log=1，只对当前数据库生效，默认关闭的<br>结果如下</p><p><strong>永久生效</strong><br>修改配置文件my.cnf<br>[mysqld]下增加或修改参数slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件</p><pre><code class="ABAP">slow_query_log =1slow_query_log_file=/var/lib/manongyanjiuseng-slow.log</code></pre><p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log（如果没有指定参数slow_query_log_file的话）</p><h3><span id="什么样的数据会放到慢查询日志">什么样的数据会放到慢查询日志</span></h3><p>需要设置一个多长的时间段就会放到日志中<br>这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒</p><p>命令：</p><pre><code class="sql">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</code></pre><p>运行时间正好等于long_query_time的情况，并不会被记录下来，需大于</p><p>设置阈值时间后还需要重启才可以生效 </p><pre><code class="sql">set global long_query_time=3;</code></pre><p>查询当前系统中有多少条慢查询记录 </p><pre><code class="sql">show global status like &#39;%Slow_queries%&#39;;</code></pre><p>如果在配置文件中设置阈值<br>具体配置如下</p><p>[mysqld]下配置:</p><pre><code class="sql">slow_query_log=1;slow_query_log_file=/var/lib/mysql/atguigu-slow.loglong_query_time=3;log_output=FILE;</code></pre><h2><span id="结合工具进行分析mysqldumpslow">==结合工具进行分析mysqldumpslow ==</span></h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p><p>查看mysqldumpslow的帮助信息，mysqldumpslow –help。</p><h3><span id="工作常用参考">工作常用参考</span></h3><pre><code class="sh">得到返回记录集最多的10个SQL ，mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log得到访问次数最多的10个SQL，mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log得到按照时间排序的前10条里面含有左连接的查询语句，mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log另外建议在使用这些命令时结合│和more 使用，否则有可能出现爆屏情况，mysqldumpslow -s r-t 10 /ar/lib/mysql/atguigu-slow.log | more</code></pre><p>3.5 批量插入数据脚本<br>为了更好的展示<br>先建立一张表</p><pre><code class="sql">create database bigData;use bigData;CREATE TABLE dept(    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,    dname VARCHAR(20)NOT NULL DEFAULT &quot;&quot;,    loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;)ENGINE=INNODB DEFAULT CHARSET=utf8;CREATE TABLE emp(    id int unsigned primary key auto_increment,    empno mediumint unsigned not null default 0,    ename varchar(20) not null default &quot;&quot;,    job varchar(9) not null default &quot;&quot;,    mgr mediumint unsigned not null default 0,    hiredate date not null,    sal decimal(7,2) not null,    comm decimal(7,2) not null,    deptno mediumint unsigned not null default 0)ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><p>开启了可以创建存储函数的权限，主要是这个功能</p><p>设置参数<strong>log_bin_trust_function_creators</strong></p><pre><code class="sql">show variables like &#39;log_bin_trust_function_creators&#39;;set global log_bin_trust_function_creators=1;</code></pre><p>这是在终端上输入的<br>但是重启后会失效</p><p>如果要配置永久的，需要在配置文件上配置</p><p>windows下my.ini[mysqld]加上</p><pre><code class="sh">log_bin_trust_function_creators=1</code></pre><p>linux下/etc/my.cnf 下my.cnf[mysqld]加上</p><pre><code class="sh">log_bin_trust_function_creators=1</code></pre><p>创建函数，保证每条数据都不同</p><p>随机产生字符串</p><pre><code class="sql">delimiter $$ # 两个 $$ 表示结束create function rand_string(n int) returns varchar(255)begin    declare chars_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyz&#39;;    declare return_str varchar(255) default &#39;&#39;;    declare i int default 0;    while i &lt; n do        set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));        set i=i+1;    end while;    return return_str;end $$</code></pre><p>执行完语句后，在终端上输入select rand_string(2)$$;，要以$$结尾</p><p>随机产生部门编号    </p><pre><code class="sql">delimiter $$create function rand_num() returns int(5)begin    declare i int default 0;    set i=floor(100+rand()*10);    return i;end $$</code></pre><p>执行完语句后，在终端上输入select rand_num()$$，要以$$结尾</p><p>创建存储过程，创建往emp表中插入数据的存储过程</p><pre><code class="sql">delimiter $$create procedure insert_emp(in start int(10),in max_num int(10))begin    declare i int default 0;    set autocommit = 0;    repeat        set i = i+1;        insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),rand_string(6),&#39;salesman&#39;,0001,curdate(),2000,400,rand_num());        until i=max_num        end repeat;    commit;end $$</code></pre><p>创建往dept表中插入数据的存储过程</p><pre><code class="sql">delimiter $$create procedure insert_dept(in start int(10),in max_num int(10))begin    declare i int default 0;    set autocommit = 0;    repeat        set i = i+1;        insert into dept(deptno,dname,loc) values((start+i),rand_string(10),rand_string(8));        until i=max_num        end repeat;    commit;end $$</code></pre><p>调用存储过程<br>往dept表中插入数据</p><pre><code class="sql">DELIMITER ;CALL insert_dept(100, 10);</code></pre><p>往emp表中插入50万数据</p><pre><code class="sql">DELIMITER ;CALL insert_emp(100001, 500000);</code></pre><h2><span id="show-profile">Show Profile</span></h2><p>Show Profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><p>查看当前状态是否开启了， </p><pre><code class="sql">show variables like &#39;profiling&#39;;</code></pre><p>开启 ，</p><pre><code class="sql">set profiling=on;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206120852097.png" alt="image-20220206120852097"></p><p>通过执行show profiles;</p><ul><li><p>诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL数字号码;<br>例如</p><pre><code class="sql">show profile cpu,block io for query 3;</code></pre><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206120949041.png" alt="image-20220206120949041"></p></li></ul><p>具体的参数介绍</p><blockquote><p>ALL：显示所有的开销信息。</p></blockquote><blockquote><p>BLOCK IO：显示块lO相关开销。<br>CONTEXT SWITCHES ：上下文切换相关开销。<br>CPU：显示CPU相关开销信息。<br>IPC：显示发送和接收相关开销信息。<br>MEMORY：显示内存相关开销信息。<br>PAGE FAULTS：显示页面错误相关开销信息。<br>SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。<br>SWAPS：显示交换次数相关开销的信息。<br>在查询该文件的时候如果出现了这些一定要特别注意</p></blockquote><h3><span id="不理想字段">不理想字段</span></h3><p><strong>converting HEAP to MyISAM</strong> 查询结果太大，内存都不够用了往磁盘上搬了。<br><strong>Creating tmp table</strong> 创建临时表，拷贝数据到临时表，用完再删除<br><strong>Copying to tmp table on disk</strong> 把内存中临时表复制到磁盘，危险!<br>locked</p><h2><span id="全局查询日志">全局查询日志</span></h2><p>General log默认不开启的原因有两个：</p><p>日志将会非常大，对磁盘是一个很大的压力。因为所有的操作都会被记录下来。<br>对MySQL数据的性能有一定的影响。</p><p>不要在生产环境开启这个功能。</p><ul><li><p>开启</p><pre><code>set global general_log=1</code></pre><p>#记录日志文件的路径</p><pre><code>general_log_file=/path/logfile</code></pre><p>#输出格式</p><pre><code>log_output=FILE</code></pre></li></ul><p>查看状态是否开启，<strong>show variables like ‘general_log’;</strong></p><pre><code class="sql">set global general_log=1;set global log_output=&#39;TABLE&#39;;</code></pre><p>log_output=‘FILE‘表示将日志存入文件,默认值是‘FILE‘</p><p>log_output=‘TABLE‘表示将日志存入数据库,这样日志信息就会被写入到mysql.slow_log表中.</p><p>所编写的sql语句，将会记录到mysql库里的geneial_log表，可以用下面的命令查看：</p><p>select * from mysql.general_log;</p><p>查出来会有输出语句</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206211546434.png" alt="image-20220206211546434"></p><h2><span id="锁机制">锁机制</span></h2><h3><span id="从读写来分">从读写来分</span></h3><p>读锁：可共同读</p><p>写锁：不可共同写，在任务完成前，会阻断其他读锁和写锁</p><p>表锁：</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206223240669.png" alt="image-20220206223240669"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206224230948.png" alt="image-20220206224230948"></p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220206224728944.png" alt="image-20220206224728944"></p><p>innoDB索引失效行锁会切换为表锁</p><h3><span id="间隙锁的危害">间隙锁的危害</span></h3><blockquote><p>什么是间隙锁？</p></blockquote><p>当我们用范围条件而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁，对于键值在条件范文内但并不存在的记录，叫做”间隙(GAP)”。</p><p><code>InnoDB</code>也会对这个”间隙”加锁，这种锁的机制就是所谓的”间隙锁”。</p><blockquote><p>间隙锁的危害</p></blockquote><p>因为<code>Query</code>执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p><p>间隙锁有一个比较致命的缺点，就是<strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong>在某些场景下这可能会対性能造成很大的危害。</p><p><img src="/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220207212800265.png" alt="image-20220207212800265"></p><h3><span id="行锁">行锁</span></h3><pre><code class="sql">SELECT .....FOR UPDATE`在锁定某一行后，其他写操作会被阻塞，直到锁定的行被`COMMIT</code></pre><h3><span id="行锁分析">行锁分析</span></h3><pre><code class="sql">mysql&gt; SHOW STATUS LIKE &#39;innodb_row_lock%&#39;;+-------------------------------+-------+| Variable_name                 | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0     || Innodb_row_lock_time          | 11131 || Innodb_row_lock_time_avg      | 11131 || Innodb_row_lock_time_max      | 11131 || Innodb_row_lock_waits         | 1     |+-------------------------------+-------+5 rows in set (0.00 sec)</code></pre><ul><li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量。</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度（重要）。</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花的平均时间（重要）。</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间。</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（重要）。</li></ul><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化策略。</p><h2><span id="主从复制">主从复制</span></h2><p><a href="https://www.cnblogs.com/phpstudy2015-6/p/6485819.html">https://www.cnblogs.com/phpstudy2015-6/p/6485819.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/17/mysql%E4%BC%98%E5%8C%96/image-20220117114857930.png&quot; alt=&quot;image-20220117114857930&quot;&gt;&lt;/p&gt;
&lt;p&gt;显示字符集编码&lt;/p&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="优化" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="http://example.com/2021/12/29/spring/"/>
    <id>http://example.com/2021/12/29/spring/</id>
    <published>2021-12-29T10:38:40.000Z</published>
    <updated>2021-12-29T12:04:42.109Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="spring">Spring</span></h1><h5><span id="spring容器">Spring容器</span></h5><h6><span id="容器是什么">容器是什么？</span></h6><p><strong>代码层次</strong>：Spring容器就是一个实现了<code>ApplicationContext</code>接口的对象</p><p><strong>从功能上来看</strong>： Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</p><p>工作流程</p><p><img src="https://img-blog.csdnimg.cn/20191217235039696.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Spring容器通过我们提交的pojo类以及配置元数据产生一个充分配置的可以使用的系统</strong></p><p>这里说的配置元数据，实际上我们就是我们提供的XML配置文件，或者通过注解方式提供的一些配置信息</p><h5><span id="spring-bean">Spring bean</span></h5><p>通过不同的创建bean的手段，来分别验证对象的实例化方法</p><p>通过<code>@compent</code>,<code>@Service</code>等注解的方式，当没有进行特殊的处理的时候，默认会使用无参构造函数进行对象的实例化</p><p>通过普通XML的方式（同<code>@compent</code>注解，这里就不赘诉了）</p><p>通过<code>@Configuration</code>注解的方式，同样，断点也进入最后一行</p><p><img src="https://img-blog.csdnimg.cn/20191217235332887.jpg" alt="在这里插入图片描述"></p><p>通过<code>@Bean</code>的方式</p><p><img src="https://img-blog.csdnimg.cn/20191217235341477.jpg" alt="在这里插入图片描述"></p><p>可以发现，通过<code>@Bean</code>方法创建对象时，Spring底层是通过<code>factoryMethod</code>的方法进行实例化对象的。Spring会在我们需要实例化的这个对象对应的<code>BeanDefinition</code>中记录<code>factoryBeanName</code>是什么（在上面的例子中factoryBeanName就是config）,同时会记录这个factoryBean中创建对象的<code>factoryMethodName</code>是什么，最后通过<code>factoryBeanName</code>获取一个Bean然后反射调用<code>factoryMethod</code>实例化一个对象。</p><h6><span id="实例化总结">实例化总结：</span></h6><ol><li><p>对象实例化，只是得到一个对象，还不是一个完全的Spring中的Bean，我们实例化后的这个对象还没有完成依赖注入，没有走完一系列的声明周期，这里需要大家注意</p></li><li><p>Spring官网上指明了，在Spring中实例化一个对象有三种方式：</p><ul><li>构造函数</li><li>实例工厂方法</li><li>静态工厂方法</li></ul></li><li><p>总结：</p><p>Spring通过解析我们的配置元数据，以及我们提供的类对象得到一个Beanfinition对象。通过这个对象可以实例化出一个java bean对象。主要流程如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20191217235508810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5><span id="依赖注入">依赖注入：</span></h5><p>根据官网介绍，依赖注入主要分为两种方式</p><ol><li><p>构造函数注入</p></li><li><p>Setter方法注入</p></li></ol><blockquote><p>在<em><strong>默认的注入模型</strong></em>下，Spring如果同时找到了两个<em><strong>符合要求的构造函数</strong></em>，那么Spring会采用默认的无参构造进行实例化，如果这个时候没有无参构造，那么此时会报错<code>java.lang.NoSuchMethodException</code>。什么叫符合要求的构造函数呢？就是构造函数中的参数Spring能找到，参数被Spring所管理。</p></blockquote><blockquote><p>这里需要着重记得：<strong>一，默认注入模型；二，符合要求的构造函数</strong></p></blockquote><p>如果我们同时采用构造注入加属性注入会怎么样呢？</p><p>Spring虽然能在构造函数里完成属性注入，但是这属于实例化对象阶段做的事情，那么在后面真正进行属性注入的时候，肯定会将其覆盖掉</p><p>结论：</p><ol><li>构造函数注入跟setter方法注入可以混用<ol><li>对于一些强制的依赖，我们最好使用构造函数注入，对于一些可选依赖我们可以采用setter方法注入</li></ol></li><li>Spring团队推荐使用构造函数的方式完成注入。但是对于一些参数过长的构造函数，Spring是不推荐的</li></ol><h5><span id="方法注入">方法注入：</span></h5><ol><li><p>通过注入上下文（applicationContext对象）</p></li><li><p>通过@LookUp的方式（也分为注解跟XML两种方式，这里只演示注解的）</p></li><li><p>方法注入还有一种方式，即通过<code> replace-method</code>这种形式，xml方式。</p></li></ol><p>可以说，一个对象的依赖就是它自身的属性，Spring中的<strong>依赖注入就是属性注入</strong>。</p><ul><li>我们知道一个对象由两部分组成：属性+行为（方法），可以说Spring通过属性注入+方法注入的方式掌控的整个bean。</li><li>属性注入跟方法注入都是Spring提供给我们用来处理Bean之间协作关系的手段</li><li>属性注入有两种方式：构造函数，Setter方法。</li><li>方法注入（LookUp Method跟Replace Method）需要依赖动态代理完成</li><li>方法注入对属性注入进行了一定程度上的补充，因为属性注入的情况下，原型对象可能会失去原型的意义，见：<a href="#jump">为什么需要方法注入</a></li></ul><p>画图如下：</p><p><img src="https://img-blog.csdnimg.cn/20191217235851939.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;spring&quot;&gt;Spring&lt;/span&gt;&lt;/h1&gt;&lt;h5&gt;&lt;span id=&quot;spring容器&quot;&gt;Spring容器&lt;/span&gt;&lt;/h5&gt;&lt;h6&gt;&lt;span id=&quot;容器是什么&quot;&gt;容器是什么？&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;代码层次&lt;/</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>项目整合security</title>
    <link href="http://example.com/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/"/>
    <id>http://example.com/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/</id>
    <published>2021-12-25T04:22:22.000Z</published>
    <updated>2022-01-20T13:29:42.294Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="整合security">整合security</span></h1><h2><span id="security流程">security流程</span></h2><p><strong>核心过滤器</strong></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20211214144425527-16404064926651.png" alt="image-20211214144425527"></p><p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要由它负责。</p><p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p><p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p><p>​    </p><h2><span id="解决面向接口开发">解决（面向接口开发）</span></h2><p>登录</p><p>​    ①自定义登录接口  </p><p>​                调用ProviderManager的方法进行认证 如果认证通过生成jwt</p><p>​                把用户信息存入redis中</p><p>​    ②自定义UserDetailsService </p><p>​                在这个实现类中去查询数据库</p><pre><code class="java">/** * &lt;p&gt; * 自定义userDetailsService - 认证用户详情 * &lt;/p&gt; * * @author qy * @since 2019-11-08 */@Service(&quot;userDetailsService&quot;)public class UserDetailsServiceImpl implements UserDetailsService &#123;    @Autowired    private UserService userService;    @Autowired    private PermissionService permissionService;    /***     * 根据账号获取用户信息     * @param username:     * @return: org.springframework.security.core.userdetails.UserDetails     */    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        // 从数据库中取出用户信息        User user = userService.selectByUsername(username);        // 判断用户是否存在        if (null == user)&#123;            //throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);        &#125;        // 返回UserDetails实现类        com.atguigu.serurity.entity.User curUser = new com.atguigu.serurity.entity.User();        BeanUtils.copyProperties(user,curUser);        List&lt;String&gt; authorities = permissionService.selectPermissionValueByUserId(user.getId());        SecurityUser securityUser = new SecurityUser(curUser);        securityUser.setPermissionValueList(authorities);        return securityUser;    &#125;&#125;</code></pre><p>校验：</p><p>​    ①定义Jwt认证过滤器</p><p>​                获取token</p><p>​                解析token获取其中的userid</p><p>​                从redis中获取用户信息</p><p>​                存入SecurityContextHolder</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162733957.png" alt="image-20220120162733957"></p><h3><span id="具体思路">具体思路：</span></h3><p>因为系统的模块众多，每个模块都需要就进行认证与授权，所以选择基于<strong>token</strong>的形式进行认证与授权，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以<strong>用户名为key</strong>，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认<strong>将token携带到header请求头中</strong>，Spring-security解析header头获取token信息，<strong>解析token获取当前用户名</strong>，根据用户名就可以从redis中获取<strong>权限列表</strong>，这样Spring-security就能够判断当前请求是否有权限访问。</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120161410796.png" alt="image-20220120161410796"></p><p>获取权限部分：</p><p>SercurityUser类中：</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162121198.png" alt="image-20220120162121198"></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120162046037.png" alt="image-20220120162046037"></p><p>往所需权限管理的模块中引入依赖：</p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120170457804.png" alt="image-20220120170457804"></p><p><img src="/2021/12/25/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88security/image-20220120212933077.png" alt="image-20220120212933077"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;整合security&quot;&gt;整合security&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;security流程&quot;&gt;security流程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;核心过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/</summary>
      
    
    
    
    <category term="安全框架" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="security" scheme="http://example.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>实习开发记录</title>
    <link href="http://example.com/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2021-12-22T01:52:18.000Z</published>
    <updated>2022-03-04T14:14:12.581Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="实习开发记录">实习开发记录</span></h1><p><strong>自定义异常（OBS）</strong></p><pre><code class="Java">@Getter@ToStringpublic class ImgException extends SystemException &#123;    /**     * 错误代码     */    private final int code;    public ImgException(ExceptionTypeEnum exceptionTypeEnum) &#123;        super(exceptionTypeEnum.getDesc());        this.code = exceptionTypeEnum.getCode();    &#125;&#125;</code></pre><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222095602282-16401381770531.png" alt="image-20211222095602282"></p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220304123839769.png" alt="image-20220304123839769"></p><p>根据OBS服务器返回的HTTP响应信息截取状态码和自定义的异常枚举类中的状态码进行对比，返回SDK文档中定义的相应的返回码对应的错误信息。</p><p>持久层框架采用JPA</p><h2><span id="jsonincludejsonincludeincludenon_null">@JsonInclude(JsonInclude.Include.NON_NULL)</span></h2><p>标记是jackson包提供的json序列化方法，已经集成于Springboot2.0中，此方法的配置意在可以对实体json序列化的时候进行对应的数值处理，</p><p>//将该标记放在属性上，如果该属性为NULL则不参与序列化<br>//如果放在类上边,那对这个类的全部属性起作用<br>//Include.Include.ALWAYS 默认<br>//Include.NON_DEFAULT 属性为默认值不序列化<br>//Include.NON_EMPTY 属性为 空（“”） 或者为 NULL 都不序列化<br>//Include.NON_NULL 属性为NULL 不序列化 </p><p>此注解适用于类标头，可以对实体类引用会自动按规则过滤实体类生成的json数据，也可以通过实现Serializable接口来标识此注解，用于对类的最终json结构进行过滤处理</p><p>eg：</p><pre><code class="java">/** * 获取当前业务的当前文件的数据，用于更新 * * @param businessId 业务ID * @param name 文件名 * @return 返回文件信息 */@Query(&quot;select i from ImpFile i where i.businessId = ?1 and &quot; +        &quot;i.name = ?2 and i.delFlag &lt;&gt; &#39;1&#39; and i.status = &#39;CURRENT&#39;&quot;)ImpFile getCurrentVersion(Long businessId, String name);</code></pre><p>&lt;&gt;为不等于，“？1”，“？2” 表示参数位置及序号</p><p>BaseModel基础实体类</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222112057709.png" alt="image-20211222112057709"></p><p>@JsonSerialize是转换为字符串。主要是后台传递给前台时的日期格式；</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222112331398.png" alt="image-20211222112331398"></p><p>这里则是解决后台传递给前台的id精度丢失问题</p><p>控制层采用ResponseResult作为统一返回结果</p><p><img src="/2021/12/22/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/image-20211222115319388.png" alt="image-20211222115319388"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;实习开发记录&quot;&gt;实习开发记录&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;自定义异常（OBS）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Java&quot;&gt;@Getter
@ToString
public class ImgExcepti</summary>
      
    
    
    
    
    <category term="实习开发" scheme="http://example.com/tags/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://example.com/2021/12/15/nginx/"/>
    <id>http://example.com/2021/12/15/nginx/</id>
    <published>2021-12-15T04:22:56.000Z</published>
    <updated>2021-12-15T04:44:38.083Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="nginx学习">nginx学习</span></h1><p>反向代理（代理服务器端 ）</p><p>负载均衡</p><p>高性能</p><p>各项功能通过配置文件进行配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;nginx学习&quot;&gt;nginx学习&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;反向代理（代理服务器端 ）&lt;/p&gt;
&lt;p&gt;负载均衡&lt;/p&gt;
&lt;p&gt;高性能&lt;/p&gt;
&lt;p&gt;各项功能通过配置文件进行配置&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>谷粒学院项目历程2</title>
    <link href="http://example.com/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/"/>
    <id>http://example.com/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/</id>
    <published>2021-12-07T03:02:07.000Z</published>
    <updated>2022-03-06T14:14:40.526Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="谷粒学院项目">谷粒学院项目</span></h1><h2><span id="redis">redis</span></h2><p>由于客户端首页访问量比较大，所以集成一下redis</p><p>当需要把分页参数和querywapper作为参数在sql语句中进行查询时，需要在mapper层加**@Param(Constants.WAPPER)**注解</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208113652994.png" alt="image-20211208113652994"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208114512577.png" alt="image-20211208114512577"></p><p><strong>@Param(Constants.WAPPER)<strong>相当于</strong>@Param(“ew”)</strong></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208113823141.png" alt="image-20211208113823141"></p><p>${ew.customSqlSegment}这个语句会自动把分页和querywapper参数传到sql查询内</p><p>在使用oss上传图片时，在前端直接调用后端接口，在前端直接给url赋值，附带moudle属性</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211208131741706.png" alt="image-20211208131741706"></p><h2><span id="注册页面获取验证码前端部分">注册页面获取验证码前端部分</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211209174045597.png" alt="image-20211209174045597"></p><pre><code class="vue">// 倒计时    timeDown() &#123;      this.codeText = this.second      // 定义计时器      const timer = setInterval(() =&gt; &#123;        this.codeText--        if (this.codeText &lt; 1) &#123;          clearInterval(timer)          this.codeText = &#39;获取验证码&#39;          this.sending = false          this.second = 60        &#125;        // console.log(new Date())      &#125;, 1000)    &#125;,</code></pre><h2><span id="用户身份认证">用户身份认证</span></h2><ul><li>传统方式为单一服务器模式。</li></ul><ul><li>单点登录（sso）：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/346672f4-9c52-42bf-8fa3-464bf34a8873.jpg" alt="img"></p><p>使用redis和认证中心</p><p><strong>优点 ：</strong>  </p><p>用户身份信息独立管理，更好的分布式管理。可以自己扩展安全策略</p><p><strong>缺点：</strong></p><p>认证服务器访问压力较大，session的可用性和一致性为矛盾性质，服务器也有性能瓶颈</p><ul><li>token模式   sso模式的一种演变</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/0.9709434306629741.png" alt="img"></p><p><strong>优点：</strong></p><ul><li>无状态： token是无状态，session是有状态的</li><li>基于标准化：你的API可以采用标准化的 JSON Web Token (JWT)</li></ul><p><strong>缺点：</strong></p><ul><li>占用带宽</li><li>无法在服务器端销毁</li></ul><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTI2MTc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>token详细学习</p><p><a href="https://www.jianshu.com/p/24825a2683e6">什么是token - 简书 (jianshu.com)</a></p><h2><span id="jwt">JWT</span></h2><p><strong>JWT头部</strong>分是一个描述JWT元数据的JSON对象</p><pre><code class="json">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><p><strong>有效载荷部分</strong>，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。</p><pre><code class="json">iss: jwt签发者sub: 主题aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</code></pre><p>不要在这一部分放隐私数据</p><p><strong>签名哈希</strong>部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p><pre><code class="json">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret)</code></pre><p><strong>Base64URL算法</strong></p><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p><p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法。</p><p><strong>注意：</strong>base64编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以把base64编码解成明文，所以不要在JWT中放入涉及私密的信息</p><h2><span id="后端生成token-根据token获取信息">后端生成token 根据token获取信息</span></h2><p>1.引入依赖</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;joda-time&lt;/groupId&gt;        &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>2.工具类</p><pre><code class="java">/**     * stoken     * @param jwtInfo     * @param expire     * @return     */    public static String getJwtToken(JwtInfo jwtInfo, int expire)&#123;        String JwtToken = Jwts.builder()                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)                .setSubject(&quot;guli-user&quot;)//主题                .setIssuedAt(new Date())//颁发时间                .setExpiration(DateTime.now().plusSeconds(expire).toDate())//过期时间                .claim(&quot;id&quot;, jwtInfo.getId())//用户id                .claim(&quot;nickname&quot;, jwtInfo.getNickname())//用户昵称                .claim(&quot;avatar&quot;, jwtInfo.getAvatar())//用户头像                .signWith(SignatureAlgorithm.HS256, getKeyInstance())                .compact();        return JwtToken;    &#125;/** * 根据token获取会员id * @param request * @return */public static JwtInfo getMemberIdByJwtToken(HttpServletRequest request) &#123;    String jwtToken = request.getHeader(&quot;token&quot;);    if(StringUtils.isEmpty(jwtToken)) return null;    Jws&lt;Claims&gt; claimsJws =  Jwts.parser().setSigningKey(getKeyInstance()).parseClaimsJws(jwtToken);    Claims claims = claimsJws.getBody();    JwtInfo jwtInfo = new JwtInfo(claims.get(&quot;id&quot;).toString(),                                   claims.get(&quot;nickname&quot;).toString(),                                   claims.get(&quot;avatar&quot;).toString());    return jwtInfo;&#125;</code></pre><p>JwtInfo为根据token获取的用户信息，注意：不能放有敏感信息</p><h2><span id="前端登录功能">前端登录功能</span></h2><p>token在cookie中，前端header携带cookie返回后端</p><pre><code class="vue">// 登录submitLogin() &#123;// 执行远程登录接口调用loginApi.submitLogin(this.user).then(response =&gt; &#123;// 将JWT写进cookiecookie.set(&#39;guli_jwt_token&#39;, response.data.token, &#123; domain: &#39;localhost&#39; &#125;)// 跳转到网站的首页面window.location.href = &#39;/&#39;&#125;)&#125;</code></pre><p><strong>{ domain: ‘localhost’ }</strong>  cookie的第三个参数</p><p>设置可以共享cookie的父域名</p><h2><span id="创建dtodata-transfer-object服务和服务之间的数据传输对象">创建DTO（Data Transfer Object）：服务和服务之间的数据传输对象</span></h2><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。</p><h3><span id="left-join-关键字语法">LEFT JOIN 关键字语法</span></h3><pre><code class="sql">SELECT column_name(s)FROM table_name1LEFT JOIN table_name2 ON table_name1.column_name=table_name2.column_name</code></pre><p>serviceimpl层中 this.remove和baseMapper.delete所达成的效果是一样的</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211214115329754-16394540114113.png" alt="image-20211214115329754"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211214115259908-16394539816312.png" alt="image-20211214115259908"></p><p>只是this调用删除方法返回布尔值</p><h2><span id="微信支付">微信支付</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215113757450.png" alt="image-20211215113757450"></p><h3><span id="内网穿透">内网穿透</span></h3><p>使用ngrock</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215132549706.png" alt="image-20211215132549706"></p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211215132522036.png" alt="image-20211215132522036"></p><p>微信回调需要访问到local host</p><p>根据微信返回的二维码url地址生成二维码  </p><p>前端生成：npm install <a href="mailto:&#x76;&#117;&#x65;&#45;&#113;&#x72;&#x69;&#111;&#117;&#x73;&#x6c;&#x79;&#64;&#49;&#46;&#x31;&#46;&#x31;">&#x76;&#117;&#x65;&#45;&#113;&#x72;&#x69;&#111;&#117;&#x73;&#x6c;&#x79;&#64;&#49;&#46;&#x31;&#46;&#x31;</a></p><p>处理一个幂等性，防止重复调用不必要的方法</p><pre><code class="java">//接口调用的幂等性：无论接口被调用多少次，最后所影响的结果都是一致的if(order.getStatus() == 0)&#123;    //更新订单状态    orderService.updateOrderStatus(notifyMap);&#125;</code></pre><h2><span id="api服务网关">API服务网关</span></h2><p>使用springcloudgateway作为网关</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code class="yaml">spring:  profiles:    active: dev # 环境设置  application:    name: infrastructure-apigateway # 服务名  cloud:    nacos:      discovery:        server-addr: localhost:8848 # nacos服务地址    gateway:      discovery:        locator:          enabled: true # gateway可以发现nacos中的微服务      routes:        - id: service-edu        uri: lb://service-edu        predicates:        - Path=/user/**, /*/edu/**        filters:        - SetStatus=250 #修改返回状态码</code></pre><p>predicates为断言，有路径断言，时间断言，远程IP断言，cookie断言，header断言，Query请求断言，路由权重断言</p><p>uri配置，如果服务器使用集群模式，自动运用负载均衡模式进行配置</p><h3><span id="处理跨域问题">处理跨域问题</span></h3><pre><code class="java">@Configurationpublic class CorsConfig &#123;    @Bean    public CorsWebFilter corsFilter() &#123;        CorsConfiguration config = new CorsConfiguration();        config.addAllowedMethod(&quot;*&quot;);        config.addAllowedOrigin(&quot;*&quot;);        config.addAllowedHeader(&quot;*&quot;);        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());        source.registerCorsConfiguration(&quot;/**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;</code></pre><p>有了config配置之后需把@CrossOrigin屏蔽掉</p><h3><span id="自定义全局过滤器">自定义全局过滤器</span></h3><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211217174019270.png" alt="image-20211217174019270"></p><p>未登录状态下购买课程显示network error</p><p>可优化用户体验，未登录状态下点击购买的话会直接跳转到登录页面</p><h2><span id="遇到问题">遇到问题</span></h2><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220131709314.png" alt="image-20211220131709314"></p><p>配置了双跨域问题</p><p><strong>原因：</strong>controller类上加了@CrossOrigin 注解，在网关配置中又配置了跨域问题</p><p><strong>解决方法：</strong>去掉@CrossOrigin 注解，保留网关配置</p><p>问题：404</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/20190620105924821.png" alt="img"></p><p><strong>原因：</strong>控制类中的mapping没有和网关配置中的path完全匹配</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/Blog\source_posts\谷粒学院项目历程2\image-20211220134104612.png" alt="image-20211220134104612"></p><p><strong>解决方法：</strong>完全匹配就好</p><h2><span id="配置中心-nacos-config">配置中心  nacos config</span></h2><p>导入依赖</p><p>远程配置中心的配置优先生效</p><p>配置动态刷新：<strong>在controller类上添加@RefershScope注解</strong></p><p>多环境配置:</p><p>在bootstrap.yml中配置环境</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220143121397.png" alt="image-20211220143121397"></p><p>然后在nacos配置中心新建配置文件，命名规则为  <strong>服务名-环境.yaml</strong></p><p>可以用名称空间做微服务隔离，结合多环境配置使用</p><p>单独配置各种服务参数</p><p><img src="/2021/12/07/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B2/image-20211220144514397.png" alt="image-20211220144514397"></p><p>然后在nacos配置中心新增配置文件</p><h2><span id="权限配置">权限配置</span></h2><h3><span id="递归操作">递归操作</span></h3><h4><span id="eg获取全部菜单">eg：获取全部菜单</span></h4><pre><code class="java">//获取全部菜单    @Override    public List&lt;Permission&gt; queryAllMenuGuli() &#123;        //1 查询菜单表所有数据        QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.orderByDesc(&quot;id&quot;);        List&lt;Permission&gt; permissionList = baseMapper.selectList(wrapper);        //2 把查询所有菜单list集合按照要求进行封装        List&lt;Permission&gt; resultList = bulidPermission(permissionList);        return resultList;    &#125;//把返回所有菜单list集合进行封装的方法    public static List&lt;Permission&gt; bulidPermission(List&lt;Permission&gt; permissionList) &#123;        //创建list集合，用于数据最终封装        List&lt;Permission&gt; finalNode = new ArrayList&lt;&gt;();        //把所有菜单list集合遍历，得到顶层菜单 pid=0菜单，设置level是1        for(Permission permissionNode : permissionList) &#123;            //得到顶层菜单 pid=0菜单            if(&quot;0&quot;.equals(permissionNode.getPid())) &#123;                //设置顶层菜单的level是1                permissionNode.setLevel(1);                //根据顶层菜单，向里面进行查询子菜单，封装到finalNode里面                finalNode.add(selectChildren(permissionNode,permissionList));            &#125;        &#125;        return finalNode;    &#125;    private static Permission selectChildren(Permission permissionNode, List&lt;Permission&gt; permissionList) &#123;        //1 因为向一层菜单里面放二层菜单，二层里面还要放三层，把对象初始化        permissionNode.setChildren(new ArrayList&lt;Permission&gt;());        //2 遍历所有菜单list集合，进行判断比较，比较id和pid值是否相同        for(Permission it : permissionList) &#123;            //判断 id和pid值是否相同            if(permissionNode.getId().equals(it.getPid())) &#123;                //把父菜单的level值+1                int level = permissionNode.getLevel()+1;                it.setLevel(level);                //如果children为空，进行初始化操作                if(permissionNode.getChildren() == null) &#123;                    permissionNode.setChildren(new ArrayList&lt;Permission&gt;());                &#125;                //把查询出来的子菜单放到父菜单里面                permissionNode.getChildren().add(selectChildren(it,permissionList));            &#125;        &#125;        return permissionNode;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;谷粒学院项目&quot;&gt;谷粒学院项目&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;redis&quot;&gt;redis&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由于客户端首页访问量比较大，所以集成一下redis&lt;/p&gt;
&lt;p&gt;当需要把分页参数和querywapper作为参数在s</summary>
      
    
    
    
    <category term="项目实战" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="谷粒学院" scheme="http://example.com/tags/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>github搜索技巧</title>
    <link href="http://example.com/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</id>
    <published>2021-12-07T02:11:31.000Z</published>
    <updated>2021-12-07T03:01:18.226Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="github搜索技巧">github搜索技巧</span></h1><p><img src="/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/e8dbfb80948296e496f574f8186d6553e61dd9ea.png@942w_659h_progressive.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;github搜索技巧&quot;&gt;github搜索技巧&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/12/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/e8dbfb80948296e496f574f8</summary>
      
    
    
    
    
    <category term="项目学习" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>谷粒学院项目历程</title>
    <link href="http://example.com/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/"/>
    <id>http://example.com/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/</id>
    <published>2021-11-11T08:52:17.000Z</published>
    <updated>2022-02-28T13:35:23.727Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="谷粒学院项目">谷粒学院项目</span></h1><h2><span id="搭建环境">搭建环境</span></h2><p>了解到非业务流程开发正好符合我之前影像系统开发的某些功能，原来是以这个名词来进行概括</p><h3><span id="项目总体架构">项目总体架构</span></h3><ul><li><input disabled type="checkbox"> common 模块的公共配置</li><li><input disabled type="checkbox"> canal_client 数据库同步模块（统计同步数据）</li><li><input disabled type="checkbox"> infrastructure：基础服务模块父节点</li><li><input disabled type="checkbox"> service api接口服务父节点</li><li><input disabled type="checkbox"> node.js做BFF层</li></ul><h2><span id="数据库">数据库</span></h2><h3><span id="分布式id">分布式ID</span></h3><p><strong>雪花算法生成</strong></p><p>它能够保证不同表的主键的不重复性，以及相同表的主键的有序性</p><p>整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p><h3><span id="自动填充">自动填充</span></h3><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等</p><p>实现：</p><p>1.<strong>数据库修改</strong></p><p>在User表中添加datetime类型的新的字段 create_time、update_time</p><p><strong>2、实体类修改</strong></p><p>实体上增加字段并添加自动填充注解</p><p><strong>3、实现元对象处理器接口</strong></p><h3><span id="批量删除">批量删除</span></h3><p>batch操作</p><h3><span id="逻辑删除">逻辑删除</span></h3><p>sql执行的是update操作</p><p>父项目只管理依赖的版本，就做到了按需加载依赖，而且版本统一</p><p><dependencymanagement>用于父项目中对子项目进行统一依赖管理</dependencymanagement></p><p>遇到问题：IDEA中删除模块后，重新创建同名模块，显示已存在该模块</p><p>解决：</p><p><strong>1.在项目区单击右键找到load/Unload Modules…unload出问题的模块就可以</strong></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xleHVlaXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3><span id="后台业务接口配置">后台业务接口配置</span></h3><h4><span id></span></h4><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211112190716874.png" alt="image-20211112190716874"></p><h3><span id="设置统一返回结果">设置统一返回结果：</span></h3><pre><code class="java">@Data@ApiModel(value = &quot;全局统一返回结果&quot;)public class R &#123;    @ApiModelProperty(value = &quot;是否成功&quot;)    private Boolean success;    @ApiModelProperty(value = &quot;返回码&quot;)    private Integer code;    @ApiModelProperty(value = &quot;返回消息&quot;)    private String message;    @ApiModelProperty(value = &quot;返回数据&quot;)    private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();    public R()&#123;&#125;    public static R ok()&#123;        R r = new R();        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());        r.setCode(ResultCodeEnum.SUCCESS.getCode());        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());        return r;    &#125;    public static R error()&#123;        R r = new R();        r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess());        r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode());        r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage());        return r;    &#125;    public static R setResult(ResultCodeEnum resultCodeEnum)&#123;        R r = new R();        r.setSuccess(resultCodeEnum.getSuccess());        r.setCode(resultCodeEnum.getCode());        r.setMessage(resultCodeEnum.getMessage());        return r;    &#125;    public R success(Boolean success)&#123;        this.setSuccess(success);        return this;    &#125;    public R message(String message)&#123;        this.setMessage(message);        return this;    &#125;    public R code(Integer code)&#123;        this.setCode(code);        return this;    &#125;    public R data(String key, Object value)&#123;        this.data.put(key, value);        return this;    &#125;    public R data(Map&lt;String, Object&gt; map)&#123;        this.setData(map);        return this;    &#125;&#125;</code></pre><h4><span id="各种状态信息返回码是由我们前端使用的vue框架决定的">各种状态信息，返回码是由我们前端使用的VUE框架决定的</span></h4><pre><code class="Java">@Getter@ToStringpublic enum ResultCodeEnum &#123;    SUCCESS(true, 20000,&quot;成功&quot;),    UNKNOWN_REASON(false, 20001, &quot;未知错误&quot;),    BAD_SQL_GRAMMAR(false, 21001, &quot;sql语法错误&quot;),    JSON_PARSE_ERROR(false, 21002, &quot;json解析异常&quot;),    PARAM_ERROR(false, 21003, &quot;参数不正确&quot;),    FILE_UPLOAD_ERROR(false, 21004, &quot;文件上传错误&quot;),    FILE_DELETE_ERROR(false, 21005, &quot;文件刪除错误&quot;),    EXCEL_DATA_IMPORT_ERROR(false, 21006, &quot;Excel数据导入错误&quot;),    VIDEO_UPLOAD_ALIYUN_ERROR(false, 22001, &quot;视频上传至阿里云失败&quot;),    VIDEO_UPLOAD_TOMCAT_ERROR(false, 22002, &quot;视频上传至业务服务器失败&quot;),    VIDEO_DELETE_ALIYUN_ERROR(false, 22003, &quot;阿里云视频文件删除失败&quot;),    FETCH_VIDEO_UPLOADAUTH_ERROR(false, 22004, &quot;获取上传地址和凭证失败&quot;),    REFRESH_VIDEO_UPLOADAUTH_ERROR(false, 22005, &quot;刷新上传地址和凭证失败&quot;),    FETCH_PLAYAUTH_ERROR(false, 22006, &quot;获取播放凭证失败&quot;),    URL_ENCODE_ERROR(false, 23001, &quot;URL编码失败&quot;),    ILLEGAL_CALLBACK_REQUEST_ERROR(false, 23002, &quot;非法回调请求&quot;),    FETCH_ACCESSTOKEN_FAILD(false, 23003, &quot;获取accessToken失败&quot;),    FETCH_USERINFO_ERROR(false, 23004, &quot;获取用户信息失败&quot;),    LOGIN_ERROR(false, 23005, &quot;登录失败&quot;),    COMMENT_EMPTY(false, 24006, &quot;评论内容必须填写&quot;),    PAY_RUN(false, 25000, &quot;支付中&quot;),    PAY_UNIFIEDORDER_ERROR(false, 25001, &quot;统一下单错误&quot;),    PAY_ORDERQUERY_ERROR(false, 25002, &quot;查询支付结果错误&quot;),    ORDER_EXIST_ERROR(false, 25003, &quot;课程已购买&quot;),    GATEWAY_ERROR(false, 26000, &quot;服务不能访问&quot;),    CODE_ERROR(false, 28000, &quot;验证码错误&quot;),    LOGIN_PHONE_ERROR(false, 28009, &quot;手机号码不正确&quot;),    LOGIN_MOBILE_ERROR(false, 28001, &quot;账号不正确&quot;),    LOGIN_PASSWORD_ERROR(false, 28008, &quot;密码不正确&quot;),    LOGIN_DISABLED_ERROR(false, 28002, &quot;该用户已被禁用&quot;),    REGISTER_MOBLE_ERROR(false, 28003, &quot;手机号已被注册&quot;),    LOGIN_AUTH(false, 28004, &quot;需要登录&quot;),    LOGIN_ACL(false, 28005, &quot;没有权限&quot;),    SMS_SEND_ERROR(false, 28006, &quot;短信发送失败&quot;),    SMS_SEND_ERROR_BUSINESS_LIMIT_CONTROL(false, 28007, &quot;短信发送过于频繁&quot;);    private Boolean success;    private Integer code;    private String message;    ResultCodeEnum(Boolean success, Integer code, String message) &#123;        this.success = success;        this.code = code;        this.message = message;    &#125;&#125;</code></pre><p>遇到问题：<strong>pom文件变橘红</strong>：idea没有识别，我们可以通过右键pom.xml文件选择Add as Maven Poject 来解决</p><p>​                    <strong>pom文件变灰</strong>：打开setting，搜索ignored<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211112212242759.png" alt="image-20211112212242759"></p><h3><span id="定义前端查询的对象">定义前端查询的对象</span></h3><p>讲师：</p><pre><code class="java">public class TeacherQueryVo implements Serializable &#123;    private static final long serialVersionUID = 1L;    @ApiModelProperty(value = &quot;讲师姓名&quot;)    private String name;    @ApiModelProperty(value = &quot;讲师级别&quot;)    private Integer level;    @ApiModelProperty(value = &quot;开始时间&quot;)    private String joinDateBegin;    @ApiModelProperty(value = &quot;结束时间&quot;)    private String joinDateEnd;&#125;</code></pre><p>关于设置自动填充类</p><p>如果没有设置的话，save方法前端以json形式返回后台数据中没有创建时间和更新时间，但是数据库中两字段为必填字段，程序就会报错</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211113135408082.png" alt="image-20211113135408082"></p><p>所以就要设置自动配置handler类</p><pre><code class="Java">@Componentpublic class CommonMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject);        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;&#125;</code></pre><h3><span id="定义统一异常处理器">定义统一异常处理器</span></h3><p>因为要返回前台，所以要统一异常处理，并以json格式返回</p><pre><code class="Java">package com.atguigu.guli.service.base.handler;import com.atguigu.guli.common.base.result.R;import com.atguigu.guli.common.base.result.ResultCodeEnum;import com.atguigu.guli.common.base.util.ExceptionUtils;import com.atguigu.guli.service.base.exception.GuliException;import lombok.extern.slf4j.Slf4j;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.jdbc.BadSqlGrammarException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zz * @since 2021/11/13 */@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)    @ResponseBody    public R error(Exception e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.error();    &#125;    @ExceptionHandler(BadSqlGrammarException.class)    @ResponseBody    public R error(BadSqlGrammarException e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.setResult(ResultCodeEnum.BAD_SQL_GRAMMAR);    &#125;    @ExceptionHandler(HttpMessageNotReadableException.class)    @ResponseBody    public R error(HttpMessageNotReadableException e) &#123;        log.error(ExceptionUtils.getMessage(e));        return R.setResult(ResultCodeEnum.JSON_PARSE_ERROR);    &#125;    @ExceptionHandler(GuliException.class)    @ResponseBody    public R error(GuliException e) &#123;        //oss的错误由这里返回前台        log.error(ExceptionUtils.getMessage(e));        return R.error().message(e.getMessage()).code(e.getCode());    &#125;&#125;</code></pre><h2><span id="oss参数配置小技巧">OSS参数配置小技巧</span></h2><p>@Data<br>@Component<br>@ConfigurationProperties(prefix = “aliyun.oss”)</p><pre><code class="java">/** * @author zz * @since 2021/11/20 * 一启动就可以从yaml文件中读取变量值 */@Data@Component@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)public class OssProperties &#123;    private String endpoint;    private String keyid;    private String keysecret;    private String bucketname;&#125;</code></pre><pre><code class="yml">aliyun:  oss:    endpoint: oss-cn-beijing.aliyuncs.com    keyid: LTAI5tHQjqR36XKKGZ4e4dxt    keysecret: ad5M6HuxGRUX0KGVCjmHBhYSCAj2i7    #bucket可以在控制台创建，也可以使用java代码创建，注意先测试bucket是否已被占用    bucketname: guli-academy-01</code></pre><h2><span id="前端">前端</span></h2><p>vue axios</p><p>跨域问题：@crossOrigin</p><p>npm</p><p><strong>安装生产环境依赖</strong>：npm install –save-dev  ***</p><p>或者 npm i -D ***</p><p>安装全局依赖：npm install –global ***</p><p>webpack进行项目打包 ，创建webpack.config.js文件：</p><pre><code class="js">const path = require(&quot;path&quot;) //Node.js内置模块module.exports = &#123;    entry: &#39;./src/main.js&#39;, //配置入口文件    output: &#123;        path: path.resolve(__dirname, &#39;./dist&#39;), //输出路径，__dirname：当前文件所在路径        filename: &#39;bundle.js&#39; //输出文件    &#125;,    module: &#123;        rules: [              &#123;                  test: /\.css$/,    //打包规则应用到以css结尾的文件上                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]            &#125;          ]      &#125;&#125;</code></pre><p>然后执行webpack –mode=development命令</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211116160418094.png" alt="image-20211116160418094"></p><p>webpack压缩</p><p>执行webpack –mode=production命令</p><p>之后这些命令都会集成在脚本里，直接执行脚本就可以了</p><p>webpack打包css</p><p>安装两个依赖</p><pre><code class="js">&quot;devDependencies&quot;: &#123;  &quot;css-loader&quot;: &quot;^3.5.2&quot;,  &quot;style-loader&quot;: &quot;^1.1.3&quot;&#125;</code></pre><p>然后在webpak.config.js文件中加上以下配置</p><pre><code class="js">module: &#123;        rules: [              &#123;                  test: /\.css$/,    //打包规则应用到以css结尾的文件上                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]            &#125;          ]      &#125;</code></pre><p>页面渲染流程：创建路由–创建API–创建页面组件</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118111357610.png" alt="image-20211118111357610"></p><p>遇到问题：<br>回显页切到新增页表单没有更新，两个页面通用一个表单，两个页面切换没有更新，因为vue会组件复用</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118113144519.png" alt="image-20211118113144519"></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118113800410.png" alt="image-20211118113800410"></p><p>需要在appmain中进行配置</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211118114000851.png" alt="image-20211118114000851"></p><pre><code class="vue">&lt;template&gt;  &lt;section class=&quot;app-main&quot;&gt;    &lt;transition name=&quot;fade-transform&quot; mode=&quot;out-in&quot;&gt;      &lt;!-- or name=&quot;fade&quot; --&gt;      &lt;!-- 如果为路由出口定义一个唯一key值，那么组件会被强制重新渲染 --&gt;      &lt;router-view :key=&quot;key&quot;/&gt;      &lt;!-- 如果路由指向的页面组件是同一个，那么路由出口显示的页面组件不会重新被渲染 --&gt;      &lt;!--      &lt;router-view/&gt;--&gt;    &lt;/transition&gt;  &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;AppMain&#39;,  // 计算属性  computed: &#123;    key() &#123;      return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>计算属性效率很高</p><h2><span id="自定义异常">自定义异常</span></h2><p>更为灵活</p><p>一般情况下自定义异常类型都为运行时异常，继承RuntimeException</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20220228200805440.png" alt="image-20220228200805440"></p><p>异常处理器对异常进行捕获抛出</p><h2><span id="注册中心和服务容错">注册中心和服务容错</span></h2><h3><span id="nacos">nacos</span></h3><p>使用它充当注册中心</p><h2><span id="负载均衡">负载均衡</span></h2><p>OpenFeign默认集成了 Ribbon， 所以在Nacos下使用OpenFeign默认就实现了负载均衡的效果</p><h2><span id="openfeign的超时控制">OpenFeign的超时控制</span></h2><p>超时后，服务消费者端默认会发起一次重试</p><h3><span id="使用jmeter测试并发">使用JMeter测试并发</span></h3><p>服务之间的雪崩效应</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211124224106908.png" alt="image-20211124224106908"></p><h3><span id="容错方案">容错方案</span></h3><p>隔离，超时，限流，熔断，降级        经典容错组件：Spring Cloud Hystrix、Sentinel。</p><h4><span id="隔离">隔离</span></h4><p>线程池隔离和信号量隔离</p><h4><span id="超时">超时</span></h4><p>所有的接口调用必须设置超时时间，不设置超时时间请求有可能陷入长期等待，甚至有可能导致整个服务不可用</p><h4><span id="限流"><strong>限流</strong></span></h4><p>限流即流量限制，或者高大上一点，叫做流量整形，限流的目的是在遇到流量高峰期或者流量突增（流量尖刺）时，把流量速率限制在系统所能接受的合理范围之内，不至于让系统被高流量击垮。限流可以保证系统在调用量猛增时的基本可用性，目前有几种常见的限流方式：</p><p>1）通过限制单位时间段内调用量来限流</p><p>2）通过限制系统的并发调用程度来限流</p><p>3）使用漏桶（Leaky Bucket）算法来进行限流</p><p>4）使用令牌桶（Token Bucket）算法来进行限流</p><h4><span id="熔断">熔断</span></h4><p>当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体可用性，可以暂时切断对下游服务的调用，这种牺牲局部，保全整体的措施就叫做熔断</p><h4><span id="降级">降级</span></h4><p>为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案</p><h3><span id="sentinel">sentinel</span></h3><p>新增流控规则</p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222458818.png" alt="image-20211125222458818" style="zoom:150%;"><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222525377.png" alt="image-20211125222525377"></p><p>在swaager中快速点击try，一秒超过两次的话就会出现下面的情况</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211125222651777.png" alt="image-20211125222651777"></p><p><strong>流量控制</strong></p><p><strong>保证自己不被上游服务压垮</strong></p><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，简单来说，就是Sentinel可以根据具体的需求来对不同的请求定义不同的控制策略。如下图所示：</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nob25nYmFvemhvbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。主要的控制方向如下：</p><ul><li><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</p></li><li><p>运行指标，例如 QPS、线程池、系统负载等；</p></li><li><p>控制的效果，例如直接限流、冷启动、排队等。</p></li></ul><p><strong>熔断降级</strong></p><p><strong>保证自己不被下游服务压垮</strong></p><p> 什么是熔断降级<br> 简单来说就是负载保护，不让服务器因为过多的并发而瘫痪。除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 Hystrix 里面描述的问题是一样的。</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nob25nYmFvemhvbmc=,size_16,color_FFFFFF,t_70#pic_center-16378508600642" alt="在这里插入图片描述"></p><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><p><strong>Sentinel熔断降级设计理念</strong><br>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。<br>Hystrix 通过线程池的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。<br>Sentinel 对这个问题采取了两种手段:</p><p>1.<strong>通过并发线程数进行限制</strong><br>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><p>2.<strong>通过响应时间对资源进行降级</strong><br>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><p><strong>负载保护</strong><br>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。<br>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2><span id="遇到问题">遇到问题：</span></h2><p>项目进行打包时没有把xml文件打包进去，导致运行sql语句时报错</p><p>解决方案：<br>pom.xml文件中配置</p><pre><code class="xml">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;</code></pre><p>然后再在application.yml文件中配置：</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211127215103746.png" alt="image-20211127215103746"></p><p><strong>com.aliyun.oss.ClientException: UnknownHost</strong></p><p>没联网！！！🤐🤐🤐</p><h2><span id="数据库优化课程管理">数据库优化（课程管理）</span></h2><p>纵向拆表</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128195950279.png" alt="image-20211128195950279"></p><p>由于有一列长文本字段数据过多，展示课程列表时并不需要这种庞杂繁多的信息，所以拆表可优化性能。</p><p>因为edu_course_description和edu_course为一对一关系，所以edu_course_description的主键生成策略应该跟随edu_course的主键生成策略。</p><pre><code class="Java">@ApiModelProperty(value = &quot;讲师ID&quot;)@TableId(value = &quot;id&quot;, type = IdType.NONE)private String id;</code></pre><pre><code class="java">private BigDecimal price;</code></pre><p>使用bigdecimal定义价格，避免精度丢失</p><p>快速赋予值</p><pre><code class="Java">BeanUtils.copyProperties( 给予=&gt;courseInfoForm, 接受=&gt;course);</code></pre><p>前段课程类别</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128212211788.png" alt="image-20211128212211788"></p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211128212227154.png" alt="image-20211128212227154"></p><p>可以使用两种方式加载资源</p><p>一次性加载（适合数据量不大）</p><p>延迟加载（适合数据量大，移动端考虑到流量问题）</p><h2><span id="多表联查">多表联查</span></h2><p>使用外联查询，因为不需查询出所有列</p><pre><code class="xml">&lt;sql id=&quot;columns&quot;&gt;    c.id,  c.title,  c.lesson_num AS lessonNum,  CONVERT(c.price, DECIMAL(8,2)) AS price,  c.cover,  c.buy_count AS buyCount,  c.view_count AS viewCount,  c.status,  c.gmt_create AS gmtCreate,  t.name AS teacherName,  s1.title AS subjectParentTitle,  s2.title AS subjectTitle&lt;/sql&gt;&lt;sql id=&quot;tables&quot;&gt;    edu_course c    LEFT JOIN edu_teacher t ON c.teacher_id = t.id    LEFT JOIN edu_subject s1 ON c.subject_parent_id = s1.id    LEFT JOIN edu_subject s2 ON c.subject_id = s2.id&lt;/sql&gt;&lt;select id=&quot;selectPageByCourseQueryVo&quot; resultType=&quot;com.atguigu.guli.service.edu.entity.vo.CourseVo&quot;&gt;    SELECT &lt;include refid=&quot;columns&quot; /&gt;    FROM &lt;include refid=&quot;tables&quot; /&gt;    $&#123;ew.customSqlSegment&#125; &lt;/select&gt;</code></pre><h3><span id="难点">难点：</span></h3><p>使用MyBatis Plus的分页插件和QueryWrapper结合自定义mapper xml实现多表关联查询</p><p>当我们需要把组装的querywapper传到mapper让mybatis自动查询时</p><p>1.<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211129204210637.png" alt="image-20211129204210637"></p><p>2.<img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211129204255198.png" alt="image-20211129204255198"></p><h3><span id="删除业务">删除业务：</span></h3><pre><code class="java"> 数据库中外键约束的设置： 互联网分布式项目中不允许使用外键与级联更新，一切设计级联的操作不要依赖数据库层，要在业务层解决 &lt;p&gt; 如果业务层解决级联删除功能 那么先删除子表数据，再删除父表数据</code></pre><h2><span id="章节管理部分">章节管理部分</span></h2><p>优化嵌套查询回显嵌套列表</p><p>优化sql语句</p><p>方案1为显示课程分类列表时使用的sql查询方法，查询效率低</p><p>方案2为在业务层解决这个问题，直接sql查询两次得出全部的数据然后在进行组装 </p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/image-20211202142759148.png" alt="image-20211202142759148"></p><h2><span id="视频上传服务">视频上传服务</span></h2><p>本地仓库导入jar包</p><pre><code class="cmd">mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar</code></pre><h2><span id="前端渲染和服务器端渲染">前端渲染和服务器端渲染</span></h2><h3><span id="1-什么是服务端渲染">1、什么是服务端渲染</span></h3><p>服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容渲染，而不是在客户端完成页面内容的渲染。</p><p>SSR并不是前端特有的技术，我们学习过的JSP技术和Thymeleaf技术就是典型的SSR</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/a9b7b10a8fbfe2d36ee20f807a174a75.png" alt="img"></p><p>服务端渲染的特点：</p><ul><li>在服务端生成html网页的dom元素</li><li>客户端（浏览器）只负责显示dom元素内容</li></ul><h3><span id="2-什么是客户端渲染">2、什么是客户端渲染</span></h3><p>客户端（浏览器） 使用AJAX向服务端发起http请 求，获取到了想要的数据，开始渲染html网页，生成dom元素，并最终将网页内容展示给用户。</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/aa49e5a9caa4641002d5608cd5acd136.png" alt="img"></p><p>客户端渲染的特点：</p><ul><li>在服务端只是给客户端响应的了数据，而不是html网页</li><li>客户端（浏览器）负责获取服务端的数据生成dom元素</li></ul><h2><span id="3-两种方式各有什么优缺点">3、两种方式各有什么优缺点？</span></h2><p><strong>客户端渲染：</strong> </p><ol><li><p>缺点：不利于网站进行SEO，因为网站大量使用javascript技术，不利于搜索引擎抓取网页。 </p></li><li><p>优点：客户端负责渲染，用户体验性好，服务端只提供数据不用关心用户界面的内容，有利于提高服务端的开发效率。 </p></li><li><p>适用场景：对SEO没有要求的系统，比如后台管理类的系统，如电商后台管理，用户管理等。</p></li></ol><p> <strong>服务端渲染：</strong> </p><ol><li><p>优点：有利于SEO，网站通过href的url将搜索引擎直接引到服务端，服务端提供优质的网页内容给搜索引擎。</p></li><li><p>缺点：服务端完成一部分客户端的工作，通常完成一个需求需要修改客户端和服务端的代码，开发效率低，不利于系统的稳定性。</p></li><li><p>适用场景：对SEO有要求的系统，比如：门户首页、商品详情页面等。</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1046667">浅析前端渲染与服务端渲染 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>那就需要一个组件来既利于seo，又利于用户体验</p><h2><span id="nuxtjs">Nuxt.js</span></h2><p>在这里指的服务器端是前端服务器</p><p>Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可以用来创建服务端渲染 (SSR) 应用，也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性</p><p>具体代码实例：</p><pre><code class="vue">  // 服务器端渲染方案：  // 异步数据获取：在前端服务器端执行，爬虫直接在页面就可以爬到具体关键字信息  asyncData() &#123;    return teacherApi.getList().then(response =&gt; &#123;      return &#123;        items: response.data.items      &#125;    &#125;)  &#125;// 客户端渲染方案//   data() &#123;//     return &#123;//       items: []//     &#125;//   &#125;,//   created() &#123;//     teacherApi.getList().then(response =&gt; &#123;//       this.items = response.data.items//     &#125;)//   &#125;</code></pre><h2><span id="前端url组装参数">前端url组装参数</span></h2><p>使用queryString组件组装</p><p><img src="/2021/11/11/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E5%8E%86%E7%A8%8B/Blog\source_posts\谷粒学院项目历程\image-20211206213423909.png" alt="image-20211206213423909"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;谷粒学院项目&quot;&gt;谷粒学院项目&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;搭建环境&quot;&gt;搭建环境&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;了解到非业务流程开发正好符合我之前影像系统开发的某些功能，原来是以这个名词来进行概括&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;</summary>
      
    
    
    
    <category term="项目实战" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="谷粒学院" scheme="http://example.com/tags/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
</feed>
